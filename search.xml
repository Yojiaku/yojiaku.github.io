<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>test_my_site</title>
      <link href="/2018/07/05/test-my-site/"/>
      <url>/2018/07/05/test-my-site/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/07/05/hello-world/"/>
      <url>/2018/07/05/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><p>顺序：<br>先：hexo clean 清除缓存</p><p>然后： hexo g 生成待发布的文件</p><p>最后： hexo d 发布</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>分块查找（Blocking Search）</title>
      <link href="/2018/06/17/BucketSort/"/>
      <url>/2018/06/17/BucketSort/</url>
      <content type="html"><![CDATA[<p>桶排序 (Bucket sort)或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。<br>桶排序以下列程序进行：</p><ol><li>设置一个定量的数组当作空桶子。</li><li>寻访序列，并且把项目一个一个放到对应的桶子去。</li><li>对每个不是空的桶子进行排序。</li><li>从不是空的桶子里把项目再放回原来的序列中。</li></ol><h2 id="代价"><a href="#代价" class="headerlink" title="代价"></a>代价</h2><p>桶排序利用函数的映射关系，减少了几乎所有的比较工作。实际上，桶排序的f(k)值的计算，其作用就相当于快排中划分，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做先进的比较排序即可。<br>对N个关键字进行桶排序的时间复杂度分为两个部分：<br>:<br>(1) 循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。<br>(2) 利用先进的比较排序算法对每个桶内的所有数据进行排序，其时间复杂度为 ∑ O(Ni*logNi) 。其中Ni 为第i个桶的数据量。</p><p>很显然，第(2)部分是桶排序性能好坏的决定因素。尽量减少桶内数据的数量是提高效率的唯一办法(因为基于比较排序的最好平均时间复杂度只能达到O(N*logN)了)。因此，我们需要尽量做到下面两点：<br>:<br>(1) 映射函数f(k)能够将N个数据平均的分配到M个桶中，这样每个桶就有[N/M]个数据量。<br>(2) 尽量的增大桶的数量。极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的“比较”排序操作。</p><p>当然，做到这一点很不容易，数据量巨大的情况下，f(k)函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。</p><p>对于N个待排数据，M个桶，平均每个桶[N/M]个数据的桶排序平均时间复杂度为：<br>O(N)+O(M<em>(N/M)</em>log(N/M))=O(N+N<em>(logN-logM))=O(N+N</em>logN-N*logM)<br>当N=M时，即极限情况下每个桶只有一个数据时。桶排序的最好效率能够达到O(N)。</p><p><strong>总结</strong>：桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。当然桶排序的空间复杂度为O(N+M)，如果输入数据非常庞大，而桶的数量也非常多，则空间代价无疑是昂贵的。此外，桶排序是稳定的。</p><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function bucket-sort(array, n) is</span><br><span class="line">  buckets ← new array of n empty lists</span><br><span class="line">  for i = 0 to (length(array)-1) do</span><br><span class="line">    insert array[i] into buckets[msbits(array[i], k)]</span><br><span class="line">  for i = 0 to n - 1 do</span><br><span class="line">    next-sort(buckets[i])</span><br><span class="line">  return the concatenation of buckets[0], ..., buckets[n-1]</span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>###C++<br>假设数据分布在[0，100)之间，每个桶内部用链表表示，在数据入桶的同时插入排序。然后把各个桶中的数据合并。<br><figure class="hljs highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BUCKET_NUM = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">explicit ListNode(int i=0):mData(i),mNext(NULL)&#123;&#125;</span><br><span class="line">ListNode* mNext;</span><br><span class="line"><span class="keyword">int</span> mData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">insert</span><span class="params">(ListNode* head,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">ListNode dummyNode;</span><br><span class="line">ListNode *newNode = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">ListNode *pre,*curr;</span><br><span class="line">dummyNode.mNext = head;</span><br><span class="line">pre = &amp;dummyNode;</span><br><span class="line">curr = head;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">NULL</span>!=curr &amp;&amp; curr-&gt;mData&lt;=val)&#123;</span><br><span class="line">pre = curr;</span><br><span class="line">curr = curr-&gt;mNext;</span><br><span class="line">&#125;</span><br><span class="line">newNode-&gt;mNext = curr;</span><br><span class="line">pre-&gt;mNext = newNode;</span><br><span class="line"><span class="keyword">return</span> dummyNode.mNext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode *head1,ListNode *head2)</span></span>&#123;</span><br><span class="line">ListNode dummyNode;</span><br><span class="line">ListNode *dummy = &amp;dummyNode;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">NULL</span>!=head1 &amp;&amp; <span class="literal">NULL</span>!=head2)&#123;</span><br><span class="line"><span class="keyword">if</span>(head1-&gt;mData &lt;= head2-&gt;mData)&#123;</span><br><span class="line">dummy-&gt;mNext = head1;</span><br><span class="line">head1 = head1-&gt;mNext;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">dummy-&gt;mNext = head2;</span><br><span class="line">head2 = head2-&gt;mNext;</span><br><span class="line">&#125;</span><br><span class="line">dummy = dummy-&gt;mNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span>!=head1) dummy-&gt;mNext = head1;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span>!=head2) dummy-&gt;mNext = head2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dummyNode.mNext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BucketSort</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;ListNode*&gt; buckets(BUCKET_NUM,(ListNode*)(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line"><span class="keyword">int</span> index = arr[i]/BUCKET_NUM;</span><br><span class="line">ListNode *head = buckets.at(index);</span><br><span class="line">buckets.at(index) = insert(head,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">ListNode *head = buckets.at(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;BUCKET_NUM;++i)&#123;</span><br><span class="line">head = Merge(head,buckets.at(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">arr[i] = head-&gt;mData;</span><br><span class="line">head = head-&gt;mNext;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> a 待排序数组元素</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> step 步长(桶的宽度/区间),具体长度可根据情况设定</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 桶的位置/索引</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> a/step;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> max=arr[<span class="number">0</span>],min=arr[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> a:arr) &#123;</span><br><span class="line">           <span class="keyword">if</span> (max&lt;a)</span><br><span class="line">               max=a;</span><br><span class="line">           <span class="keyword">if</span> (min&gt;a)</span><br><span class="line">               min=a;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//该值也可根据实际情况选择</span></span><br><span class="line">       <span class="keyword">int</span> bucketNum=max/<span class="number">10</span>-min/<span class="number">10</span>+<span class="number">1</span>;</span><br><span class="line">       List buckList=<span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">       <span class="comment">//create bucket</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=bucketNum;i++)&#123;</span><br><span class="line">           buckList.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//push into the bucket</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> index=indexFor(arr[i],<span class="number">10</span>);</span><br><span class="line">           ((ArrayList&lt;Integer&gt;)buckList.get(index)).add(arr[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       ArrayList&lt;Integer&gt; bucket=<span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bucketNum;i++)&#123;</span><br><span class="line">           bucket=(ArrayList&lt;Integer&gt;)buckList.get(i);</span><br><span class="line">           insertSort(bucket);</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> k : bucket) &#123;</span><br><span class="line">               arr[index++]=k;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//把桶内元素插入排序</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(List&lt;Integer&gt; bucket)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;bucket.size();i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> temp=bucket.get(i);</span><br><span class="line">           <span class="keyword">int</span> j=i-<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">for</span> (; j&gt;=<span class="number">0</span> &amp;&amp; bucket.get(j)&gt;temp;j--)&#123;</span><br><span class="line">               bucket.set(j+<span class="number">1</span>,bucket.get(j));</span><br><span class="line">           &#125;</span><br><span class="line">           bucket.set(j+<span class="number">1</span>,temp);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h5><ol><li><a href="https://zh.wikipedia.org/wiki/%E6%A1%B6%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">维基百科-桶排序</a></li><li><a href="https://baike.baidu.com/item/%E6%A1%B6%E6%8E%92%E5%BA%8F/4973777?fr=aladdin" target="_blank" rel="noopener">百度百科-桶排序</a></li></ol>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分块查找（Blocking Search）</title>
      <link href="/2018/06/16/Blocking_Search/"/>
      <url>/2018/06/16/Blocking_Search/</url>
      <content type="html"><![CDATA[<p>分块查找，又称索引顺序查找。它是一种性能介于顺序查找和二分查找之间的改进方法。它是为了找到 <strong>二分查找的高效但需要顺序存储</strong> 和 <strong>顺序查找可以解决元素动态变化但效率低下</strong> 之间更平衡的方法。</p><h2 id="1-基本思想"><a href="#1-基本思想" class="headerlink" title="1.基本思想"></a>1.基本思想</h2><p>①把线性表分成若干块，每块包含若干个元素<br>②块内无序，块间有序。<br>③建立一个索引表，把每块中的最大关键字值和每块的第一个元素在表中的位置和最后一个元素在表中的位置存放在索引项中。<br>④先确定待查数据元素所在的块，然后再块内顺序查找</p><h2 id="2-算法分析"><a href="#2-算法分析" class="headerlink" title="2.算法分析"></a>2.算法分析</h2><h3 id="2-1时间复杂度"><a href="#2-1时间复杂度" class="headerlink" title="2.1时间复杂度"></a>2.1时间复杂度</h3><p>分块查找算法的效率介于顺序查找和二分查找之间。</p><blockquote><p>时间复杂度为O(n)~O(log2n)</p></blockquote><h3 id="2-2平均查找长度ASL"><a href="#2-2平均查找长度ASL" class="headerlink" title="2.2平均查找长度ASL"></a>2.2平均查找长度ASL</h3><p>分块查找的平均查找长度由两部分组成，一个是对索引表进行查找的平均查找长度，一个是对快内节点进行查找的平均查找长度。<br>线性表中共有n个节点，分成大小相等的b块，每块有s=n/b个节点。</p><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/yuanJiaLi/pic/Blocking_Search_ASL.png" alt=""></p><h3 id="2-3存储结构"><a href="#2-3存储结构" class="headerlink" title="2.3存储结构"></a>2.3存储结构</h3><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/yuanJiaLi/pic/Blocking_Search_Structure.png" alt=""></p><h2 id="3-分块查找优缺点"><a href="#3-分块查找优缺点" class="headerlink" title="3.分块查找优缺点"></a>3.分块查找优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>在表中插入或删除一个记录时，只要找到该记录所属的块，然后在该块内进行插入和删除运算即可。由于块内记录的存放是任意的，所以插入或删除记录无需移动大量记录。</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>需要将待查表分块排序，并且要增加一个存储空间用来存储索引表。</p><h2 id="4-C语言实现"><a href="#4-C语言实现" class="headerlink" title="4.C语言实现"></a>4.C语言实现</h2><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">index</span> &#123;</span>  <span class="comment">//定义块的结构</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">&#125; newIndex[<span class="number">3</span>];   <span class="comment">//定义结构体数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> a[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a,<span class="keyword">const</span> <span class="keyword">void</span>* b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*(struct index*)a).key&gt;(*(struct index*)b).key?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j=<span class="number">-1</span>, k, key;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">33</span>,<span class="number">42</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">24</span>,<span class="number">48</span>, <span class="number">22</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">20</span>,  <span class="number">60</span>,<span class="number">58</span>,<span class="number">74</span>,<span class="number">49</span>,<span class="number">86</span>,<span class="number">53</span>&#125;;</span><br><span class="line">    <span class="comment">//确认模块的起始值和最大值</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">        newIndex[i].start = j+<span class="number">1</span>;  <span class="comment">//确定每个块范围的起始值</span></span><br><span class="line">        j += <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=newIndex[i].start; k&lt;=j; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newIndex[i].key&lt;a[k]) &#123;</span><br><span class="line">                newIndex[i].key=a[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对结构体按照 key 值进行排序</span></span><br><span class="line">    qsort(newIndex,<span class="number">3</span>, <span class="keyword">sizeof</span>(newIndex[<span class="number">0</span>]), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入要查询的数，并调用函数进行查找</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入您想要查找的数：\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;key);</span><br><span class="line">    k = search(key, a);</span><br><span class="line">    <span class="comment">//输出查找的结果</span></span><br><span class="line">    <span class="keyword">if</span> (k&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"查找成功！您要找的数在数组中的位置是：%d\n"</span>,k+<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"查找失败！您要找的数不在数组中。\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, startValue;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="number">3</span> &amp;&amp; key&gt;newIndex[i].key) &#123; <span class="comment">//确定在哪个块中，遍历每个块，确定key在哪个块中</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i&gt;=<span class="number">3</span>) &#123;  <span class="comment">//大于分得的块数，则返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    startValue = newIndex[i].start;  <span class="comment">//startValue等于块范围的起始值</span></span><br><span class="line">    <span class="keyword">while</span> (startValue &lt;= startValue+<span class="number">5</span> &amp;&amp; a[startValue]!=key)</span><br><span class="line">    &#123;</span><br><span class="line">        startValue++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (startValue&gt;startValue+<span class="number">5</span>) &#123;  <span class="comment">//如果大于块范围的结束值，则说明没有要查找的数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> startValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h6><p>1.百度百科——分块查找</p><p>2.<a href="http://blog.csdn.net/u013036274/article/details/49176027" title="【数据结构】静态查找之分块查找" target="_blank" rel="noopener">【数据结构】静态查找之分块查找</a></p><p>3.<a href="http://data.biancheng.net/view/56.html" target="_blank" rel="noopener">分块查找算法（索引顺序查找）及C语言实现</a></p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Prim最小生成树算法</title>
      <link href="/2018/06/15/Prim_Minimum_Spanning_Tree/"/>
      <url>/2018/06/15/Prim_Minimum_Spanning_Tree/</url>
      <content type="html"><![CDATA[<p>Prim最小生成树算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点，且其所有边的权值之和亦为最小。该算法于1930年由捷克数学家沃伊捷赫·亚尔尼克发现；并在1957年由美国计算机科学家罗伯特·普里姆独立发现；1959年，艾兹格·迪科斯彻再次发现了该算法。因此，在某些场合，普里姆算法又被称为DJP算法、亚尔尼克算法或普里姆－亚尔尼克算法。</p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>从单一顶点开始，普里姆算法按照以下步骤逐步扩大树中所含顶点的数目，直到遍及连通图的所有顶点。</p><ol><li>输入：一个加权连通图，其中顶点集合为V，边集合为E；</li><li>初始化：Vnew = {x}，其中x为集合V中的任一节点（起始点），Enew = {}；</li><li>重复下列操作，直到Vnew = V：<br>在集合E中选取权值最小的边（u, v），其中u为集合Vnew中的元素，而v则是V中没有加入Vnew的顶点（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；<br>将v加入集合Vnew中，将（u, v）加入集合Enew中；</li><li>输出：使用集合Vnew和Enew来描述所得到的最小生成树。<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2>|最小边、权的数据结构|时间复杂度（总计）|<br>|:—:|:—:|<br>|邻接矩阵、搜索|O(V²)|<br>|二叉堆（后文伪代码中使用的数据结构）、邻接表|O((V + E) log(V)) = O(E log(V))|<br>|斐波那契堆、邻接表|O(E + V log(V))|<h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2>已知图G的边数量为numEdge, 顶点数量为numVert, prim生成的树为T0, 最小生成树（MST）为Tmin<br>则有，cost(Tmin)&lt;=cost(T0)<br>设： T0 的 numVert-1 条边按照权重由小到大排列依次为：ek1, ek2, ek3, …, ekn<br>Tmin 的 numVert-1 条边按照权重由小到大排列依次为：eg1, eg2, eg3, …, egn<br>其中n=numVert-1<br>两棵树的边从小到大权重比较，设第一个属于 T0 但不属于 Tmin 的边为 ed1, 连接该边的两个顶点为 (vs, ve1)<br>同时存在第一个属于 Tmin 但不属于 T0 的边为 ed2, 连接该边的两个顶点为 (vs, ve2)。<br>两个边的起点相同。由Prim算法性质可知，w(ed2) &gt;= w(ed1)<br>此时，在 Tmin 中删除 ed2 ，添加 ed1，边的数量和顶点数量均不变，且不存在环，因此得到新的生成树Tnew,且cost(Tmin)&gt;=cost(Tnew)<br>又因为 Tmin 是MST 所以 cost(Tmin)=cost(Tnew)。<br>以此类推，cost(Tmin)=cost(T0)<br>T0是最小生成树， 得证.</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//来源：严蔚敏 吴伟民《数据结构(C语言版)》</span><br><span class="line">void MiniSpanTree_PRIM (MGraph G, VertexType u) &#123;</span><br><span class="line">    /*  用普利姆算法從第u個頂點出發構造網G 的最小生成樹T,輸出T的各條邊。</span><br><span class="line">        記錄從頂點集U到V-U的代價最小的邊的輔助數組定義：</span><br><span class="line">        struct</span><br><span class="line">        &#123;</span><br><span class="line">            VertexType adjvex;</span><br><span class="line">            VRtype lowcost;</span><br><span class="line">        &#125;closedge[MAX_VERTEX_NUM];</span><br><span class="line">    */</span><br><span class="line">    k = LocateVex(G, u);</span><br><span class="line">    for (j = 0 ; j &lt; G.vexnum; j++) &#123; //輔助數組初始化</span><br><span class="line">        if (j != k)</span><br><span class="line">            closedge[j] = &#123;u, G.arcs[k][j].adj&#125;; //&#123;adjvex, lowcost&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closedge[k].lowcost = 0; //初始，U=&#123;u&#125;</span><br><span class="line">    for (i = 1; i &lt; G.vexnum ; i++) &#123; //選擇其餘G.vexnum -1 個頂點</span><br><span class="line">        k = minimum(closedge); //求出T的下個結點：第k結點</span><br><span class="line">        //  此时 closedge[k].lowcost = MIN&#123; closedge[Vi].lowcost|closedge[Vi].lowcost&gt;0,Vi∈V-U&#125;</span><br><span class="line">        printf(closedge[k].adjvex, G.vexs[k]); //輸出生成樹的邊</span><br><span class="line">        closedge[k].lowcost = 0; //第k條邊併入U集</span><br><span class="line">        for (j = 0; j &lt; G.vexnum; j++) &#123;</span><br><span class="line">            if (G.arcs[k][j].adj &lt; closedge[j].lowcost) //新頂點併入U後重新選擇最小邊</span><br><span class="line">                closedge[j] = &#123;G.vex[k], G.arcs[k][j].adj&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class Prim &#123;</span><br><span class="line">    public static List&lt;Vertex&gt; vertexList = new ArrayList&lt;Vertex&gt;();//结点集</span><br><span class="line">    public static List&lt;Edge&gt; EdgeQueue = new ArrayList&lt;Edge&gt;();//边集</span><br><span class="line">    public static List&lt;Vertex&gt; newVertex = new ArrayList&lt;Vertex&gt;();//已经 访问过的结点</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        primTree();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void buildGraph() &#123;</span><br><span class="line">        Vertex v1 = new Vertex(&quot;a&quot;);</span><br><span class="line">        Prim.vertexList.add(v1);</span><br><span class="line">        Vertex v2 = new Vertex(&quot;b&quot;);</span><br><span class="line">        Prim.vertexList.add(v2);</span><br><span class="line">        Vertex v3 = new Vertex(&quot;c&quot;);</span><br><span class="line">        Prim.vertexList.add(v3);</span><br><span class="line">        Vertex v4 = new Vertex(&quot;d&quot;);</span><br><span class="line">        Prim.vertexList.add(v4);</span><br><span class="line">        Vertex v5 = new Vertex(&quot;e&quot;);</span><br><span class="line">        Prim.vertexList.add(v5);</span><br><span class="line">        addEdge(v1, v2, 6);</span><br><span class="line">        addEdge(v1, v3, 7);</span><br><span class="line">        addEdge(v2, v3, 8);</span><br><span class="line">        addEdge(v2, v5, 4);</span><br><span class="line">        addEdge(v2, v4, 5);</span><br><span class="line">        addEdge(v3, v4, 3);</span><br><span class="line">        addEdge(v3, v5, 9);</span><br><span class="line">        addEdge(v5, v4, 7);</span><br><span class="line">        addEdge(v5, v1, 2);</span><br><span class="line">        addEdge(v4, v2, 2);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void addEdge(Vertex a, Vertex b, int w) &#123;</span><br><span class="line">        Edge e = new Edge(a, b, w);</span><br><span class="line">        Prim.EdgeQueue.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void primTree() &#123;</span><br><span class="line">        buildGraph();</span><br><span class="line">        Vertex start = vertexList.get(0);</span><br><span class="line">        newVertex.add(start);</span><br><span class="line">        for (int n = 0; n &lt; vertexList.size() - 1; n++) &#123;</span><br><span class="line">            Vertex temp = new Vertex(start.key);</span><br><span class="line">            Edge tempedge = new Edge(start, start, 1000);</span><br><span class="line">            for (Vertex v : newVertex) &#123;</span><br><span class="line">                for (Edge e : EdgeQueue) &#123;</span><br><span class="line">                    if (e.start == v &amp;&amp; !containVertex(e.end)) &#123;</span><br><span class="line">                        if (e.key &lt; tempedge.key) &#123;</span><br><span class="line">                            temp = e.end;</span><br><span class="line">                            tempedge = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            newVertex.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        Iterator it = newVertex.iterator();</span><br><span class="line">        while (it.hasNext()) &#123;</span><br><span class="line">            Vertex v = (Vertex) it.next();</span><br><span class="line">            System.out.println(v.key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static boolean containVertex(Vertex vte) &#123;</span><br><span class="line">        for (Vertex v : newVertex) &#123;</span><br><span class="line">            if (v.key.equals(vte.key))</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Vertex &#123;</span><br><span class="line">    String key;</span><br><span class="line">    Vertex(String key) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Edge &#123;</span><br><span class="line">    Vertex start;</span><br><span class="line">    Vertex end;</span><br><span class="line">    int key;</span><br><span class="line">    Edge(Vertex start, Vertex end, int key) &#123;</span><br><span class="line">        this.start = start;</span><br><span class="line">        this.end  = end;</span><br><span class="line">        this.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><ol><li><a href="https://zh.wikipedia.org/wiki/%E6%99%AE%E6%9E%97%E5%A7%86%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">维基百科-普林姆算法</a></li></ol>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>区块链的技术原理和意义（论文祥读）</title>
      <link href="/2018/06/10/blockchainPage1/"/>
      <url>/2018/06/10/blockchainPage1/</url>
      <content type="html"><![CDATA[<h3 id="文章重点"><a href="#文章重点" class="headerlink" title="文章重点"></a>文章重点</h3><p>区块链技术原理、数据结构、运行机制、区块链的分叉</p><h3 id="区块链技术原理"><a href="#区块链技术原理" class="headerlink" title="区块链技术原理"></a>区块链技术原理</h3><blockquote><p>前言：今天在学校上了一门有关银行金融的课程，了解到一个术语<code>financial intermediation</code>——金融中介，早期的银行直至现在贷款人和被贷款人依旧采取中介的方式进行交易，究其原因是现在的交易是基于信用。<br>而区块链打破的正是基于信用的交易方式，它假设交易双方互不信任，完全依靠密码学原理进行交易和记账，由此打破交易需要第三方介入的传统贸易方式。</p></blockquote><h4 id="区块链定义和特点"><a href="#区块链定义和特点" class="headerlink" title="区块链定义和特点"></a>区块链定义和特点</h4><p>区块链，顾名思义，很容易就联想到<code>链表</code>这一数据结构。实际上，区块链就是一种分布式<em><code>(1)</code></em>数据库，通过去中心化<em><code>(2)</code></em>、去信任的方式，集体维护一个可靠数据库。<br>传统数据库的4中操作可以简写为CURD，C表示创建（create）、U表示更新（update）、R表示读取（read）、D表示删除（delete）。<br>而区块链作为分布式数据库，相当于放弃了更新（U）和删除（D）这两个操作，用“<code>无法篡改</code>”和“<code>不可抵赖</code>”两个重要特点代替，依托P2P网络提供的分布式端对端网络的特点，可将之归结为<code>CROSS</code>原则：</p><ul><li>C（create）：创建</li><li>R（retrieve）：可溯，依托区块彼此相连的链式结构，用户可以追溯至最初交易来查看整个交易过程（想象拉链，总能通过任一个链条项找到其他任意链条项）</li><li>O（open）：开放，任何一个人都可以通过接入P2P网络来记账</li><li>S（security）：安全，基于密码学的安全通信，以及工作量证明机制，无人可以篡改数据库中的数据</li><li>S（stable）：稳定，系统中任何节点的退出，都不会影响到整个系统的稳定性，不会遇到中心化节点通常遇到的“单点故障”问题。</li></ul><p>由此可见，具有CROSS特点的区块链技术极有可能改变现有的交易模式。传统的交易中，商家和消费者之间难以做到完全信任，为了保证对方是可信的，常常需要国家信用背书或者企业背书的第三方机构。商家和消费者为了证明自己合规，需要自己把自己部分的材料都汇聚到第三方机构，能想象一下这冗长的手续以及额外的费用，这也常常使得交易滞后。区块链技术则逐步实现去中心化、去中介，实现消费者和商家之间直接支付，减去了中间不必要的时间。</p><h4 id="区块链的技术原语"><a href="#区块链的技术原语" class="headerlink" title="区块链的技术原语"></a>区块链的技术原语</h4><p>主要运用了4个基础技术——哈希运算（SHA256）、数字签名、P2P网络、工作量证明（PoW）</p><h5 id="哈希加密算法（SHA256）"><a href="#哈希加密算法（SHA256）" class="headerlink" title="哈希加密算法（SHA256）"></a>哈希加密算法（SHA256）</h5><p>将任何一串数据输入到SHA256都能得到一个256位的<code>Hash值</code>（散列值），特点：相同的数据输入将得到相同的结果，输入数据只要稍有变化，则将得到一个千差万别的结果，且结果无法事先预知——我们不能通过找规律的方式找到这个Hash值。</p><h5 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h5><p>通常数字签名是基于椭圆曲线加密技术的公私钥来实现，有两个很重要的概念：</p><ol><li>公私钥是非对称加密技术，公钥和私钥不同，但是可以基于私钥生成公钥。</li><li>相关性，公钥加密的，对应的私钥才能解密。私钥加密的内容，对应的公钥才能解密。</li></ol><h5 id="P2P网络"><a href="#P2P网络" class="headerlink" title="P2P网络"></a>P2P网络</h5><p>P2P网络分为有结构和无结构，区别在于路由规则的制定方面。<br>有结构的P2P网络，例如Chord，利用<code>一致性哈希表（DHT）</code>构建每个节点的路由表。<br>无结构的P2P网络代表是Gnutella，节点之间的路由靠广播的方式。一个节点要想查找一个文件，首先问其邻居有没有这个文件，他的邻居再问各自的邻居有没有，这样迭代，容易形成<code>广播风暴</code>，因此一般设置一个网络TTL，来限制广播传播的范围。<br>区块链采用的是无结构P2P网络。</p><h5 id="工作量证明机制"><a href="#工作量证明机制" class="headerlink" title="工作量证明机制"></a>工作量证明机制</h5><p>相当于一份工作证明，确认你做过一定量的工作。工作量是信任产生的基础，在区块链中，我们通过解决一个数学难题来证明自己的工作量。<br>这个数据难题就是，对一个数字串进行两次SHA256运算，如果得到的数小于一个指定的值，就算成功。否则，要通过不断的尝试试错，来求解这个数。一般来说，指定的结果值，前面都是多个零开头。</p><h4 id="区块链的数据结构"><a href="#区块链的数据结构" class="headerlink" title="区块链的数据结构"></a>区块链的数据结构</h4><p>一个区块链依托于一个P2P网络。<br>节点可以有 4 种功能，即钱包、完整的区块链拷贝、挖矿和路由。<br><code>路由</code>功能是每个节点必需的，前3个功能，根据节点自己的需求来定。<br>对于一个区块链拷贝来说，它记录了从 2009 年，中本聪建立创世区块以来，系统运行时记录的所有交易记录。<br>区块链分为区块头和区块体。<br>区块头包含版本号、上一个区块的哈希值、Merkle根节点哈希值、时间戳、难度值、随机数和交易记录这些字段。<br>区块与区块之间彼此相连，构成的一个链式结构，叫做区块链。这跟以前编写C语言，用指针实现链表是一个道理。不过，这里的指针不是内存地址，而是将上一个区块的区块头，使用两次SHA256加密算法，得到的哈希值。</p><blockquote><p>区块头没有包含任何交易记录信息，怎么能保证交易记录不被篡改？</p></blockquote><p>答案是，为了提高区块链的校验效率，把一个区块里的所有交易记录，构建成Merkle树这样的二叉树结构。如下图（c）所示，如果交易记录是奇数，图中的 3 个记录，剩下的二叉树节点由自己填补：图中的交易 2 和自己构成了一个二叉树。以此类推，直到根节点。二叉树的两个交易记录哈希值直接串联，作为下一个二叉树的输入。通过这种方式，如果有人更改任何一个交易记录，按照前面 SHA256 加密哈希的特性，Merkle根节点就会变动很大，以致其他节点在验证区块链的哈希值时，能够很明显地发现问题。</p><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/blog/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%BB%93%E6%9E%84.png" alt="图 区块链的数据结构"></p><h4 id="区块链的运行机制"><a href="#区块链的运行机制" class="headerlink" title="区块链的运行机制"></a>区块链的运行机制</h4><p>用户A想把比特币支付给用户B，首先要知道用户 B 的钱包地址。B 可以通过钱包，产生一对公私钥，通过一些处理，得到新的私钥和钱包 B的地址。通过数字签名，B 将钱包地址发给 A。A 根据 B 的地址，发起一个交易，通过自己的数字签名授权，将这个交易发给 B，这时 B 已经收到了这些比特币，但是还不能用，因为没有得到系统的确认。之后，A向全网内所有人广播，告诉其他节点有关交易的信息。类似的交易重复发生，直到区块确权时间到，矿工们开始竞争记账权。首先，计算Merkle根节点的哈希值，然后不断调整区块头中的随机数，争取小于系统的设定值，此为工作量证明。第一个算出结果的矿工，得到系统给予的比特币奖励，也向全网广播这个消息。其他节点在收到该消息时，结束工作量证明，并对区块进行验证（随机数），如果验证合格，将区块接入到区块链的末尾。具体如下图：</p><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/blog/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.png" alt="图 区块链的运行机制"></p><p>相关技术细节：</p><ul><li><p>地址生成机制<br>B通过钱包，生成256位的私钥，基于椭圆曲线加密算法，得到有前缀的512位公钥哈希字符串；经过SHA256算法，得到256位的哈希加密字符串；通过RIPEMD160算法，得到160位的公钥哈希字符串；使用Base58算法，将二进制字符串翻译成人眼可识别的字符串，也就是B钱包的地址。</p></li><li><p>消息交互机制</p></li><li>区块确认机制<br>上下文固定，只能通过随机数的不断尝试来进行暴力破解，争取小于系统要求的门限值。最后的胜出者将区块链入区块链的末尾（<strong>只是链接到末尾，而不是确认</strong>）。区块链为了防止<code>51%</code>攻击，延迟<code>6个区块</code>再对这个区块进行确认。</li></ul><h4 id="区块链的分叉和51-攻击"><a href="#区块链的分叉和51-攻击" class="headerlink" title="区块链的分叉和51%攻击"></a>区块链的分叉和51%攻击</h4><p>分叉：指同一时间段内全网不止一个节点能计算出随机数，即会有多个节点在网络中广播它们各自打包好的临时区块。<br>某一节点若收到多个针对同一个前续区块的后续临时区块，则该节点会在本地区块链上建立分支，多个临时区块对应多个分支。<br>需要等到下一个工作量证明被发现，而其中一个分支被证实为最长的一条，那么在另一条分支链条上工作的节点将转换阵营，开始在较长的区块链条上工作，而其他分支将会被网络彻底抛弃。<br>51%攻击则是由区块链的分叉衍生出来的。</p>]]></content>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Algorithm-二维数组中的查找-BinarySearch</title>
      <link href="/2018/03/28/BinarySearch/"/>
      <url>/2018/03/28/BinarySearch/</url>
      <content type="html"><![CDATA[<h1 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h1><blockquote><p>题目描述<br>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></blockquote><h2 id="最简单的思路"><a href="#最简单的思路" class="headerlink" title="最简单的思路"></a>最简单的思路</h2><p>对每行采用二分查找，时间复杂度是O(nlogn)</p><h2 id="JavaScript实现"><a href="#JavaScript实现" class="headerlink" title="JavaScript实现"></a>JavaScript实现</h2><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js-binary search-iterative</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearchIterative</span>(<span class="params">a, value</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> mid, lo = <span class="number">0</span>,</span><br><span class="line">      hi = a.length - <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">    mid = <span class="built_in">Math</span>.floor((lo + hi) / <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">      hi = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">      lo = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Find</span>(<span class="params">target, array</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> row = array.length;</span><br><span class="line">    <span class="keyword">let</span> colFirst = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;row; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> result = binarySearchIterative(array[i], target);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> BinarySearch Algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS逻辑或运算符</title>
      <link href="/2018/03/26/JS%E9%80%BB%E8%BE%91%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2018/03/26/JS%E9%80%BB%E8%BE%91%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript逻辑或运算符"><a href="#JavaScript逻辑或运算符" class="headerlink" title="JavaScript逻辑或运算符"></a>JavaScript逻辑或运算符</h1><p>JScript 使用下面的规则来把非 Boolean 值转换为 Boolean 值： </p><ul><li>所有对象都被认为是 true。 </li><li>字符串当且仅当为空时才被认为是 false。 </li><li>null 和 undefined 被认为是 false。 </li><li>数字当且仅当为 0 时才是 false。 </li></ul>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS逻辑与运算符</title>
      <link href="/2018/03/26/JS%E9%80%BB%E8%BE%91%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2018/03/26/JS%E9%80%BB%E8%BE%91%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript逻辑“与”运算符"><a href="#JavaScript逻辑“与”运算符" class="headerlink" title="JavaScript逻辑“与”运算符"></a>JavaScript逻辑“与”运算符</h1><p>当且仅当两个表达式的值都等于 True 时， result 才是 True。如果任一表达式的值等于 False， 则 result 为 False。 </p><p>JScript 使用下面的规则，来把非 Boolean 值转换为 Boolean 值： </p><ul><li>所有对象都被认为是 true。 </li><li>字符串当且仅当为空时被认为是 false。 </li><li>null 和 undefined 被认为是 false。 </li><li>数字当且仅当为零时是 false。 </li></ul>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS-Global</title>
      <link href="/2018/03/26/JS-Global/"/>
      <url>/2018/03/26/JS-Global/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript-Global方法"><a href="#JavaScript-Global方法" class="headerlink" title="JavaScript Global方法"></a>JavaScript Global方法</h1><h2 id="isNaN方法"><a href="#isNaN方法" class="headerlink" title="isNaN方法"></a>isNaN方法</h2><p>返回一个 Boolean 值，指明提供的值是否是保留值 NaN （不是数字）。 </p><p>isNaN(numValue)</p><p>必选项 numvalue 参数为要检查是否为 NAN 的值。 </p><p>说明<br>如果值是 NaN， 那么 isNaN 函数返回 true ，否则返回 false 。 使用这个函数的典型情况是检查 parseInt 和 parseFloat 方法的返回值。 </p><p>还有一种办法，变量可以与它自身进行比较。 如果比较的结果不等，那么它就是 NaN 。 这是因为 NaN 是唯一与自身不等的值。 </p><h2 id="isFinite-方法"><a href="#isFinite-方法" class="headerlink" title="isFinite 方法"></a>isFinite 方法</h2><p>返回一个 Boolean 值,指明所提供的数字是否是有限的。</p><p>isFinite(number)</p><p>必选项 number 参数为任意的数值。 </p><p>说明<br>如果 number 不是 NaN 、负无穷或正无穷，那么 isFinite 方法将返回 true 。 如果是这三种情况，函数返回 false 。 </p><h2 id="parseInt-方法"><a href="#parseInt-方法" class="headerlink" title="parseInt 方法"></a>parseInt 方法</h2><p>返回由字符串转换得到的整数。</p><p>parseInt(numString, [radix])</p><p>参数<br>numString</p><p>必选项。要转换为数字的字符串。</p><p>radix</p><p>可选项。在 2 和 36 之间的表示 numString 所保存数字的进制的值。如果没有提供，则前缀为 ‘0x’ 的字符串被当作十六进制，前缀为 ‘0’ 的字符串被当作八进制。所有其它字符串都被当作是十进制的。</p><p>说明<br>parseInt 方法返回与保存在 numString 中的数字值相等的整数。如果 numString 的前缀不能解释为整数，则返回 NaN（而不是数字）。 </p><p>parseInt(“abc”)     // 返回 NaN。<br>parseInt(“12abc”)   // 返回 12。<br>可以用 isNaN 方法检测 NaN。 </p><h2 id="parseFloat-方法"><a href="#parseFloat-方法" class="headerlink" title="parseFloat 方法"></a>parseFloat 方法</h2><p>返回由字符串转换得到的浮点数。 </p><p>parseFloat(numString)</p><p>必选项 numString 参数是包含浮点数的字符串。 </p><p>说明<br>parseFloat 方法返回与 numString 中保存的数相等的数字表示。如果 numString 的前缀不能解释为浮点数，则返回 NaN （而不是数字）。</p><p>parseFloat(“abc”)      // 返回 NaN。<br>parseFloat(“1.2abc”)   // 返回 1.2。<br>可以用 isNaN 方法检测 NaN。 </p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS函数创建</title>
      <link href="/2018/03/26/JS%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA/"/>
      <url>/2018/03/26/JS%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript函数创建"><a href="#JavaScript函数创建" class="headerlink" title="JavaScript函数创建"></a>JavaScript函数创建</h1><h2 id="caller属性"><a href="#caller属性" class="headerlink" title="caller属性"></a>caller属性</h2><p>返回一个对函数的引用，该函数调用了当前函数。</p><p>functionName.caller </p><p>functionName 对象是所执行函数的名称。</p><p>对于函数来说，caller 属性只有在函数执行时才有定义。 如果函数是由 JScript 程序的顶层调用的，那么 caller 包含的就是 null 。</p><p>如果在字符串上下文中使用 caller 属性，那么结果和 functionName.toString 一样，也就是说，显示的是函数的反编译文本。</p><h2 id="arguments属性"><a href="#arguments属性" class="headerlink" title="arguments属性"></a>arguments属性</h2><p>为当前执行的 function 对象返回一个arguments 对象。</p><p>function.arguments</p><p>function 参数是当前执行函数的名称，可以省略。 </p><p>通过 arguments 属性，函数可以处理可变数量的参数。 arguments 对象的 length 属性包含了传递给函数的参数的数目。对于arguments 对象所包含的单个参数，其访问方法与数组中所包含的参数的访问方法相同。</p><h2 id="length属性"><a href="#length属性" class="headerlink" title="length属性"></a>length属性</h2><p>返回函数定义的参数数目。 </p><p>functionName.length</p><p>所必须的functionName 参数是被讨论的函数的名称。 </p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS-throw语句</title>
      <link href="/2018/03/26/JS-throw%E8%AF%AD%E5%8F%A5/"/>
      <url>/2018/03/26/JS-throw%E8%AF%AD%E5%8F%A5/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript-throw语句"><a href="#JavaScript-throw语句" class="headerlink" title="JavaScript throw语句"></a>JavaScript throw语句</h1><p>产生一个能被 try…catch…finally 语句处理的错误情形。 </p><p>throw exception </p><p>必选的 exception 参数可以是任何表达式。 </p><p>说明<br>下面的例子根据传递进来的值扔出一个错误，然后举例说明那个错误是如何在 try…catch…finally语句的层次中被处理的： </p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TryCatchDemo</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (x == <span class="number">0</span>)   <span class="comment">// 估参数的值。</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="string">"x equals zero"</span>;   <span class="comment">// 扔出一个错误。</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="string">"x does not equal zero"</span>;   <span class="comment">// 扔出一个不同的错误。</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span>(e) &#123;   <span class="comment">// 在这儿处理 "x = 0" 的错误。</span></span><br><span class="line">         <span class="keyword">if</span> (e == <span class="string">"x equals zero"</span>)   <span class="comment">// 检查错误能否在这儿被处理。</span></span><br><span class="line">            <span class="keyword">return</span>(e + <span class="string">" handled locally."</span>);   <span class="comment">// 返回对象错误消息。</span></span><br><span class="line">         <span class="keyword">else</span>   <span class="comment">// 不能在这儿处理这个错误。</span></span><br><span class="line">            <span class="keyword">throw</span> e;   <span class="comment">// 重新扔出该错误给下一个</span></span><br><span class="line">      &#125;   <span class="comment">// 错误处理程序。</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span>(e) &#123;   <span class="comment">// 在此处理其他错误。</span></span><br><span class="line">      <span class="keyword">return</span>(e + <span class="string">" handled higher up."</span>);   <span class="comment">// 返回错误消息。</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.write(TryCatchDemo(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">document</span>.write(TryCatchDemo(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS日期时间</title>
      <link href="/2018/03/26/JS%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4/"/>
      <url>/2018/03/26/JS%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript日期和时间"><a href="#JavaScript日期和时间" class="headerlink" title="JavaScript日期和时间"></a>JavaScript日期和时间</h1><h2 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h2><p>启用基本存储器并取得日期和时间。</p><p>dateObj = new Date()<br>dateObj = new Date(dateVal)<br>dateObj = new Date(year, month, date[, hours[, minutes[, seconds[,ms]]]]) </p><p>dateVal</p><p>必选项。如果是数字值，dateVal 表示指定日期与 1970 年 1 月 1 日午夜间全球标准时间 的毫秒数。如果是字符串，则 dateVal 按照 parse 方法中的规则进行解析。dateVal 参数也可以是从某些 ActiveX(R) 对象返回的 VT_DATE 值</p><p>year</p><p>必选项。完整的年份，比如，1976（而不是 76）。</p><p>month</p><p>必选项。表示的月份，是从 0 到 11 之间的整数（ 1 月至 12 月）。</p><p>date</p><p>必选项。表示日期，是从 1 到 31 之间的整数。</p><p>hours</p><p>可选项。 如果提供了 minutes 则必须给出。表示小时，是从 0 到 23 的整数（午夜到 11pm）。</p><p>Date 对象保存以毫秒为单位表示特定时间段。如果某个参数的值大于其范围或为负数，则存储的其他值将做相应的调整。例如，如果指定 150 秒，JScript 将该数字重新定义为 2 分 30 秒。 </p><p>如果数字为 NaN，则表示该对象不代表特定的时间段。如果未向 Date 对象传递参数，它将被初始化为当前时间 (UTC)。在能够使用该对象前必须为其赋值。 </p><p>Date 对象能够表示的日期范围约等于 1970 年 1 月 1 日前后各 285,616 年。 </p><p>Date 对象具有两个不创建 Date 对象就可以调用的静态方法。它们是 parse 和 UTC。</p><h2 id="getDate方法"><a href="#getDate方法" class="headerlink" title="getDate方法"></a>getDate方法</h2><p>返回Date对象中庸本地时间表示的一个月的日期值</p><p>dateObj.getDate() </p><p>要获取用全球标准时间 (UTC)表示的日期值，请使用 getUTCDate 方法。 </p><p>返回值是一个处于 1 到 31 之间的整数，它代表了相应的 Date 对象中的日期值。</p><h2 id="getDay方法"><a href="#getDay方法" class="headerlink" title="getDay方法"></a>getDay方法</h2><p>返回 Date 对象中用本地时间表示的一周中的日期值。 </p><p>dateObj.getDay()</p><p>要获取用全球标准时间 (UTC)表示的一周中日期值，请使用 getUTCDay 方法。</p><p>getDay 方法所返回的值是一个处于 0 到 6 之间的整数，它代表了一周中的某一天，返回值与一周中日期的对应关系如下： </p><table><thead><tr><th>值</th><th>星期</th></tr></thead><tbody><tr><td>0</td><td>星期天</td></tr><tr><td>1</td><td>星期一</td></tr><tr><td>2</td><td>星期二</td></tr><tr><td>3</td><td>星期三</td></tr><tr><td>4</td><td>星期四</td></tr><tr><td>5</td><td>星期五</td></tr><tr><td>6</td><td>星期六</td></tr></tbody></table>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JSNull</title>
      <link href="/2018/03/26/JSNull/"/>
      <url>/2018/03/26/JSNull/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript-Null"><a href="#JavaScript-Null" class="headerlink" title="JavaScript Null"></a>JavaScript Null</h1><p>null 值指出一个变量中没有包含有效的数据。产生 null 的原因是： </p><ul><li>对一个变量显式地赋值为 null。 </li><li>包含 null 的表达式之间的任何操作。 </li></ul>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS数组处理</title>
      <link href="/2018/03/26/JS%E6%95%B0%E7%BB%84%E5%A4%84%E7%90%86/"/>
      <url>/2018/03/26/JS%E6%95%B0%E7%BB%84%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript数组处理"><a href="#JavaScript数组处理" class="headerlink" title="JavaScript数组处理"></a>JavaScript数组处理</h1><p>Array, concat, join, length, reverse, slice, sort</p><h2 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象"></a>Array对象</h2><p>提供对创建任何数据类型的数组的支持。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arrayObj = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line">arrayObj = <span class="keyword">new</span> <span class="built_in">Array</span>([size])</span><br><span class="line">arrayObj = <span class="keyword">new</span> <span class="built_in">Array</span>([element0[, element1[, ...[, elementN]]]])</span><br></pre></td></tr></table></figure><h2 id="concat方法（Array）"><a href="#concat方法（Array）" class="headerlink" title="concat方法（Array）"></a>concat方法（Array）</h2><p>返回一个新数组，这个新数组是由两个或更多数组组合而成。</p><p>array1.concat([item1[, item2[, . . . [, itemN]]]])</p><p>concat 方法返回一个 Array 对象，其中包含了 array1 和提供的任意其他项目的连接。</p><p>要加的项目（item1 … itemN）会按照从左到右的顺序添加到数组。如果某一项为数组，那么添加其内容到 array1 的末尾。如果该项目不是数组，就将其作为单个的数组元素添加到数组的末尾。</p><p>以下为从源数组复制元素到结果数组： </p><ul><li>对于从正被连接到新数组的数组中复制的对象参数，复制后仍然指向相同的对象。不论新数组和源数组中哪一个有改变，都将引起另一个的改变。 </li><li>对于连接到新数组的数值或字符串，只复制其值。一个数组中值有改变并不影响另一个数组中的值。 </li></ul><h2 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h2><p>返回字符串值，其中包括连接道一起的数组的所有元素，元素由指定分隔符分开。</p><p>arrayObj.join(separator)</p><p>如果数组中有元素没有定义或者为 null，将其作为空字符串处理。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JoinDemo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> a, b;</span><br><span class="line">   a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">   b = a.join(<span class="string">"-"</span>);</span><br><span class="line">   <span class="keyword">return</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reverse方法"><a href="#reverse方法" class="headerlink" title="reverse方法"></a>reverse方法</h2><p>返回一个元素顺序被反转的Array对象。</p><p>arrayObj.reverse( )</p><p>reverse 方法将一个 Array 对象中的元素位置进行反转。在执行过程中，这个方法并不会创建一个新的 Array 对象。 </p><p>如果数组是不连续的，reverse 方法将在数组中创建元素以便填充数组中的间隔。这样所创建的全部元素的值都是 undefined。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReverseDemo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> a, l;                  <span class="comment">// 声明变量。</span></span><br><span class="line">   a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);  <span class="comment">// 创建数组并赋值。</span></span><br><span class="line">   l = a.reverse();           <span class="comment">// 反转数组的内容。</span></span><br><span class="line">   <span class="keyword">return</span>(l);                 <span class="comment">// 返回结果数组。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="slice方法（Array）"><a href="#slice方法（Array）" class="headerlink" title="slice方法（Array）"></a>slice方法（Array）</h2><p>返回一个数组的一段。</p><p>arrayObj.slice(start, [end]) </p><p>slice 方法返回一个 Array 对象，其中包含了 arrayObj 的指定部分。 </p><p>slice 方法一直复制到 end 所指定的元素，但是不包括该元素。如果 start 为负，将它作为 length + start处理，此处 length 为数组的长度。如果 end 为负，就将它作为 length + end 处理，此处 length 为数组的长度。如果省略 end ，那么 slice 方法将一直复制到 arrayObj 的结尾。如果 end 出现在 start 之前，不复制任何元素到新数组中。</p><h2 id="sort方法"><a href="#sort方法" class="headerlink" title="sort方法"></a>sort方法</h2><p>返回一个元素已经排序的Array对象。</p><p>arrayobj.sort(sortfunction) </p><p>sortFunction</p><p>可选项。是用来确定元素顺序的函数的名称。如果这个参数被省略，那么元素将按照 ASCII 字符顺序进行升序排列。 </p><p>sort 方法将 Array 对象进行适当的排序；在执行过程中并不会创建新的 Array 对象。 </p><p>如果为 sortfunction 参数提供了一个函数，那么该函数必须返回下列值之一： </p><ul><li>负值，如果所传递的第一个参数比第二个参数小。 </li><li>零，如果两个参数相等。 </li><li>正值，如果第一个参数比第二个参数大。 </li></ul>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript创建高级对象</title>
      <link href="/2018/03/26/JavaScript%E5%88%9B%E5%BB%BA%E9%AB%98%E7%BA%A7%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/03/26/JavaScript%E5%88%9B%E5%BB%BA%E9%AB%98%E7%BA%A7%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript创建高级对象"><a href="#JavaScript创建高级对象" class="headerlink" title="JavaScript创建高级对象"></a>JavaScript创建高级对象</h1><h2 id="使用构造函数"><a href="#使用构造函数" class="headerlink" title="使用构造函数"></a>使用构造函数</h2><p>构造函数是一个函数，调用它来例示并初始化特殊类型的对象。可以使用 new 关键字来调用一个构造函数。下面给出了使用构造函数的新示例。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = <span class="keyword">new</span> <span class="built_in">Object</span>();             <span class="comment">// 创建没有属性的通用对象。</span></span><br><span class="line"><span class="keyword">var</span> myBirthday = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1961</span>, <span class="number">5</span>, <span class="number">10</span>);  <span class="comment">// 创建一个 Date 对象。</span></span><br><span class="line"><span class="keyword">var</span> myCar = <span class="keyword">new</span> Car();                   <span class="comment">// 创建一个用户定义的对象，并初始化其属性。</span></span><br></pre></td></tr></table></figure><p>通过构造函数将一个参数作为特定的 this 关键字的值传递给新创建的空对象。然后构造函数负责为新对象执行适应的初始化（创建属性并给出其初始值）。完成后，构造函数返回它所构造的对象的一个参数。</p><h2 id="使用原型"><a href="#使用原型" class="headerlink" title="使用原型"></a>使用原型</h2><p>在编写构造函数时，可以使用原型对象（它本身是所有构造函数的一个属性）的属性来创建继承属性和共享方法。原型属性和方法将按引用复制给类中的每个对象，因此它们都具有相同的值。可以在一个对象中更改原型属性的值，新的值将覆盖默认值，但仅在该实例中有效。属于这个类的其他对象不受此更改的影响。下面给出了使用自定义构造函数的示例，Circle（注意 this 关键字的使用）。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Circle.prototype.pi = <span class="built_in">Math</span>.PI;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ACirclesArea</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.pi * <span class="keyword">this</span>.r * <span class="keyword">this</span>.r; <span class="comment">// 计算圆面积的公式为 ?r2。</span></span><br><span class="line">&#125;</span><br><span class="line">Circle.prototype.area = ACirclesArea; <span class="comment">// 计算圆面积的函数现在是 Circle Prototype 对象的一个方法。</span></span><br><span class="line"><span class="keyword">var</span> a = ACircle.area();               <span class="comment">// 此为如何在 Circle 对象上调用面积函数。</span></span><br></pre></td></tr></table></figure><p>使用这个原则，可以给预定义的构造函数（都具有原型对象）定义附加属性。例如，如果想要能够删除字符串的前后空格（与 VBScript 的 Trim 函数类似），就可以给 String 原型对象创建自己的方法。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加一个名为 trim 的函数作为</span></span><br><span class="line"><span class="comment">// String 构造函数的原型对象的一个方法。</span></span><br><span class="line"><span class="built_in">String</span>.prototype.trim = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 用正则表达式将前后空格</span></span><br><span class="line">    <span class="comment">// 用空字符串替代。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/(^\s*)|(\s*$)/g</span>, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有空格的字符串</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">"    leading and trailing spaces    "</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示 "    leading and trailing spaces     (35)"</span></span><br><span class="line"><span class="built_in">window</span>.alert(s + <span class="string">" ("</span> + s.length + <span class="string">")"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除前后空格</span></span><br><span class="line">s = s.trim();</span><br><span class="line"><span class="comment">// 显示"leading and trailing spaces (27)"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript对象</title>
      <link href="/2018/03/26/JavaScript%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/03/26/JavaScript%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript对象"><a href="#JavaScript对象" class="headerlink" title="JavaScript对象"></a>JavaScript对象</h1><p>Jscript 对象是属性和方法的集合。一个方法就是一个函数，是对象的成员。属性是一个值或一组值（以数组或对象的形式），是对象的成员。Jscript 支持四种类型的对象：内部对象、生成的对象、宿主给出的对象（如 Internet 浏览器中的 window 和 document）以及 ActiveX 对象（外部组件）。</p><h2 id="作为数组的对象"><a href="#作为数组的对象" class="headerlink" title="作为数组的对象"></a>作为数组的对象</h2><p>在 Jscript 中，对象和数组几乎是以相同的方式处理的。对象和数组均可以被赋予任意值，实际上数组只是一种特殊的对象。数组和对象的区别在于数组有一个“奇妙的” length 属性，而对象没有。这意味着可以给数组的一个元素赋予比其他元素更大的值。例如，myArray[100] = “hello” — 然后 length 属性将自动地被更新为 101（新长度）。同样，如果修改数组的 length 属性，将删除不再是数组部分的元素。</p><p>Jscript 中所有的对象均支持“expando”属性或那些可以在运行时动态添加和删除的属性。这些属性可以有包含数字的任意名称。如果属性的名称是简单的标识符&lt;&lt;参考标识符规则&gt;&gt;，可以在对象名称的后面加句点，例如：</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加两个 expando 属性，'name' 和 'age'</span></span><br><span class="line">myObj.name = <span class="string">"Fred"</span>;</span><br><span class="line">myObj.age = <span class="number">42</span>;</span><br></pre></td></tr></table></figure><p>如果属性名称不是一个简单的标识符，或者在写脚本的时候不知道，可以在方括号中使用任意表达式来索引属性。在 Jscript 中所有 expando 属性的名称在被添加到对象之前被转换为字符串。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加两个无法写在 object.property 语</span></span><br><span class="line"><span class="comment">// 法中的 expando 属性。</span></span><br><span class="line"><span class="comment">// 第一个属性包含无效字符（空格），</span></span><br><span class="line"><span class="comment">// 所以必须写在方括号里。</span></span><br><span class="line">myObj[<span class="string">"not a valid identifier"</span>] = <span class="string">"This is the property value"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个 expando 名称是一个数字，</span></span><br><span class="line"><span class="comment">// 所以也必须写在方括号里。</span></span><br><span class="line">myObj[<span class="number">100</span>] = <span class="string">"100"</span>;</span><br></pre></td></tr></table></figure><p>传统的作法是赋给数组元素以 0 开始的数字索引。这些数组元素与 length 属性相交互。然而，由于所有的数组也是对象，也支持 expando 属性。请注意，虽然如此，expando 属性并不以任何方式与 length 属性相交互。例如：</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三个元素的数组</span></span><br><span class="line"><span class="keyword">var</span> myArray = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加数据</span></span><br><span class="line">myArray[<span class="number">0</span>] = <span class="string">"Hello"</span>;</span><br><span class="line">myArray[<span class="number">1</span>] = <span class="number">42</span>;</span><br><span class="line">myArray[<span class="number">2</span>] = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示数组的长度 3</span></span><br><span class="line"><span class="built_in">window</span>.alert(myArray.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加某些 expando 属性</span></span><br><span class="line">myArray.expando = <span class="string">"JScript!"</span>;</span><br><span class="line">myArray[<span class="string">"another Expando"</span>] = <span class="string">"Windows"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仍然显示 3，因为两个 expando 属性</span></span><br><span class="line"><span class="comment">// 并不影响长度。</span></span><br><span class="line"><span class="built_in">window</span>.alert(myArray.length);</span><br></pre></td></tr></table></figure><p>虽然 Jscript 并不直接支持多维数组，但是可以在数组元素中存储任意种类的数据 — 包含其他数组。所以通过在另一个数组的元素里存储其他数组可以得到多维数组的特性。例如，下面的代码为最大为 5 的数字建立了乘法表：</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若是更大的表请改变本数</span></span><br><span class="line"><span class="keyword">var</span> iMaxNum = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 循环计数</span></span><br><span class="line"><span class="keyword">var</span> i, j;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新数组。由于数组从 0 开始计数，</span></span><br><span class="line"><span class="comment">// 而不是 1，所以数组大小为 iMaxNum + 1。</span></span><br><span class="line"><span class="keyword">var</span> MultiplicationTable = <span class="keyword">new</span> <span class="built_in">Array</span>(iMaxNum + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为每个主要的数做循环（表中的每一行）</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= iMaxNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 生成表中的列</span></span><br><span class="line">    MultiplicationTable[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(iMaxNum + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将乘法的结果存在行中</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= iMaxNum; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        MultiplicationTable[i][j] = i * j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.alert(MultiplicationTable[<span class="number">3</span>][<span class="number">4</span>]); <span class="comment">// 显示 12</span></span><br><span class="line"><span class="built_in">window</span>.alert(MultiplicationTable[<span class="number">5</span>][<span class="number">2</span>]); <span class="comment">// 显示 10</span></span><br><span class="line"><span class="built_in">window</span>.alert(MultiplicationTable[<span class="number">1</span>][<span class="number">4</span>]); <span class="comment">// 显示 4</span></span><br></pre></td></tr></table></figure><h2 id="创建自己的对象"><a href="#创建自己的对象" class="headerlink" title="创建自己的对象"></a>创建自己的对象</h2><p>要创建自己的对象实例，必须首先为其定义一个构造函数。构造函数创建一个新对象，赋予对象属性，并在合适的时候赋予方法。例如，下面的示例为 pasta 对象定义了构造函数。注意 this 关键字的使用，它指向当前对象。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pasta 是有四个参数的构造器。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pasta</span>(<span class="params">grain, width, shape, hasEgg</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 是用什么粮食做的？</span></span><br><span class="line">    <span class="keyword">this</span>.grain = grain;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多宽？（数值）</span></span><br><span class="line">    <span class="keyword">this</span>.width = width;     </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 横截面形状？（字符串）</span></span><br><span class="line">    <span class="keyword">this</span>.shape = shape;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否加蛋黄？（boolean）</span></span><br><span class="line">    <span class="keyword">this</span>.hasEgg = hasEgg;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了对象构造器后，用 new 运算符创建对象实例。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> spaghetti = <span class="keyword">new</span> pasta(<span class="string">"wheat"</span>, <span class="number">0.2</span>, <span class="string">"circle"</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">var</span> linguine = <span class="keyword">new</span> pasta(<span class="string">"wheat"</span>, <span class="number">0.3</span>, <span class="string">"oval"</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>可以给对象实例添加属性以改变该实例，但是用相同的构造器生成的其他对象定义中并不包括这些属性，而且除非你特意添加这些属性那么在其他实例中并不显示出来。如果要将对象所有实例的附加属性显示出来，必须将它们添加到构造函数或构造器原型对象（原型在高级文档中讨论）中。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// spaghetti 的附加属性。</span></span><br><span class="line">spaghetti.color = <span class="string">"pale straw"</span>;</span><br><span class="line">spaghetti.drycook = <span class="number">7</span>;</span><br><span class="line">spaghetti.freshcook = <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> chowFun = <span class="keyword">new</span> pasta(<span class="string">"rice"</span>, <span class="number">3</span>, <span class="string">"flat"</span>, <span class="literal">false</span>); </span><br><span class="line"><span class="comment">// chowFun 对象或其他现有的 pasta 对象</span></span><br><span class="line"><span class="comment">// 都没有添加到 spaghetti 对象</span></span><br><span class="line"><span class="comment">// 的三个新属性。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将属性‘foodgroup’加到 pasta 原型对象</span></span><br><span class="line"><span class="comment">// 中，这样 pasta 对象的所有实例都可以有该属性，</span></span><br><span class="line"><span class="comment">// 包括那些已经生成的实例。</span></span><br><span class="line">pasta.prototype.foodgroup = <span class="string">"carbohydrates"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 spaghetti.foodgroup、chowFun.foodgroup，等等</span></span><br><span class="line"><span class="comment">// 均包含值“carbohydrates”。</span></span><br></pre></td></tr></table></figure><h2 id="在定义中包含方法"><a href="#在定义中包含方法" class="headerlink" title="在定义中包含方法"></a>在定义中包含方法</h2><p>可以在对象的定义中包含方法（函数）。一种方法是在引用别处定义的函数的构造函数中添加一个属性。例如，下面的示例扩充上面定义的 pasta 构造函数以包含 toString 方法，该方法将在显示对象的值时被调用。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pasta 是有四个参数的构造器。</span></span><br><span class="line"><span class="comment">// 第一部分与上面相同。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pasta</span>(<span class="params">grain, width, shape, hasEgg</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 用什么粮食做的？</span></span><br><span class="line">    <span class="keyword">this</span>.grain = grain;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多宽？（数值）</span></span><br><span class="line">    <span class="keyword">this</span>.width = width;     </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 横截面形状？（字符串）</span></span><br><span class="line">    <span class="keyword">this</span>.shape = shape;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否加蛋黄？（boolean）</span></span><br><span class="line">    <span class="keyword">this</span>.hasEgg = hasEgg;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里添加 toString 方法（如下定义）。</span></span><br><span class="line">    <span class="comment">// 注意在函数的名称后没有加圆括号；</span></span><br><span class="line">    <span class="comment">// 这不是一个函数调用，而是</span></span><br><span class="line">    <span class="comment">// 对函数自身的引用。</span></span><br><span class="line">    <span class="keyword">this</span>.toString = pastaToString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际的用来显示 past 对象内容的函数。 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pastaToString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 返回对象的属性。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Grain: "</span> + <span class="keyword">this</span>.grain + <span class="string">"\n"</span> +</span><br><span class="line">        <span class="string">"Width: "</span> + <span class="keyword">this</span>.width + <span class="string">"\n"</span> +</span><br><span class="line">        <span class="string">"Shape: "</span> + <span class="keyword">this</span>.shape + <span class="string">"\n"</span> +</span><br><span class="line">        <span class="string">"Egg?: "</span> + <span class="built_in">Boolean</span>(<span class="keyword">this</span>.hasEgg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> spaghetti = <span class="keyword">new</span> pasta(<span class="string">"wheat"</span>, <span class="number">0.2</span>, <span class="string">"circle"</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 将调用 toString() 并显示 spaghetti 对象</span></span><br><span class="line"><span class="comment">// 的属性。</span></span><br><span class="line"><span class="built_in">window</span>.alert(spaghetti);</span><br></pre></td></tr></table></figure><h2 id="内部对象"><a href="#内部对象" class="headerlink" title="内部对象"></a>内部对象</h2><p>Microsoft Jscript 提供了 11 个内部（或“内置”）对象。它们是Array、Boolean、Date、Function、Global、Math、Number、Object、RegExp、Error 以及 String 对象。</p><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>用关键字 Array 生成数组时，Jscript 包含了 length 属性，该属性记录了数组入口数。如果没有给该属性指定值，则设置长度为 0 且数组没有入口点。如果指定一个数值，则将长度设置为该数。如果指定了不止一个参数，则这些参数被用作数组的入口。另外，参数的数目被赋给 length 属性。如下面的示例与前一个示例是等价的。</p><p>当向用关键字 Array 生成的数组中添加元素时，Jscript 自动改变属性 length 的值。Jscript 中的数组索引总是以 0 开始，而不是 1，所以属性 length 通常比数组的最大索引大 1。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>在 Jscript 中，可以将字符串（和数）当作对象来处理。string 对象 有一些内置方法，可以和自己的字符串一起使用。其中一个是substring 方法，它返回字符串的一部分。该方法以两个数字作为参数。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aString = <span class="string">"0123456789"</span>;</span><br><span class="line"><span class="keyword">var</span> aChunk = aString.substring(<span class="number">4</span>, <span class="number">7</span>);  <span class="comment">// 将 aChunk 设为 "456"。</span></span><br><span class="line"><span class="keyword">var</span> aNotherChunk = aString.substring(<span class="number">7</span>, <span class="number">4</span>);  <span class="comment">// 将 aNotherChunk 设为 "456"。</span></span><br><span class="line"><span class="comment">// 使用上面生成数组的示例：</span></span><br><span class="line">firstLetter = theMonths[<span class="number">5</span>].substring(<span class="number">0</span>,<span class="number">1</span>);  <span class="comment">// 将变量 firstLetter 设为“J”。</span></span><br></pre></td></tr></table></figure><p>String 对象的另一个属性是 length 属性。本属性包含了字符串中的字符数（空字符串为 0）。它是一个数值，可以直接在计算中使用。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> howLong = <span class="string">"Hello World"</span>.length  <span class="comment">// 设置变量 howLong 为 11。</span></span><br></pre></td></tr></table></figure><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>MAX_VALUE</td><td>可能的最大数大约为 1.79E+308；可以是正数或负数。（具体数值随系统不同而有微小差别。）</td></tr><tr><td>MIN_VALUE</td><td>可能的最小数大约为 2.22E-308；可以是正数或负数。（具体数值随系统不同而有微小差别。）</td></tr><tr><td>NaN</td><td>特殊非数量值，“不是数值”。</td></tr><tr><td>POSITIVE_INFINITY</td><td>比最大正数（Number.MAX_VALUE）还要大的任意正值自动被转换为此值，代表正无穷大。</td></tr><tr><td>NEGATIVE_INFINITY</td><td>比最小的负数（负的 Number.MAX_VALUE）还小的任意值被自动转换为此值，代表负无穷。</td></tr></tbody></table><p>Number.NaN 是一个特殊的属性，被定义为“不是数值”。例如被 0 除返回 NaN。试图解析一个无法被解析为数字的字符串同样返回 Number.NaN。把 NaN 与任何数值或本身作比较的结果都是不相等。不能通过与 Number.NaN 比较来测试 NaN 结果，而应该使用 isNaN() 函数。</p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript控制语句</title>
      <link href="/2018/03/26/JavaScript%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
      <url>/2018/03/26/JavaScript%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript控制语句"><a href="#JavaScript控制语句" class="headerlink" title="JavaScript控制语句"></a>JavaScript控制语句</h1><h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><p>如果要一起测试多个条件，并且知道某个条件比其他条件更可能满足或不满足测试，可以使用称为“短路计算”的特性来加速脚本的运行速度。当 JScript 计算逻辑表达式时，只计算要得到结果所需的子表达式。</p><p>例如，如果有一个“与”表达式，如 ((x == 123) &amp;&amp; (y == 42))，Jscript 首先检查 x 是否为 123。如果不是，即使 y 等于 42，整个表达式的值也不可能为 true。因此，并不对 y 作测试，Jscript 返回 false 值。</p><p>类似地，如果多个条件中只要有一个为真（使用 || 运算符），则当任何一个条件满足该测试时测试则停止。如果要测试的条件包括函数调用或其他复合表达式，这种处理方式就有效。出于此种想法，写 OR 表达式时，先写最有可能为 true 的条件。写 AND 表达式时，先写最有可能为 false 的条件。</p><p>以这种方式设计脚本的好处的一个示例是：在下例中如果 runfirst() 返回 0 或 false， 则不会运行 runsecond()。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((runfirst() == <span class="number">0</span>) || (runsecond() == <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">// 若干代码。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用循环"><a href="#使用循环" class="headerlink" title="使用循环"></a>使用循环</h2><p>JScript 支持四种循环： for 循环、 for…in 循环、 while 循环、 do…while 循环。</p><h3 id="使用-for…in-循环"><a href="#使用-for…in-循环" class="headerlink" title="使用 for…in 循环"></a>使用 for…in 循环</h3><p>JScript 提供了一种特别的循环方式来遍历一个对象的所有用户定义的属性或者一个数组的所有元素。for…in 循环中的循环计数器是一个字符串，而不是数字。它包含当前属性的名称或者当前数组元素的下标。</p><p>下面的代码范例应在 Internet 浏览器中运行，因为它使用 alert 方法，该方法不属于 Jscript。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建具有某些属性的对象</span></span><br><span class="line"><span class="keyword">var</span> myObject = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">myObject.name = <span class="string">"James"</span>;</span><br><span class="line">myObject.age = <span class="string">"22"</span>;</span><br><span class="line">myObject.phone = <span class="string">"555 1234"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举（循环）对象的所有属性</span></span><br><span class="line"><span class="keyword">for</span> (prop <span class="keyword">in</span> myObject)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 显示 "The property 'name' is James"，等等。</span></span><br><span class="line">    <span class="built_in">window</span>.alert(<span class="string">"The property '"</span> + prop + <span class="string">"' is "</span> + myObject[prop]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管 for…in 循环看起来像 VBScript 的 For Each…Next 循环，其实并不一样。JScript 的 for…in 循环重复Jscript 对象所有的属性。VBScript 的 For Each…Next 循环重复集合中的所有项目。要循环 JScript 中的所有集合，需要用 Enumerator 对象。尽管某些对象（像 Internet 浏览器中的那些）支持 VBScript 的 For Each…Next 和 Jscript 的 for…in 循环，但多数对象并不都支持。</p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript运算符</title>
      <link href="/2018/03/26/JavaScript%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2018/03/26/JavaScript%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript运算符"><a href="#JavaScript运算符" class="headerlink" title="JavaScript运算符"></a>JavaScript运算符</h1><p>== （相等）与 === （严格相等）的区别在于恒等运算符在比较前强制转换不同类型的值。例如，恒等对字符串 “1” 与数值 1 的比较结果将为 true。而严格相等不强制转换不同类型的值，因此它认为字符串 “1” 与数值 1 不相同。</p><p>基本的字符串、数值和布尔值是按值比较的。如果它们的值相同，比较结果为相等。对象（包括Array、Function、String、Number、Boolean、Error、Date以及 RegExp 对象）按引用比较。即使这些类型的两个变量具有相同的值，只有在它们正好为同一对象时比较结果才为 true。</p><p>例如：</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具有相同值的两个基本字符串。</span></span><br><span class="line"><span class="keyword">var</span> string1 = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">var</span> string2 = <span class="string">"Hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具有相同值的两个 String 对象。</span></span><br><span class="line"><span class="keyword">var</span> StringObject1 = <span class="keyword">new</span> <span class="built_in">String</span>(string1);</span><br><span class="line"><span class="keyword">var</span> StringObject2 = <span class="keyword">new</span> <span class="built_in">String</span>(string2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较结果为 true。</span></span><br><span class="line"><span class="keyword">if</span> (string1 == string2)</span><br><span class="line">     <span class="comment">// 执行某些命令（将要运行的）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较结果为 false。</span></span><br><span class="line"><span class="keyword">if</span> (StringObject1 == StringObject2)</span><br><span class="line">    <span class="comment">//执行某些命令（不会运行）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要比较 String 对象的值， </span></span><br><span class="line"><span class="comment">// 用 toString() 或者 valueOf() 方法。</span></span><br><span class="line"><span class="keyword">if</span> (StringObject1.valueOf() == StringObject2)</span><br><span class="line">     <span class="comment">//执行某些命令（将要运行的）。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript数据类型</title>
      <link href="/2018/03/26/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/03/26/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript数据类型"><a href="#JavaScript数据类型" class="headerlink" title="JavaScript数据类型"></a>JavaScript数据类型</h1><p>三种主要数据类型、两种复合数据类型、两种特殊数据类型</p><ul><li><p>主要（基本）数据类型：<br>字符串<br>数值<br>布尔</p></li><li><p>复合（引用）数据类型：<br>对象<br>数组</p></li><li><p>特殊数据类型：<br>Null<br>undefined</p></li></ul><h2 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h2><p>在 Jscript 中数据类型 null 只有一个值：null。关键字 null 不能用作函数或变量的名称。</p><p>包含 null 的变量包含“无值”或“无对象”。换句话说，该变量没有保存有效的数、字符串、boolean、数组或对象。可以通过给一个变量赋 null 值来清除变量的内容。</p><p>请注意，在 Jscript 中，null 与 0 不相等（与在 C 和 C++ 中不同）。同时应该指出的是，Jscript中 typeof 运算符将报告 null 值为 Object 类型，而非类型 null。这点潜在的混淆是为了向下兼容。</p><h2 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h2><p>如下情况使返回 undefined 值： </p><ul><li>对象属性不存在， </li><li>声明了变量但从未赋值。 </li></ul><p>注意不能通过与 undefined 做比较来测试一个变量是否存在，虽然可以检查它的类型是否为“undefined”。在以下的代码范例中，假设程序员想测试是否已经声明变量 x ：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种方法不起作用</span></span><br><span class="line"><span class="keyword">if</span> (x == <span class="literal">undefined</span>)</span><br><span class="line">    <span class="comment">// 作某些操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法同样不起作用- 必须检查</span></span><br><span class="line"><span class="comment">// 字符串 "undefined"</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span>(x) == <span class="literal">undefined</span>)</span><br><span class="line">    <span class="comment">// 作某些操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法有效</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span>(x) == <span class="string">"undefined"</span>)</span><br><span class="line">    <span class="comment">// 作某些操作</span></span><br></pre></td></tr></table></figure></p><h2 id="null-和-undefined-比较"><a href="#null-和-undefined-比较" class="headerlink" title="null 和 undefined 比较"></a>null 和 undefined 比较</h2><p>考虑将 undefined 值与null做比较。</p><p>someObject.prop == null;<br>如下情况时，比较的结果为 true， </p><ul><li>如果属性 someObject.prop 包含 null 值， </li><li>如果属性 someObject.prop 不存在。 </li></ul><p>要检查一个对象属性是否存在，可以使用新的 in 运算符： (？)<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (&quot;prop&quot; in someObject)</span><br><span class="line">// someObject 有属性 &apos;prop&apos;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript变量</title>
      <link href="/2018/03/26/JavaScript/"/>
      <url>/2018/03/26/JavaScript/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript变量"><a href="#JavaScript变量" class="headerlink" title="JavaScript变量"></a>JavaScript变量</h1><h2 id="名称规则"><a href="#名称规则" class="headerlink" title="名称规则"></a>名称规则</h2><ul><li>第一个字符必须是一个 ASCII 字母（大小写均可），或一个下划线( _ )。注意第一个字符不能是数字。 </li><li>后续的字符必须是字母、数字或下划线。 </li><li>变量名称一定不能是 保留字。</li></ul><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><ol><li>当药声明一个变量并进行初始化，但又不想指定任何特殊值，可以赋为NULL。</li><li>如果声明了一个变量却没有对其赋值，该变量存在，其值为 <code>undefined</code>。</li></ol><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> currentCount;</span><br><span class="line"><span class="keyword">var</span> finalCount = <span class="number">1</span> * currentCount; <span class="comment">// finalCount 的值为 NaN，因为 currentCount 为 undefined。</span></span><br></pre></td></tr></table></figure><p>注意：任何在undefined上的运算结果都为NaN。</p><ol start="3"><li>可以不用 <code>var</code> 关键字声明变量，并赋值–（隐式声明）。</li><li>不能使用未经过声明的变量。</li></ol><h2 id="NULL和undefined的区别"><a href="#NULL和undefined的区别" class="headerlink" title="NULL和undefined的区别"></a>NULL和undefined的区别</h2><p>注意在 JScript 中 null 和 undefined 的主要区别是 null 的操作象数字 0，而 undefined 的操作象特殊值NaN （不是一个数字）。对 null 值和 undefined 值作比较总是相等的。<br>例如：<br>var bestAge = null;var muchTooOld = 3 * bestAge; // muchTooOld 的值为 0。</p><h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><p>JScript 是一种自由类型的语言。它的变量没有预定类型（相对于强类型语言，如 C++）。相反，JScript 变量的类型相应于他们包含的值的类型。这种操作的好处是能将值作为另一类型处理。</p><p>要想显式地将字符串转换为整数，使用 parseInt 方法。要想显式地将字符串转换为数字，使用 parseFloat 方法。请注意，比较大小时字符串自动转换为相等的数字，但加法（连接）运算时保留为字符串。</p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>对CustomEvents.js文件的解读</title>
      <link href="/2018/02/11/CustomEvents-js/"/>
      <url>/2018/02/11/CustomEvents-js/</url>
      <content type="html"><![CDATA[<h1 id="建立Visualization需要的步骤"><a href="#建立Visualization需要的步骤" class="headerlink" title="建立Visualization需要的步骤"></a>建立Visualization需要的步骤</h1><ol><li>建立恰当的控件控制Visualization（例如插入元素，删除元素等）；</li><li>为上述建立的控件建立callBack（回调函数）<br>Creates callbacks for these controls that implement the visualizations. The visualizations are implemented by sending an array of strings to the animation manager – the animation manager will then implement the animation, and handle all of the animation controls for you<br>为这些实现可视化的控件创建回调。 通过向动画管理器发送字符串数组来实现可视化 - 动画管理器将实现动画，并为您处理所有动画控件</li><li>Listen for an undo event from the animation manager. When an undo event is detected, roll back the last operation<br>从动画管理器中听取撤消事件。 当检测到撤消事件时，回退上次的操作（“上一步骤”按钮功能响应？）</li></ol><h1 id="使用Algorithm方法-函数"><a href="#使用Algorithm方法-函数" class="headerlink" title="使用Algorithm方法/函数"></a>使用Algorithm方法/函数</h1><p>所在文件：Algorithm.js<br>注意：Algorithm是个人造类（原本的js中没有的，是新的object）</p><h2 id="1-函数定义"><a href="#1-函数定义" class="headerlink" title="1. 函数定义"></a>1. 函数定义</h2><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyAlgorithm</span>(<span class="params">am, w, h</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.init(am, w, h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyAlgorithm.prototype = <span class="keyword">new</span> Algorithm(); <span class="comment">// 创建一个新的Algorithm对象</span></span><br><span class="line">MyAlgorithm.prototype.constructor = MyAlgorithm;<span class="comment">// 新对象的构造函数</span></span><br><span class="line">MyAlgorithm.superclass = Algorithm.prototype;<span class="comment">// 新对象继承的超类（新对象继承父类ALgorithm的属性）</span></span><br></pre></td></tr></table></figure><h1 id="对于AnimationMain-js-文件中的-reorderSibling-node1-node2-函数的实现"><a href="#对于AnimationMain-js-文件中的-reorderSibling-node1-node2-函数的实现" class="headerlink" title="对于AnimationMain.js 文件中的 reorderSibling(node1, node2) 函数的实现"></a>对于AnimationMain.js 文件中的 reorderSibling(node1, node2) 函数的实现</h1><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">&lt;title&gt;菜鸟教程(runoob.com)&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=<span class="string">"Water"</span> style=<span class="string">"width:100px;height:20px;background-color:red;"</span>&gt;node1&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div id="myList" style="width:100px;height:20px;background-color:yellow;"&gt;node2&lt;/</span>div&gt;</span><br><span class="line">&lt;p id=<span class="string">"demo"</span>&gt;单击按钮替换列表中的第一项。&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;button onclick="reorderSibling()"&gt;点我&lt;/</span>button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reorderSibling</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> node1=<span class="built_in">document</span>.getElementById(<span class="string">"Water"</span>);</span><br><span class="line"><span class="keyword">var</span> node2=<span class="built_in">document</span>.getElementById(<span class="string">"myList"</span>);</span><br><span class="line"></span><br><span class="line">node1.parentNode.replaceChild(node1,node2);</span><br><span class="line">node1.parentNode.insertBefore(node2, node1);</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;首先创建一个文本节点。&lt;br&gt;然后替换第一个列表中的第一个子节点。&lt;/</span>p&gt;</span><br><span class="line">&lt;p&gt;<span class="xml"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>注意:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span>这个例子只将文本节点的文本节点“Coffee”替换为“Water”,而不是整个LI元素,这也是替换节点的一种备选。&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p> <img src="https://raw.githubusercontent.com/Yojiaku/hexoBlogPic/875a87600027685f3d0b3e29c573f7f6976aefcf/functionGif/reorderSibling-node1-node2.gif" alt="reorderSibling-node1-node2-function"></p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Visualization </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>由Blocking Search动画引出的CSS样式的知识</title>
      <link href="/2018/02/07/Blocking-Search-Style/"/>
      <url>/2018/02/07/Blocking-Search-Style/</url>
      <content type="html"><![CDATA[<h1 id="前后对比图"><a href="#前后对比图" class="headerlink" title="前后对比图"></a>前后对比图</h1><p><img src="https://raw.githubusercontent.com/Yojiaku/hexoBlogPic/8906194b095bc9b644f5697ea9f7091b5853eed5/blockingSearch02.gif" alt="BlockingSearch.GIF before"><br><img src="https://raw.githubusercontent.com/Yojiaku/hexoBlogPic/259f6e2b6e095e56ccdf6babad9a7e7674623826/blockingSearch04.gif" alt="BlockingSearch.GIF after"></p><h1 id="CSS清除浮动的8种方法"><a href="#CSS清除浮动的8种方法" class="headerlink" title="CSS清除浮动的8种方法"></a>CSS清除浮动的8种方法</h1><p>浮动会使当前标签产生向上浮的效果，同时会影响到前后标签、父级标签的位置及 width height 属性。而且同样的代码，在各种浏览器中显示效果也有可能不相同，这样让清除浮动更难了。解决浮动引起的问题有多种方法，但有些方法在浏览器兼容性方面还有问题。</p><h2 id="父级div定义-height"><a href="#父级div定义-height" class="headerlink" title="父级div定义 height"></a>父级div定义 height</h2><p>代码如下：<br><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt; </span><br><span class="line"><span class="selector-class">.div1</span>&#123;<span class="attribute">background</span>:<span class="number">#000080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="comment">/*解决代码*/</span><span class="attribute">height</span>:<span class="number">200px</span>;&#125; </span><br><span class="line"><span class="selector-class">.div2</span>&#123;<span class="attribute">background</span>:<span class="number">#800080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="attribute">height</span>:<span class="number">100px</span>;<span class="attribute">margin-top</span>:<span class="number">10px</span>&#125; </span><br><span class="line"><span class="selector-class">.left</span>&#123;<span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">20%</span>;<span class="attribute">height</span>:<span class="number">200px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line"><span class="selector-class">.right</span>&#123;<span class="attribute">float</span>:right;<span class="attribute">width</span>:<span class="number">30%</span>;<span class="attribute">height</span>:<span class="number">80px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line">&lt;/style&gt; </span><br><span class="line">&lt;div class="div1"&gt; </span><br><span class="line">&lt;div class="left"&gt;Left&lt;/div&gt; </span><br><span class="line">&lt;div class="right"&gt;Right&lt;/div&gt; </span><br><span class="line">&lt;/div&gt; </span><br><span class="line">&lt;div class="div2"&gt; </span><br><span class="line"><span class="selector-tag">div2</span> </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题。 </p><p>优点：简单、代码少、容易掌握 </p><p>缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题 </p><p>建议：不推荐使用，只建议高度固定的布局时使用 </p><h2 id="结尾处加空div标签-clear-both"><a href="#结尾处加空div标签-clear-both" class="headerlink" title="结尾处加空div标签 clear:both"></a>结尾处加空div标签 clear:both</h2><p>代码如下:<br><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt; </span><br><span class="line"><span class="selector-class">.div1</span>&#123;<span class="attribute">background</span>:<span class="number">#000080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red&#125; </span><br><span class="line"><span class="selector-class">.div2</span>&#123;<span class="attribute">background</span>:<span class="number">#800080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="attribute">height</span>:<span class="number">100px</span>;<span class="attribute">margin-top</span>:<span class="number">10px</span>&#125; </span><br><span class="line"><span class="selector-class">.left</span>&#123;<span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">20%</span>;<span class="attribute">height</span>:<span class="number">200px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line"><span class="selector-class">.right</span>&#123;<span class="attribute">float</span>:right;<span class="attribute">width</span>:<span class="number">30%</span>;<span class="attribute">height</span>:<span class="number">80px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line"><span class="comment">/*清除浮动代码*/</span> </span><br><span class="line"><span class="selector-class">.clearfloat</span>&#123;<span class="attribute">clear</span>:both&#125; </span><br><span class="line">&lt;/style&gt; </span><br><span class="line">&lt;div class="div1"&gt; </span><br><span class="line">&lt;div class="left"&gt;Left&lt;/div&gt; </span><br><span class="line">&lt;div class="right"&gt;Right&lt;/div&gt; </span><br><span class="line">&lt;div class="clearfloat"&gt;&lt;/div&gt; </span><br><span class="line">&lt;/div&gt; </span><br><span class="line">&lt;div class="div2"&gt; </span><br><span class="line"><span class="selector-tag">div2</span> </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度 </p><p>优点：简单、代码少、浏览器支持好、不容易出现怪问题 </p><p>缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不好 </p><p>建议：不推荐使用，但此方法是以前主要使用的一种清除浮动方法 </p><h2 id="父级div定义-伪类-after-和-zoom-采用的"><a href="#父级div定义-伪类-after-和-zoom-采用的" class="headerlink" title="父级div定义 伪类:after 和 zoom (采用的)"></a>父级div定义 伪类:after 和 zoom (采用的)</h2><p>代码如下:<br><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt; </span><br><span class="line"><span class="selector-class">.div1</span>&#123;<span class="attribute">background</span>:<span class="number">#000080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;&#125; </span><br><span class="line"><span class="selector-class">.div2</span>&#123;<span class="attribute">background</span>:<span class="number">#800080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="attribute">height</span>:<span class="number">100px</span>;<span class="attribute">margin-top</span>:<span class="number">10px</span>&#125; </span><br><span class="line"><span class="selector-class">.left</span>&#123;<span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">20%</span>;<span class="attribute">height</span>:<span class="number">200px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line"><span class="selector-class">.right</span>&#123;<span class="attribute">float</span>:right;<span class="attribute">width</span>:<span class="number">30%</span>;<span class="attribute">height</span>:<span class="number">80px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line"><span class="comment">/*清除浮动代码*/</span> </span><br><span class="line"><span class="selector-class">.clearfloat</span><span class="selector-pseudo">:after</span>&#123;<span class="attribute">display</span>:block;<span class="attribute">clear</span>:both;<span class="attribute">content</span>:<span class="string">""</span>;<span class="attribute">visibility</span>:hidden;<span class="attribute">height</span>:<span class="number">0</span>&#125; </span><br><span class="line"><span class="selector-class">.clearfloat</span>&#123;<span class="attribute">zoom</span>:<span class="number">1</span>&#125; </span><br><span class="line">&lt;/style&gt; </span><br><span class="line">&lt;div class="div1 clearfloat"&gt; </span><br><span class="line">&lt;div class="left"&gt;Left&lt;/div&gt; </span><br><span class="line">&lt;div class="right"&gt;Right&lt;/div&gt; </span><br><span class="line">&lt;/div&gt; </span><br><span class="line">&lt;div class="div2"&gt; </span><br><span class="line"><span class="selector-tag">div2</span> </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题 </p><p>优点：浏览器支持好、不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等） </p><p>缺点：代码多、不少初学者不理解原理，要两句代码结合使用才能让主流浏览器都支持。 </p><p>建议：推荐使用，建议定义公共类，以减少CSS代码。</p><h2 id="父级div定义-overflow-hidden"><a href="#父级div定义-overflow-hidden" class="headerlink" title="父级div定义 overflow:hidden"></a>父级div定义 overflow:hidden</h2><p>代码如下:<br><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt; </span><br><span class="line"><span class="selector-class">.div1</span>&#123;<span class="attribute">background</span>:<span class="number">#000080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="comment">/*解决代码*/</span><span class="attribute">width</span>:<span class="number">98%</span>;<span class="attribute">overflow</span>:hidden&#125; </span><br><span class="line"><span class="selector-class">.div2</span>&#123;<span class="attribute">background</span>:<span class="number">#800080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="attribute">height</span>:<span class="number">100px</span>;<span class="attribute">margin-top</span>:<span class="number">10px</span>;<span class="attribute">width</span>:<span class="number">98%</span>&#125; </span><br><span class="line"><span class="selector-class">.left</span>&#123;<span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">20%</span>;<span class="attribute">height</span>:<span class="number">200px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line"><span class="selector-class">.right</span>&#123;<span class="attribute">float</span>:right;<span class="attribute">width</span>:<span class="number">30%</span>;<span class="attribute">height</span>:<span class="number">80px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line">&lt;/style&gt; </span><br><span class="line">&lt;div class="div1"&gt; </span><br><span class="line">&lt;div class="left"&gt;Left&lt;/div&gt; </span><br><span class="line">&lt;div class="right"&gt;Right&lt;/div&gt; </span><br><span class="line">&lt;/div&gt; </span><br><span class="line">&lt;div class="div2"&gt; </span><br><span class="line"><span class="selector-tag">div2</span> </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度 </p><p>优点：简单、代码少、浏览器支持好 </p><p>缺点：不能和position配合使用，因为超出的尺寸的会被隐藏。 </p><p>建议：只推荐没有使用position或对overflow:hidden理解比较深的朋友使用。</p><h2 id="父级div定义-overflow-auto"><a href="#父级div定义-overflow-auto" class="headerlink" title="父级div定义 overflow:auto"></a>父级div定义 overflow:auto</h2><p>代码如下:<br><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt; </span><br><span class="line"><span class="selector-class">.div1</span>&#123;<span class="attribute">background</span>:<span class="number">#000080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="comment">/*解决代码*/</span><span class="attribute">width</span>:<span class="number">98%</span>;<span class="attribute">overflow</span>:auto&#125; </span><br><span class="line"><span class="selector-class">.div2</span>&#123;<span class="attribute">background</span>:<span class="number">#800080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="attribute">height</span>:<span class="number">100px</span>;<span class="attribute">margin-top</span>:<span class="number">10px</span>;<span class="attribute">width</span>:<span class="number">98%</span>&#125; </span><br><span class="line"><span class="selector-class">.left</span>&#123;<span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">20%</span>;<span class="attribute">height</span>:<span class="number">200px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line"><span class="selector-class">.right</span>&#123;<span class="attribute">float</span>:right;<span class="attribute">width</span>:<span class="number">30%</span>;<span class="attribute">height</span>:<span class="number">80px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line">&lt;/style&gt; </span><br><span class="line">&lt;div class="div1"&gt; </span><br><span class="line">&lt;div class="left"&gt;Left&lt;/div&gt; </span><br><span class="line">&lt;div class="right"&gt;Right&lt;/div&gt; </span><br><span class="line">&lt;/div&gt; </span><br><span class="line">&lt;div class="div2"&gt; </span><br><span class="line"><span class="selector-tag">div2</span> </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>原理：必须定义width或zoom:1，同时不能定义height，使用overflow:auto时，浏览器会自动检查浮动区域的高度 </p><p>优点：简单、代码少、浏览器支持好 </p><p>缺点：内部宽高超过父级div时，会出现滚动条。 </p><p>建议：不推荐使用，如果你需要出现滚动条或者确保你的代码不会出现滚动条就使用吧。 </p><h2 id="父级div-也一起浮动"><a href="#父级div-也一起浮动" class="headerlink" title="父级div 也一起浮动"></a>父级div 也一起浮动</h2><p>代码如下:<br><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt; </span><br><span class="line"><span class="selector-class">.div1</span>&#123;<span class="attribute">background</span>:<span class="number">#000080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="comment">/*解决代码*/</span><span class="attribute">width</span>:<span class="number">98%</span>;<span class="attribute">margin-bottom</span>:<span class="number">10px</span>;<span class="attribute">float</span>:left&#125; </span><br><span class="line"><span class="selector-class">.div2</span>&#123;<span class="attribute">background</span>:<span class="number">#800080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="attribute">height</span>:<span class="number">100px</span>;<span class="attribute">width</span>:<span class="number">98%</span>;<span class="comment">/*解决代码*/</span><span class="attribute">clear</span>:both&#125; </span><br><span class="line"><span class="selector-class">.left</span>&#123;<span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">20%</span>;<span class="attribute">height</span>:<span class="number">200px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line"><span class="selector-class">.right</span>&#123;<span class="attribute">float</span>:right;<span class="attribute">width</span>:<span class="number">30%</span>;<span class="attribute">height</span>:<span class="number">80px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line">&lt;/style&gt; </span><br><span class="line">&lt;div class="div1"&gt; </span><br><span class="line">&lt;div class="left"&gt;Left&lt;/div&gt; </span><br><span class="line">&lt;div class="right"&gt;Right&lt;/div&gt; </span><br><span class="line">&lt;/div&gt; </span><br><span class="line">&lt;div class="div2"&gt; </span><br><span class="line"><span class="selector-tag">div2</span> </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>原理：所有代码一起浮动，就变成了一个整体 </p><p>优点：没有优点 </p><p>缺点：会产生新的浮动问题。 </p><p>建议：不推荐使用，只作了解。 </p><h2 id="父级div定义-display-table"><a href="#父级div定义-display-table" class="headerlink" title="父级div定义 display:table"></a>父级div定义 display:table</h2><p>代码如下:<br><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt; </span><br><span class="line"><span class="selector-class">.div1</span>&#123;<span class="attribute">background</span>:<span class="number">#000080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="comment">/*解决代码*/</span><span class="attribute">width</span>:<span class="number">98%</span>;<span class="attribute">display</span>:table;<span class="attribute">margin-bottom</span>:<span class="number">10px</span>;&#125; </span><br><span class="line"><span class="selector-class">.div2</span>&#123;<span class="attribute">background</span>:<span class="number">#800080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="attribute">height</span>:<span class="number">100px</span>;<span class="attribute">width</span>:<span class="number">98%</span>;&#125; </span><br><span class="line"><span class="selector-class">.left</span>&#123;<span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">20%</span>;<span class="attribute">height</span>:<span class="number">200px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line"><span class="selector-class">.right</span>&#123;<span class="attribute">float</span>:right;<span class="attribute">width</span>:<span class="number">30%</span>;<span class="attribute">height</span>:<span class="number">80px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line">&lt;/style&gt; </span><br><span class="line">&lt;div class="div1"&gt; </span><br><span class="line">&lt;div class="left"&gt;Left&lt;/div&gt; </span><br><span class="line">&lt;div class="right"&gt;Right&lt;/div&gt; </span><br><span class="line">&lt;/div&gt; </span><br><span class="line">&lt;div class="div2"&gt; </span><br><span class="line"><span class="selector-tag">div2</span> </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>原理：将div属性变成表格 </p><p>优点：没有优点 </p><p>缺点：会产生新的未知问题。 </p><p>建议：不推荐使用，只作了解。 </p><h2 id="结尾处加-br标签-clear-both"><a href="#结尾处加-br标签-clear-both" class="headerlink" title="结尾处加 br标签 clear:both"></a>结尾处加 br标签 clear:both</h2><p>代码如下:<br><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt; </span><br><span class="line"><span class="selector-class">.div1</span>&#123;<span class="attribute">background</span>:<span class="number">#000080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="attribute">margin-bottom</span>:<span class="number">10px</span>;<span class="attribute">zoom</span>:<span class="number">1</span>&#125; </span><br><span class="line"><span class="selector-class">.div2</span>&#123;<span class="attribute">background</span>:<span class="number">#800080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="attribute">height</span>:<span class="number">100px</span>&#125; </span><br><span class="line"><span class="selector-class">.left</span>&#123;<span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">20%</span>;<span class="attribute">height</span>:<span class="number">200px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line"><span class="selector-class">.right</span>&#123;<span class="attribute">float</span>:right;<span class="attribute">width</span>:<span class="number">30%</span>;<span class="attribute">height</span>:<span class="number">80px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line"><span class="selector-class">.clearfloat</span>&#123;<span class="attribute">clear</span>:both&#125; </span><br><span class="line">&lt;/style&gt; </span><br><span class="line">&lt;div class="div1"&gt; </span><br><span class="line">&lt;div class="left"&gt;Left&lt;/div&gt; </span><br><span class="line">&lt;div class="right"&gt;Right&lt;/div&gt; </span><br><span class="line">&lt;br class="clearfloat" /&gt; </span><br><span class="line">&lt;/div&gt; </span><br><span class="line">&lt;div class="div2"&gt; </span><br><span class="line"><span class="selector-tag">div2</span> </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>原理：父级div定义zoom:1来解决IE浮动问题，结尾处加 br标签 clear:both </p><p>建议：不推荐使用，只作了解。</p><h1 id="原生JS给元素添加class属性"><a href="#原生JS给元素添加class属性" class="headerlink" title="原生JS给元素添加class属性"></a>原生JS给元素添加class属性</h1><p>有下面三种语句：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>].className = <span class="string">'snow-container'</span>; <span class="comment">//设置为新的</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>].className += <span class="string">'snow-container'</span>; <span class="comment">//在原来的后面加这个</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>].classList.add(<span class="string">"snow-container"</span>); <span class="comment">//与第一个等价</span></span><br></pre></td></tr></table></figure></p><p>用第三种<br>因为第一种是直接将旧的class改为新的<br>第二种实在旧的class基础上像字符串拼接一样<br>只有第三种实现了目的</p><h1 id="Flex-布局"><a href="#Flex-布局" class="headerlink" title="Flex 布局"></a>Flex 布局</h1><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">点击这里</a></p><h1 id="ul内容自适应居中"><a href="#ul内容自适应居中" class="headerlink" title="ul内容自适应居中"></a>ul内容自适应居中</h1><p>在开发过程中，想到一个问题，平时对块级元素居中的时候都是定义一个宽度然后简单的通过margin:0 auto;实现，但是如果内容增加，是不是每次都需要修改宽度呢。我觉得需要思考一个自适应内容，并居中的方案。<br><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'container'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"clearfix"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:void(0);"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:void(0);"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:void(0);"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">''</span>;</span><br><span class="line">    <span class="attribute">visibility</span>:hidden;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">text-align</span>:center;          </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">ul</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">li</span>&#123;</span><br><span class="line">     <span class="attribute">float</span>:left;</span><br><span class="line">     <span class="attribute">width</span>:<span class="number">20px</span>;</span><br><span class="line">     <span class="attribute">height</span>:<span class="number">20px</span>;</span><br><span class="line">     <span class="attribute">margin</span>:<span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">     <span class="attribute">-webkit-border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">     <span class="attribute">-moz-border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">     <span class="attribute">-o-border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">     <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">     <span class="attribute">cursor</span>:pointer;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这实现思想是，先让ul定义 display:inline-block 属性，让其变成行内块级元素。</p><p>当ul成为行内块级元素后，它便有了行级元素的特性。</p><p>那么，重点来了。</p><p>只需要对ul的父级元素 .container 定义一个text-align:center;</p><p>效果便可以很明显的看到了。</p><p>更重点是，ul内的li的增减并不会对其位置造成偏移。</p><h1 id="css-行高-line-height"><a href="#css-行高-line-height" class="headerlink" title="css 行高 line-height"></a>css 行高 line-height</h1><p><a href="http://www.zhangxinxu.com/wordpress/2009/11/css%E8%A1%8C%E9%AB%98line-height%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">点击这里</a></p>]]></content>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>由Blocking Search动画引出的知识点2</title>
      <link href="/2018/02/06/BlockingSearch-JS2/"/>
      <url>/2018/02/06/BlockingSearch-JS2/</url>
      <content type="html"><![CDATA[<h1 id="调用含有-setInterval-的函数时异步问题的解决"><a href="#调用含有-setInterval-的函数时异步问题的解决" class="headerlink" title="调用含有 setInterval 的函数时异步问题的解决"></a>调用含有 setInterval 的函数时异步问题的解决</h1><p>重点：使用 async/await 与 Promise 对象</p><h2 id="在代码中引用"><a href="#在代码中引用" class="headerlink" title="在代码中引用"></a>在代码中引用</h2><ul><li>引用前（有问题的代码）<figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> linearSearch = <span class="function"><span class="keyword">function</span> (<span class="params">desired_letter, array, flag</span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line">linear_interval = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (current_index &gt;= array.length) &#123;</span><br><span class="line">clearInterval(linear_interval);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (current_value &gt;= desired_letter) &#123;</span><br><span class="line">clearInterval(linear_interval);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> current_index;</span><br><span class="line">&#125;</span><br><span class="line">current_index += <span class="number">1</span>;</span><br><span class="line">&#125;, SEARCH_INTERVAL_TIME/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ## Blocking Search</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">startBlockingSearch</span>(<span class="params">desired_letter, array</span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> which_block = linearSearch(desired_letter, block_arr, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"which_block = "</span>, which_block);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这里遇到了 which_block 打印出来始终为 undefined 的问题。</p><ul><li><p>问题解决后的代码</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> linearSearch = <span class="function"><span class="keyword">function</span> (<span class="params">desired_letter, array, flag</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">...</span><br><span class="line">linear_interval = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (current_index &gt;= array.length) &#123;</span><br><span class="line">clearInterval(linear_interval);</span><br><span class="line">resolve(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (current_value &gt;= desired_letter) &#123;</span><br><span class="line">clearInterval(linear_interval);</span><br><span class="line">...</span><br><span class="line">resolve(current_index);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;, SEARCH_INTERVAL_TIME/<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ## Blocking Search</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">startBlockingSearch</span>(<span class="params">desired_letter, array</span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> which_block = <span class="keyword">await</span> linearSearch(desired_letter, block_arr, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"which_block = "</span>, which_block);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>需要注意的地方</p><ul><li>在 async 的函数（这里是 startBlockingSearch 函数）里面引用的函数（这里是 linearSearch 函数）的真正返回值需要用 <strong><code>resolve</code></strong> 包裹起来</li><li>且引用的函数必须再用 <strong>return new Promise(function(resolve, reject){…}</strong> 嵌套一次</li></ul></li></ul><h2 id="关于Promise对象"><a href="#关于Promise对象" class="headerlink" title="关于Promise对象"></a>关于Promise对象</h2><h3 id="一些参考链接"><a href="#一些参考链接" class="headerlink" title="一些参考链接"></a>一些参考链接</h3><ul><li><p><a href="https://www.cnblogs.com/blog-index/p/6637543.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">JS Promise API</a></p><ul><li><p>主要内容：<br><strong>Promise 三状态</strong></p><ul><li>pending：初始状态，未完成或拒绝</li><li>fulfilled：操作成功完成[Resolved（已完成，又称 Fulfilled）]</li><li><p>rejected：操作失败</p><p>pending状态的Promise对象可能被填充了（fulfilled）值，也可能被某种理由（异常信息）拒绝（reject）了。当其中任一种情况出现时，Promise对象的then方法绑定的处理方法（handlers ）就会被调用(then方法包含两个参数：onfulfilled和onrejected，它们都是Function类型。当值被填充时，调用then的onfulfilled方法，当Promise被拒绝时，调用then的onrejected方法， 所以在异步操作的完成和绑定处理方法之间不存在竞争)</p><p>因为Promise.prototype.then和 Promise.prototype.catch方法返回 promises对象自身， 所以它们可以被链式调用.</p><p><img src="https://raw.githubusercontent.com/Yojiaku/hexoBlogPic/566b52408c23a0153c65326a68039833de085a39/promise.png" alt="promise"></p></li></ul><p><strong>Promise API</strong></p><ul><li>Promise.resolve() 执行成功</li><li>Promise.reject() 执行失败</li><li>Promise.prototype.then() 递延处理</li><li>Promise.prototype.catch() 异常</li></ul></li></ul></li><li><p><a href="https://www.cnblogs.com/dojo-lzz/p/4340897.html" target="_blank" rel="noopener">闲话Promise机制</a></p></li><li><p><a href="https://www.jianshu.com/p/063f7e490e9a" target="_blank" rel="noopener">Javascript 中的神器——Promise</a></p><ul><li><p>主要内容：<br><strong>封装代码与异步代码</strong></p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">resolve(someValue);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">写成</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve(someValue);</span><br></pre></td></tr></table></figure><p><strong>捕获同步异常</strong></p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'悲剧了，又出 bug 了'</span>);</span><br><span class="line"> &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><a href="http://www.zhangxinxu.com/wordpress/2014/02/es6-javascript-promise-%E6%84%9F%E6%80%A7%E8%AE%A4%E7%9F%A5/" target="_blank" rel="noopener">ES6 JavaScript Promise的感性认知</a></li><li><a href="https://www.cnblogs.com/yunfeifei/p/4453690.html" target="_blank" rel="noopener">JavaScript进阶之路——认识和使用Promise，重构你的Js代码</a></li><li><a href="http://blog.csdn.net/jasonzds/article/details/53717501" target="_blank" rel="noopener">JavaScript再述promise的用法和常用方法</a></li></ul><h2 id="关于async-与-await"><a href="#关于async-与-await" class="headerlink" title="关于async 与 await"></a>关于async 与 await</h2><h3 id="一些参考链接-1"><a href="#一些参考链接-1" class="headerlink" title="一些参考链接"></a>一些参考链接</h3><ul><li><p><a href="https://www.cnblogs.com/cpselvis/p/6344122.html" target="_blank" rel="noopener">Javascript中的async await</a></p><ul><li><p>注意点：</p><ul><li>async用来申明里面包裹的内容可以进行同步的方式执行，await则是进行执行顺序控制，每次执行一个await，程序都会暂停等待await返回值，然后再执行之后的await。</li><li>await后面调用的函数需要返回一个promise，另外这个函数是一个普通的函数即可，而不是generator。</li><li><p>await只能用在async函数之中，用在普通函数中会报错。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  docs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</span><br><span class="line"><span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上面代码会报错，因为 await 用在普通函数之中了。但是，如果将 forEach 方法的参数改成 async 函数，也有问题。</p>  <figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可能得到错误结果</span></span><br><span class="line">  docs.forEach(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</span><br><span class="line"><span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上面代码可能不会正常工作，原因是这时三个 db.post 操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用 for 循环。</p>  <figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> doc <span class="keyword">of</span> docs) &#123;</span><br><span class="line"><span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  如果确实希望多个请求并发执行，可以使用 Promise.all 方法。</p>  <figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.map(<span class="function">(<span class="params">doc</span>) =&gt;</span> db.post(doc));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(promises);</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用下面的写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.map(<span class="function">(<span class="params">doc</span>) =&gt;</span> db.post(doc));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> results = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">results.push(<span class="keyword">await</span> promise);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><pre><code>+ await命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try...catch 代码块中。<figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">await</span> somethingThatReturnsAPromise();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> somethingThatReturnsAPromise().catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p><a href="http://www.ruanyifeng.com/blog/2015/05/async.html" target="_blank" rel="noopener">async 函数的含义和用法</a></p><ul><li>示例：指定多少毫秒后输出一个值。(指定50毫秒以后，输出”hello world”。)<figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> timeout(ms);</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncPrint(<span class="string">'hello world'</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><a href="https://segmentfault.com/a/1190000007535316" target="_blank" rel="noopener">理解JavaScript的async/await</a><br><strong> 这篇很重要 </strong></p></li><li><p><a href="http://cnodejs.org/topic/5976b6d668aa87c774e5eb85" target="_blank" rel="noopener">用async/await多个返回值的方法，可以直接接收吗？比如 var value = request(url);</a></p></li></ul><h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p><img src="https://raw.githubusercontent.com/Yojiaku/hexoBlogPic/8906194b095bc9b644f5697ea9f7091b5853eed5/blockingSearch02.gif" alt="blockingSearch02.GIF"></p><h1 id="动态添加li的方法"><a href="#动态添加li的方法" class="headerlink" title="动态添加li的方法"></a>动态添加li的方法</h1><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line"><span class="keyword">var</span> node = <span class="built_in">document</span>.createElement(<span class="string">"LI"</span>);</span><br><span class="line"><span class="keyword">var</span> text = index_table_key[i].innerHTML;</span><br><span class="line"><span class="keyword">var</span> textnode = <span class="built_in">document</span>.createTextNode(text);</span><br><span class="line">block_arr.push(text);</span><br><span class="line">node.setAttribute(<span class="string">'id'</span>, text+<span class="string">'-linear'</span>);</span><br><span class="line">node.appendChild(textnode);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'block-linear-search'</span>).appendChild(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>由编写Blocking Search动画引出的知识点</title>
      <link href="/2018/02/06/BlockingSearch-JS/"/>
      <url>/2018/02/06/BlockingSearch-JS/</url>
      <content type="html"><![CDATA[<h1 id="动画控制-定时器"><a href="#动画控制-定时器" class="headerlink" title="动画控制-定时器"></a>动画控制-定时器</h1><p>引用自：<a href="https://www.zhihu.com/question/31636244" target="_blank" rel="noopener">异步控制完成sleep功能</a><br>具体如下：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>)</span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">1000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'world!'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, ms))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure></p><p>关键点：</p><ul><li>async</li><li>await</li><li>Promise对象</li><li>setTimeout</li><li>“=&gt;”箭头函数<br>在Blocking Search动画中的应用：<figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, ms));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">startBlockingSearch</span>(<span class="params">desired_letter, array</span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=BLOCK_NUM; i++) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">await</span> sleep(SEARCH_INTERVAL_TIME/<span class="number">2</span>);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>实现效果：<br><img src="https://raw.githubusercontent.com/Yojiaku/hexoBlogPic/8a643fbd83faf6fc6a39c34a2969631406021177/blockingSearch01.gif" alt="blocking search"></p><h1 id="JS动态命名变量名"><a href="#JS动态命名变量名" class="headerlink" title="JS动态命名变量名"></a>JS动态命名变量名</h1><h2 id="法一：用eval"><a href="#法一：用eval" class="headerlink" title="法一：用eval"></a>法一：用eval</h2><p>例子如下：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Thread_num=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=Thread_num;i++)&#123;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"var set_"</span> + i + <span class="string">"="</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">alert(set_5);</span><br></pre></td></tr></table></figure></p><p>但是此方法有一个缺点：eval函数占用内存，建议用法二</p><h2 id="法二：用数组"><a href="#法二：用数组" class="headerlink" title="法二：用数组"></a>法二：用数组</h2><p>例子如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Thread_num=5;</span><br><span class="line">var arr=[];</span><br><span class="line">for(var i=1;i&lt;=Thread_num;i++)&#123;</span><br><span class="line">arr[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="在Blocking-Search动画中的应用："><a href="#在Blocking-Search动画中的应用：" class="headerlink" title="在Blocking Search动画中的应用："></a>在Blocking Search动画中的应用：</h2><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ID_index=[];</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=BLOCK_NUM; i++) &#123;</span><br><span class="line">...</span><br><span class="line">ID_index[i] = <span class="keyword">new</span> ID(key, start, end);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"ID_index"</span>+i+<span class="string">": key = "</span>+key+<span class="string">" start = "</span>+start+<span class="string">" end = "</span>+end);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JS中构建结构体数组"><a href="#JS中构建结构体数组" class="headerlink" title="JS中构建结构体数组"></a>JS中构建结构体数组</h1><h2 id="在Blocking-Search动画中的应用：-1"><a href="#在Blocking-Search动画中的应用：-1" class="headerlink" title="在Blocking Search动画中的应用："></a>在Blocking Search动画中的应用：</h2><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 块结构</span></span><br><span class="line"><span class="keyword">var</span> ID = <span class="function"><span class="keyword">function</span>(<span class="params">key, start, end</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">self.key = key;</span><br><span class="line">self.start = start;</span><br><span class="line">self.end = end;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">startBlockingSearch</span>(<span class="params">desired_letter, array</span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> key, start, end;</span><br><span class="line"><span class="keyword">var</span> ID_index=[];</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=BLOCK_NUM; i++) &#123;</span><br><span class="line">start = j+<span class="number">1</span>;</span><br><span class="line">j = j+<span class="number">1</span>;</span><br><span class="line">end = j+<span class="number">4</span>;</span><br><span class="line">j = j+<span class="number">4</span>;</span><br><span class="line">key = array[j];</span><br><span class="line">ID_index[i] = <span class="keyword">new</span> ID(key, start, end);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"ID_index"</span>+i+<span class="string">": key = "</span>+key+<span class="string">" start = "</span>+start+<span class="string">" end = "</span>+end);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>ID_index = []</code> 就是构建的结构体数组。</p><h1 id="原生JS如何删除Ul下class为active的li-（没有用到，偶然搜到）"><a href="#原生JS如何删除Ul下class为active的li-（没有用到，偶然搜到）" class="headerlink" title="原生JS如何删除Ul下class为active的li （没有用到，偶然搜到）"></a>原生JS如何删除Ul下class为active的li （没有用到，偶然搜到）</h1><p>比如说，ul下有5个li，其中3个class是active的，我要把这3个元素节点删除，我写了这样的代码<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">oBtn2.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> aActive=oUl.getElementsByClassName(<span class="string">'active'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;aActive.length;i++)&#123;</span><br><span class="line">        oUl.removeChild(aActive[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当点击btn2时，首先获取oUl下所有class为active的li，然后遍历删除，我后来大概知道是哪里出的问题，就是每次删除一个后，aActive的个数变了，因为aActive是动态的。<br>我才学js不久，只知道removeChild删除单个节点的方法，还有什么简单的办法可以实现删除一堆节点么？</p><p>回答一：<br>将aActive长度保存即可，for(var i=0,len=aActive.length; i&lt;len; i++){oUl.removeChild(aActive[0])}，要注意的是低版本ie不支持getElementsByClassName方法，如果要兼容，要遍历所有节点查找。getElementsByTagName,getElementsByName这些方法都是动态，实时的，即是会根据节点的增删变化而变化的</p><p>回答二：<br>数组的splice()方法,aActive.splice(0,3)</p><p>回答三：<br><code>html</code><br><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Bin<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">'a'</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">'a'</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">'a'</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><code>javascript</code><br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn=<span class="built_in">document</span>.querySelector(<span class="string">'button'</span>);</span><br><span class="line"><span class="keyword">var</span> activeIlists=<span class="built_in">document</span>.getElementsByClassName(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">var</span> ul=<span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>);</span><br><span class="line">btn.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(activeIlists.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;=<span class="number">4</span>;i++)&#123;     </span><br><span class="line">     ul.removeChild(activeIlists[i]);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>实现效果：<a href="http://jsbin.com/coxejo/1/edit?html,js,output" target="_blank" rel="noopener">点击这里查看</a></p><p>回答四：从后往前删除，这样即使删除了li，也不会影响前面节点的位置。<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;<span class="xml"><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">&lt;ul&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li class="active"&gt;1&lt;/</span>li&gt;</span><br><span class="line">    &lt;li &gt;<span class="number">2</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li class="active"&gt;3&lt;/</span>li&gt;</span><br><span class="line">    &lt;li &gt;<span class="number">4</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li class="active"&gt;5&lt;/</span>li&gt;</span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">function removeByClass()</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        var ul = document.getElementsByTagName('ul')[0];</span></span><br><span class="line"><span class="string">        var _li = ul.getElementsByTagName('li');</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        for(var i = _li.length -1; i &gt;= 0; i--)&#123;</span></span><br><span class="line"><span class="string">            if(_li[i].className =='active')&#123;</span></span><br><span class="line"><span class="string">                ul.removeChild(_li[i]);</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">window.onload = removeByClass();</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>主要重点是removeChild 函数对DOM的即时影响。</strong></p><h1 id="JS在数组前添加元素"><a href="#JS在数组前添加元素" class="headerlink" title="JS在数组前添加元素"></a>JS在数组前添加元素</h1><p>用unshift方法：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]; </span><br><span class="line"><span class="keyword">var</span> b = a.unshift(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>则 a = [0,1,2,3,4,5];<br>b=6,即添加后数组长度</p><h1 id="JavaScript-String-slice-函数详解"><a href="#JavaScript-String-slice-函数详解" class="headerlink" title="JavaScript String.slice() 函数详解"></a>JavaScript String.slice() 函数详解</h1><p><a href="http://www.365mini.com/page/javascript-string-slice.htm" target="_blank" rel="noopener">点击这里</a></p><h1 id="getElementsByClassName-方法"><a href="#getElementsByClassName-方法" class="headerlink" title="getElementsByClassName() 方法"></a>getElementsByClassName() 方法</h1><p><a href="http://www.runoob.com/jsref/met-document-getelementsbyclassname.html" target="_blank" rel="noopener">点击这里</a></p><h1 id="CSS-变量"><a href="#CSS-变量" class="headerlink" title="CSS 变量"></a>CSS 变量</h1><p><a href="http://blog.csdn.net/u011043843/article/details/46480677" target="_blank" rel="noopener">点击这里</a></p><h2 id="在Blocking-Search动画中的应用：-2"><a href="#在Blocking-Search动画中的应用：-2" class="headerlink" title="在Blocking Search动画中的应用："></a>在Blocking Search动画中的应用：</h2><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义一些颜色变量 */</span></span><br><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line"><span class="comment">/* 分块区 */</span></span><br><span class="line">--block_1-color: FireBrick;</span><br><span class="line"><span class="selector-tag">--block_2-color</span>: <span class="selector-tag">DarkSeaGreen</span>;</span><br><span class="line"><span class="selector-tag">--block_3-color</span>: <span class="selector-tag">Bisque</span>;</span><br><span class="line"><span class="selector-tag">--block_4-color</span>: <span class="selector-tag">Aquamarine</span>;</span><br><span class="line"><span class="selector-tag">--block_5-color</span>: <span class="selector-tag">CornflowerBlue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.data</span> <span class="selector-tag">li</span><span class="selector-class">.block_1</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="built_in">var</span>(--block_1-color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.data</span> <span class="selector-tag">li</span><span class="selector-class">.block_2</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="built_in">var</span>(--block_2-color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.data</span> <span class="selector-tag">li</span><span class="selector-class">.block_3</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="built_in">var</span>(--block_3-color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.data</span> <span class="selector-tag">li</span><span class="selector-class">.block_4</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="built_in">var</span>(--block_4-color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.data</span> <span class="selector-tag">li</span><span class="selector-class">.block_5</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="built_in">var</span>(--block_5-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>删除元素所有子节点</title>
      <link href="/2018/02/05/remove-node-in-js/"/>
      <url>/2018/02/05/remove-node-in-js/</url>
      <content type="html"><![CDATA[<h1 id="删除元素所有子节点"><a href="#删除元素所有子节点" class="headerlink" title="删除元素所有子节点"></a>删除元素所有子节点</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elem = getElementById(<span class="string">"elem_id"</span>);  </span><br><span class="line">elem.innerHTML = <span class="string">""</span>;</span><br></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnDelete</span>(<span class="params"></span>)</span>&#123;   </span><br><span class="line">    <span class="keyword">var</span> elem = getElementById(<span class="string">"elem_id"</span>);  </span><br><span class="line">    <span class="keyword">while</span>(elem.hasChildNodes()) <span class="comment">//当elem下还存在子节点时 循环继续  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        elem.removeChild(elem.firstChild);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnDelete</span>(<span class="params"></span>)</span>&#123;   </span><br><span class="line">    <span class="keyword">var</span> elem = getElementById(<span class="string">"elem_id"</span>);  </span><br><span class="line">    <span class="keyword">while</span>(elem.lastChild) <span class="comment">//当div下还存在最后的子节点时 循环继续&lt;/span&gt;&lt;span style="font-size:14px;"&gt;  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        elem.removeChild(elem.lastChild);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h2><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnDelete</span>(<span class="params"></span>)</span>&#123;   </span><br><span class="line">    <span class="keyword">var</span> elem = getElementById(<span class="string">"elem_id"</span>);  </span><br><span class="line">    <span class="keyword">var</span> childs = elem.childNodes;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=childs.length<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;      </span><br><span class="line">        elem.removeChild(childs.item(i));      </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法五"><a href="#方法五" class="headerlink" title="方法五"></a>方法五</h2><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#elem_id"</span>).empty();</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C语言概览（基础）</title>
      <link href="/2018/02/02/C-Introduction/"/>
      <url>/2018/02/02/C-Introduction/</url>
      <content type="html"><![CDATA[<h2 id="入门知识（hello-world级别）"><a href="#入门知识（hello-world级别）" class="headerlink" title="入门知识（hello world级别）"></a>入门知识（hello world级别）</h2><h2 id="printf"><a href="#printf" class="headerlink" title="printf()"></a>printf()</h2><p>printf函数永远不会自动换行。<br>“\n”只代表一个字符。类似于 <code>\n</code> 的转义字符序列为表示无法输入的字符或不可见的字符提供了一种通用的可扩充机制。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>变量类型：<ul><li>int         整型（16位）</li><li>float        浮点型（32位）-至少6位有效数字</li><li>char         字符-一个字节</li><li>short     短整型</li><li>long         长整型</li><li>double     双精度浮点型</li></ul></li><li>符号常量：<br>  “幻数”：指200、30这种数字，不能向以后阅读该程序的人提供什么信息，而且程序修改困难。<br>  “常量”：给幻数赋予有意义的名字<pre><code>工具：#define 名字 替换文本</code></pre></li><li><p>字符输入/输出<br>  无论文本从何处输入，输出到何处，其输入/输出都是按照字符流的方式处理。文本流是由多行字符构成的字符序列，而每行字符则有0个或多个字符组成，行末是一个换行符。<br>  getchar()与putchar()</p><pre><code>+ 每次调用时，getchar从文本流中读入下一个输入字符，并将其作为结果值返回。即：在执行语句<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = getchar();</span><br></pre></td></tr></table></figure>之后，变量 c 将包含输入流中的下一个字符。这种字符通常是通过**键盘**输入的。+ 每次调用 putchar 时将打印出一个字符，例如：<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">putchar</span>();</span><br></pre></td></tr></table></figure>将把整型变量 c 的内容以**字符**的形式打印出来，通常是显示在屏幕上。+ putchar 与 getchar 可以交替调用，输出的次序与调用次序一致。+ 文件复制<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="comment">/* copy input to output; 1st version */</span></span><br><span class="line"> main()</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">int</span> c;</span><br><span class="line"> c = getchar();</span><br><span class="line"> <span class="keyword">while</span> (c != EOF) &#123;</span><br><span class="line"><span class="built_in">putchar</span>(c);</span><br><span class="line">c = getchar();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>&gt; 字符在键盘、屏幕或者其他任何地方无论以什么形式表现，它在机器内部都是以位模式存储的。char类型专门用于存储这种字符型数据，当然 int 也可以用于存储字符型数据，因为某种原因，这里使用 int。</code></pre></li></ul><h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><p>例子：读入一组文本行，并把最长的文本行打印出来<br><figure class="hljs highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (还有未处理的行)</span><br><span class="line"><span class="keyword">if</span> (该行比已处理的最长行还要长)</span><br><span class="line">保存该行为最长行</span><br><span class="line">保存该行的长度</span><br><span class="line">打印最长的行</span><br></pre></td></tr></table></figure></p><p>编写 getline 函数：读取输入的下一行，在督导文件末尾时返回一个信号（更好的是能够在读入文本行时返回该行的长度，而在遇到文件结束符时返回 0 ）。且只包含换行符的行，其长度为1.<br>编写 copy 函数：发现某个新读入的行比以前读入的最长行还要长时，就需要把该行保存起来，即 copy 到另一个安全的位置。<br>程序如下：<br><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/* maximum input line length */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 1000 </span></span><br><span class="line"><span class="keyword">int</span> _getline(<span class="keyword">char</span> line[], <span class="keyword">int</span> maxline);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(<span class="keyword">char</span> to[], <span class="keyword">char</span> from[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* print the longest input line */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len;<span class="comment">/* current line length */</span></span><br><span class="line"><span class="keyword">int</span> max; <span class="comment">/* maximum length seen so far */</span></span><br><span class="line"><span class="keyword">char</span> line[MAXLINE];<span class="comment">/* current input line */</span></span><br><span class="line"><span class="keyword">char</span> longest[MAXLINE]; <span class="comment">/* longest line saved here */</span></span><br><span class="line"></span><br><span class="line">max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((len = _getline(line, MAXLINE)) &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (len &gt; max) &#123;</span><br><span class="line">max = len;</span><br><span class="line">copy(longest, line);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (max &gt; <span class="number">0</span>) <span class="comment">/* there was a line */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, longest);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* getline: read a line into line, return maxline */</span></span><br><span class="line"><span class="keyword">int</span> _getline(<span class="keyword">char</span> line[], <span class="keyword">int</span> maxline) &#123;</span><br><span class="line"><span class="keyword">int</span> c, i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;maxline<span class="number">-1</span> &amp;&amp; (c=getchar())!=EOF &amp;&amp; c!=<span class="string">'\n'</span>; ++i)</span><br><span class="line">line[i] = c;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'\n'</span>) &#123;</span><br><span class="line">line[i] = c;</span><br><span class="line">++i;</span><br><span class="line">&#125;</span><br><span class="line">line[i] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* copy: copy 'from' into 'to'; assume to is big enough */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(<span class="keyword">char</span> to[], <span class="keyword">char</span> from[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((to[i] = from[i]) != <span class="string">'\0'</span>)</span><br><span class="line">++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> C-languge </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS实现linearSearch动画时遇到的知识点</title>
      <link href="/2018/02/01/linearSearch-questions/"/>
      <url>/2018/02/01/linearSearch-questions/</url>
      <content type="html"><![CDATA[<h1 id="JS实现linearSearch动画时遇到的知识点"><a href="#JS实现linearSearch动画时遇到的知识点" class="headerlink" title="JS实现linearSearch动画时遇到的知识点"></a>JS实现linearSearch动画时遇到的知识点</h1><p>标签（空格分隔）： JavaScript </p><hr><h2 id="arguments-对象"><a href="#arguments-对象" class="headerlink" title="arguments 对象"></a>arguments 对象</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><code>arguments</code>是一个对应于传递给函数的参数的类数组对象。<br>    <strong>重点：</strong>类数组对象</p><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><code>arguments</code>对象是所有（非箭头）函数中都可用的局部变量。可以使用<code>arguments</code>对象在函数中引用函数的参数。此对象包含传递给函数的每个参数的条目，第一个条目索引从0开始。<br>例如：若一个函数传递了三个参数，可以用下列方式引用：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// expected output: 1</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  <span class="comment">// expected output: 2</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">2</span>]);</span><br><span class="line">  <span class="comment">// expected output: 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></p><p>输出结果：即arguments[0] 对应 参数a；arguments[1] 对应 参数b；arguments[2] 对应 参数c<br><figure class="hljs highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1</span></span><br><span class="line">&gt; <span class="number">2</span></span><br><span class="line">&gt; <span class="number">3</span></span><br></pre></td></tr></table></figure></p><p><code>arguments</code>对象不是一个<code>Array</code>，但它类似于<code>Array</code>，其除了length属性和索引元素之外没有任何<code>Array</code>属性。例如，它没有<code>pop</code>方法，但是它可以被转换为一个真正的<code>Array</code>：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES2015</span></span><br><span class="line"><span class="keyword">const</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：对参数使用slice会阻止某些js引擎中的优化，另一种方式是：<br>    <figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = (<span class="built_in">arguments</span>.length === <span class="number">1</span> ? [<span class="built_in">arguments</span>[<span class="number">0</span>]] : <span class="built_in">Array</span>.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>));</span><br></pre></td></tr></table></figure></p></blockquote><p>如果调用的参数多于正式声明接受的参数，则可以使用<code>arguments</code>对象。（<strong>对可以传递可变数量的参数的函数很有用</strong>)。使用<code>arguments.length</code>来确定传递给函数参数的个数，然后使用<code>arguments</code>对象来处理每个参数。要确定函数<strong>签名</strong>中参数的数量，使用<code>Function.length</code>属性。</p><h3 id="对参数使用-typeof"><a href="#对参数使用-typeof" class="headerlink" title="对参数使用 typeof"></a>对参数使用 typeof</h3><p>typeof参数返回“object”。<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">arguments</span>); <span class="comment">// 'object'</span></span><br></pre></td></tr></table></figure></p><p>可以使用索引确定单个参数的类型。<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">//this will return the typeof individual arguments.</span></span><br></pre></td></tr></table></figure></p><h3 id="对参数使用扩展语法"><a href="#对参数使用扩展语法" class="headerlink" title="对参数使用扩展语法"></a>对参数使用扩展语法</h3><p>还可以使用<code>Array.from()</code>方法或<strong>扩展运算符</strong>将参数转换为真实数组：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="keyword">var</span> args = [...arguments];</span><br></pre></td></tr></table></figure></p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>arguments.callee 指向当前执行的函数</li><li>arguments.caller 指向调用当前函数的函数</li><li>arguments.length 指向传递给当前函数的参数数量</li><li>arguments[@@iterator] 返回一个新的Array迭代器对象，改对象包含参数中每个索引的值。</li></ul><blockquote><p>注意：在严格模式下，<code>arguments</code>对象与之前不同。<code>arguments[@@iterator]</code>不再与函数的实际形参之间共享，同时caller属性也被移除。</p></blockquote><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="定义链接字符串的函数"><a href="#定义链接字符串的函数" class="headerlink" title="定义链接字符串的函数"></a>定义链接字符串的函数</h4><p>这个例子定义了一个函数来连接字符串。这个函数唯一正式声明了的参数是一个字符串，该参数指定一个字符作为衔接点来连接字符串。该函数定义如下：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myConcat</span>(<span class="params">separator</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> args.join(separator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你可以传递任意数量的参数到该函数，并使用每个参数作为列表中的项创建列表。<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// returns "red, orange, blue"</span></span><br><span class="line">myConcat(<span class="string">", "</span>, <span class="string">"red"</span>, <span class="string">"orange"</span>, <span class="string">"blue"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// returns "elephant; giraffe; lion; cheetah"</span></span><br><span class="line">myConcat(<span class="string">"; "</span>, <span class="string">"elephant"</span>, <span class="string">"giraffe"</span>, <span class="string">"lion"</span>, <span class="string">"cheetah"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// returns "sage. basil. oregano. pepper. parsley"</span></span><br><span class="line">myConcat(<span class="string">". "</span>, <span class="string">"sage"</span>, <span class="string">"basil"</span>, <span class="string">"oregano"</span>, <span class="string">"pepper"</span>, <span class="string">"parsley"</span>);</span><br></pre></td></tr></table></figure></p><h4 id="定义创建html列表的方法"><a href="#定义创建html列表的方法" class="headerlink" title="定义创建html列表的方法"></a>定义创建html列表的方法</h4><p>这个例子定义了一个函数通过一个字符串来创建HTML列表。这个函数唯一正式声明了的参数是一个字符。当该参数为 “u” 时，创建一个无序列表 (项目列表)；当该参数为 “o” 时，则创建一个有序列表 (编号列表)。该函数定义如下：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">list</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">"&lt;"</span> + type + <span class="string">"l&gt;&lt;li&gt;"</span>;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  result += args.join(<span class="string">"&lt;/li&gt;&lt;li&gt;"</span>);</span><br><span class="line">  result += <span class="string">"&lt;/li&gt;&lt;/"</span> + type + <span class="string">"l&gt;"</span>; <span class="comment">// end list</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你可以传递任意数量的参数到该函数，并将每个参数作为一个项添加到指定类型的列表中。例如：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> listHTML = list(<span class="string">"u"</span>, <span class="string">"One"</span>, <span class="string">"Two"</span>, <span class="string">"Three"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* listHTML is:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">"&lt;ul&gt;&lt;li&gt;One&lt;/li&gt;&lt;li&gt;Two&lt;/li&gt;&lt;li&gt;Three&lt;/li&gt;&lt;/ul&gt;"</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><h4 id="剩余参数、默认参数和解构赋值参数"><a href="#剩余参数、默认参数和解构赋值参数" class="headerlink" title="剩余参数、默认参数和解构赋值参数"></a>剩余参数、默认参数和解构赋值参数</h4><p><code>arguments</code>对象可以与<strong>剩余参数、默认参数、解构赋值</strong>参数结合使用。<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure></p><p>在严格模式下，剩余参数、默认参数和解构赋值参数的存在不会改变<code>arguments</code>对象的行为，但是在非严格模式下就有所不同了。</p><p>当非严格模式中的函数没有包含剩余参数、默认参数和解构赋值，那么<code>arguments</code>对象中的值<strong>会</strong>跟踪参数的值（反之亦然）。看下面的代码：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">99</span>;   <span class="comment">// 更新了arguments[0] 同样更新了a</span></span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">func(<span class="number">10</span>); <span class="comment">// 99</span></span><br></pre></td></tr></table></figure></p><p>并且<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a</span>) </span>&#123; </span><br><span class="line">  a = <span class="number">99</span>;              <span class="comment">// 更新了a 同样更新了arguments[0] </span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">func(<span class="number">10</span>); <span class="comment">// 99</span></span><br></pre></td></tr></table></figure></p><p>当非严格模式中的函数有包含剩余参数、默认参数和解构赋值，那么<code>arguments</code>对象中的值不会跟踪参数的值（反之亦然）。相反, <code>arguments</code>反映了调用时提供的参数：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a = <span class="number">55</span></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">99</span>; <span class="comment">// updating arguments[0] does not also update a</span></span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">func(<span class="number">10</span>); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></p><p>并且<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a = <span class="number">55</span></span>) </span>&#123; </span><br><span class="line">  a = <span class="number">99</span>; <span class="comment">// updating a does not also update arguments[0]</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">func(<span class="number">10</span>); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></p><p>并且<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a = <span class="number">55</span></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">func(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p><h2 id="babel处理Symbol的麻烦（未理解）"><a href="#babel处理Symbol的麻烦（未理解）" class="headerlink" title="babel处理Symbol的麻烦（未理解）"></a>babel处理Symbol的麻烦（未理解）</h2><p>在使用 babel 转换 ES next 代码的时候，并不会将 Symbol 直接转换成 ES5 中对应的内容，需要引入额外的 polyfill 才能正常工作。</p><p>有的团队为了避免引入这个额外的 polyfill ，会选择不使用 Symbol ，包括通过 babel 生成 Symbol 的特性（比如 <code>for of</code> 等）。</p><p>这时候就会有个比较隐蔽的地方需要注意，就是尽量不要让 babel 生成这样的代码：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _typeof = <span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">"function"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Symbol</span>.iterator === <span class="string">"symbol"</span> ? <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">typeof</span> obj; &#125; : <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123; <span class="keyword">return</span> obj &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">"function"</span> &amp;&amp; obj.constructor === <span class="built_in">Symbol</span> &amp;&amp; obj !== <span class="built_in">Symbol</span>.prototype ? <span class="string">"symbol"</span> : <span class="keyword">typeof</span> obj; &#125;;</span><br></pre></td></tr></table></figure></p><p>这个里面包含了一个 <code>Symbol</code> ，为了让 <code>Symbol</code> 不至于报错，又要想办法在全局先声明一下 <code>Symbol</code> 变量，比较丑陋。</p><p>目前在实践中，发现这样的 ES next 代码会生成上述代码：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">        filter(<span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(a);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>生成的代码为：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _typeof = <span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">"function"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Symbol</span>.iterator === <span class="string">"symbol"</span> ? <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">typeof</span> obj; &#125; : <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123; <span class="keyword">return</span> obj &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">"function"</span> &amp;&amp; obj.constructor === <span class="built_in">Symbol</span> &amp;&amp; obj !== <span class="built_in">Symbol</span>.prototype ? <span class="string">"symbol"</span> : <span class="keyword">typeof</span> obj; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> _ret = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">            filter(<span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(a);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                v: <span class="keyword">void</span> <span class="number">0</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">typeof</span> _ret === <span class="string">"undefined"</span> ? <span class="string">"undefined"</span> : _typeof(_ret)) === <span class="string">"object"</span>) <span class="keyword">return</span> _ret.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码有什么特征呢？就是在 <code>if</code> 块中定义了函数，函数中访问了 <code>if</code> 块中的“块级变量”，并且 <code>if</code> 块使用了 <code>return</code> 语句。</p><p>可以看出，<code>babel</code> 为了保证 <code>if</code> 块内变量的作用域，会套一个匿名函数，同时由于 <code>if</code> 块中存在 <code>return</code> 返回，所以就用 <code>_ret</code> 来接收匿名函数的返回值。然后后面为啥会生成那串长长的对 <code>_ret</code> 的类型判断代码，目前还不太清楚，可能要结合 <code>babel</code> 的内部处理逻辑去看了，单从生成的代码看，这个完全是多余的。</p><p>推而广之， <code>for</code> 块等局部非函数作用域都会有类似的问题。</p><p>实际上，从代码编写规范角度来看，是不应该在这种局部作用域块里面定义函数的。函数应该是一段通用的代码，不应该缩在那一小块里面。</p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> linearSearch </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>由linear search引出的getchar()输入字符和数字问题</title>
      <link href="/2018/01/31/c-getchar/"/>
      <url>/2018/01/31/c-getchar/</url>
      <content type="html"><![CDATA[<h1 id="由linear-search引出的getchar-输入字符和数字问题"><a href="#由linear-search引出的getchar-输入字符和数字问题" class="headerlink" title="由linear search引出的getchar()输入字符和数字问题"></a>由linear search引出的getchar()输入字符和数字问题</h1><p>@C—language </p><hr><blockquote><p>起因：在考研之际，重新拾起快忘光了的C语言，大一的时候没有认真学习，现在还真的发现好多以前遗漏了的问题<br>主要内容：C语言的获取字符输入方法getchar()，以及如何读取int型变量<br>操作系统：windows<br>编译器：Cygwin的gnu环境</p></blockquote><h2 id="getchar-的用途"><a href="#getchar-的用途" class="headerlink" title="getchar()的用途"></a>getchar()的用途</h2><p>初始代码（<code>linearSearch.c</code>)<br><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 10</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">linearSearch</span><span class="params">(<span class="keyword">int</span> [], <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> nums[LEN] = &#123;<span class="number">5</span>, <span class="number">10</span>, <span class="number">22</span>, <span class="number">32</span>, <span class="number">45</span>, <span class="number">67</span>, <span class="number">73</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">101</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> desiredElem, location;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Input the desired element, please: \n"</span>);</span><br><span class="line">desiredElem = getchar();</span><br><span class="line"></span><br><span class="line">location = linearSearch(nums, LEN, desiredElem);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(location != <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The desired element was found at index location %d.\n"</span>, location);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The desired element was not found in the list. the location is %d.\n"</span>, location);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this function returns the location of key in the list</span></span><br><span class="line"><span class="comment">// a -1 is returned if the value is not found</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">linearSearch</span><span class="params">(<span class="keyword">int</span> <span class="built_in">list</span>[], <span class="keyword">int</span> size, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"key = %d.\n"</span>, key);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">list</span>[i] == key)&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>乍看感觉这段代码还像模像样的，但是在Cygwin中编译结果：<br><figure class="hljs highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./cygwinTest.exe</span><br><span class="line">Input the desired element, please:</span><br><span class="line"><span class="number">10</span></span><br><span class="line">key = <span class="number">49</span>.</span><br><span class="line">The desired element was not found in the list. the location is -<span class="number">1</span>.</span><br></pre></td></tr></table></figure></p><p>可以轻易发现是getchar()方法出了问题，下面看看getchar()：</p><ul><li>名称：getchar()</li><li>定义：用在文件读取中，读取文件时要区分文件中有效数据与输入结束符的问题，C语言解决方法是，在没有输入时，getchar函数将返回一个特殊值，这个特殊值与任何实际字符都不同，成为“EOF”（文件结束符），为int类型</li><li>返回值类型：int类型(对应字符的ASCII值)</li><li>一般用法：<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">读一个字符</span><br><span class="line"><span class="keyword">while</span>(该字符不是EOF)</span><br><span class="line">    输出刚读入的字符</span><br><span class="line">    读下一个字符</span><br></pre></td></tr></table></figure></li></ul><p>转换为C：<br><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/* copy input to output; 1st version */</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c != EOF)&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(c);</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以找到问题的原因了：因为我们是要得到int型，但是getchar返回的是输入字符的ASCII码，所以就出错了，应该使用scanf函数：<br><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;desiredElem);</span><br></pre></td></tr></table></figure></p><p>编译结果如下：<br><figure class="hljs highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./cygwinTest.exe</span><br><span class="line">Input the desired element, please:</span><br><span class="line"><span class="number">22</span></span><br><span class="line">key = <span class="number">22</span>.</span><br><span class="line">The desired element was found at index location <span class="number">2</span>.</span><br></pre></td></tr></table></figure></p><blockquote><p>下面引出今天叙述的重点：C语言如何从键盘输入数据</p></blockquote><h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf()"></a>scanf()</h3><p>scanf == scan format，意思是格式化扫描，即从键盘获得用户输入<br>一般用法为：<br><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);  <span class="comment">//输入整数并赋值给变量a</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b);  <span class="comment">//输入整数并赋值给变量b</span></span><br></pre></td></tr></table></figure></p><p>scanf与printf非常相似：<br><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);  <span class="comment">// 获取用户输入的两个整数，分别赋值给变量 a 和 b</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d"</span>, a, b);  <span class="comment">// 将变量 a 和 b 的是在显示器上输出。</span></span><br></pre></td></tr></table></figure></p><p>它们都有格式控制字符串，都有变量列表。不同的是，scanf的变量前要带一个<code>&amp;</code>符号，称为“取地址符”，即获得变量在内存中的地址。<br>数据都是以二进制的形式保存在内存中的，字节（Byte）是最小的可操作单位。为了便于管理，我们给每个字节分配了一个编号，使用该字节时，只要知道编号就可以，就像每个学生都有学号，老师会随机抽取学号来让学生回答问题。字节的编号是有顺序的，从 0 开始，接下来是 1、2、3……<br>下图是 4G 内存中每个字节的编号（以十六进制表示）：</p><p><img src="https://raw.githubusercontent.com/Yojiaku/hexoBlogPic/676fef3df90d1f2b094c7ae72fa1503eceb5adae/2018-1-31charStore.png" alt="字节编号"></p><p>这个编号，就叫做<strong>地址（Address）</strong>。<code>int a;</code>    会在内存中分配四个字节的空间，我们将第一个字节的地址称为变量 a 的地址，也就是<code>&amp;a</code>的值。对于的整数、浮点数、字符，都要使用 &amp; 获取它们的地址，scanf 会根据地址把读取到的数据写入内存。<br>不妨将变量地址数出来看看：<br><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="string">'F'</span>;</span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">12</span>;</span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">452</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;a=%#x, &amp;b=%#x, &amp;c=%#x\n"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="hljs highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./scanfAddress.exe</span><br><span class="line">&amp;a=<span class="number">0</span>xffffcbfc, &amp;b=<span class="number">0</span>xffffcbf8, &amp;c=<span class="number">0</span>xffffcbf4</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/Yojiaku/hexoBlogPic/f516a7e74f92ebc1991939583757173687f6f561/2018-1-31charStore2.png" alt="abc变量内存地址"></p><blockquote><p>注意：这里看到的地址是虚拟地址，并不等于它在物理内存中的地址。虚拟地址是现代计算机因内存管理的需要才提出的概念。</p></blockquote><p>以上。</p>]]></content>
      
      
        <tags>
            
            <tag> C—language </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>markdown语法归纳</title>
      <link href="/2018/01/30/hello-hexo/"/>
      <url>/2018/01/30/hello-hexo/</url>
      <content type="html"><![CDATA[<p><a href="https://www.zybuluo.com/mdeditor" title="作业部落旗下 Cmd 在线 Markdown 编辑阅读器" target="_blank" rel="noopener">『Cmd 技术渲染的沙箱页面，点击此处编写自己的文档』</a></p><h1 id="Cmd-Markdown-简明语法手册"><a href="#Cmd-Markdown-简明语法手册" class="headerlink" title="Cmd Markdown 简明语法手册"></a>Cmd Markdown 简明语法手册</h1><p>标签： Cmd-Markdown</p><hr><h3 id="1-斜体和粗体"><a href="#1-斜体和粗体" class="headerlink" title="1. 斜体和粗体"></a>1. 斜体和粗体</h3><p>使用 * 和 ** 表示斜体和粗体。</p><p>示例：</p><p>这是 <em>斜体</em>，这是 <strong>粗体</strong>。</p><h3 id="2-分级标题"><a href="#2-分级标题" class="headerlink" title="2. 分级标题"></a>2. 分级标题</h3><p>使用 === 表示一级标题，使用 — 表示二级标题。</p><p>示例：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这是一个一级标题</span><br><span class="line">============================</span><br><span class="line"></span><br><span class="line">这是一个二级标题</span><br><span class="line">--------------------------------------------------</span><br><span class="line"></span><br><span class="line">### 这是一个三级标题</span><br></pre></td></tr></table></figure><p>你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。</p><h3 id="3-外链接"><a href="#3-外链接" class="headerlink" title="3. 外链接"></a>3. 外链接</h3><p>使用 [描述](链接地址) 为文字增加外链接。</p><p>示例：</p><p>这是去往 <a href="http://ghosertblog.github.com" target="_blank" rel="noopener">本人博客</a> 的链接。</p><h3 id="4-无序列表"><a href="#4-无序列表" class="headerlink" title="4. 无序列表"></a>4. 无序列表</h3><p>使用 *，+，- 表示无序列表。</p><p>示例：</p><ul><li>无序列表项 一</li><li>无序列表项 二</li><li>无序列表项 三</li></ul><h3 id="5-有序列表"><a href="#5-有序列表" class="headerlink" title="5. 有序列表"></a>5. 有序列表</h3><p>使用数字和点表示有序列表。</p><p>示例：</p><ol><li>有序列表项 一</li><li>有序列表项 二</li><li>有序列表项 三</li></ol><h3 id="6-文字引用"><a href="#6-文字引用" class="headerlink" title="6. 文字引用"></a>6. 文字引用</h3><p>使用 &gt; 表示文字引用。</p><p>示例：</p><blockquote><p>野火烧不尽，春风吹又生。</p></blockquote><h3 id="7-行内代码块"><a href="#7-行内代码块" class="headerlink" title="7. 行内代码块"></a>7. 行内代码块</h3><p>使用 `代码` 表示行内代码块。</p><p>示例：</p><p>让我们聊聊 <code>html</code>。</p><h3 id="8-代码块"><a href="#8-代码块" class="headerlink" title="8.  代码块"></a>8.  代码块</h3><p>使用 四个缩进空格 表示代码块。</p><p>示例：</p><pre><code>这是一个代码块，此行左侧有四个不可见的空格。</code></pre><h3 id="9-插入图像"><a href="#9-插入图像" class="headerlink" title="9.  插入图像"></a>9.  插入图像</h3><p>使用 ![描述](图片链接地址) 插入图像。</p><p>示例：</p><p><img src="https://www.zybuluo.com/static/img/my_head.jpg" alt="我的头像"></p><h1 id="Cmd-Markdown-高阶语法手册"><a href="#Cmd-Markdown-高阶语法手册" class="headerlink" title="Cmd Markdown 高阶语法手册"></a>Cmd Markdown 高阶语法手册</h1><h3 id="1-内容目录"><a href="#1-内容目录" class="headerlink" title="1. 内容目录"></a>1. 内容目录</h3><p>在段落中填写 <code>[TOC]</code> 以显示全文内容的目录结构。</p><p>[TOC]</p><h3 id="2-标签分类"><a href="#2-标签分类" class="headerlink" title="2. 标签分类"></a>2. 标签分类</h3><p>在编辑区任意行的列首位置输入以下代码给文稿标签：</p><p>标签： 数学 英语 Markdown</p><p>或者</p><p>Tags： 数学 英语 Markdown</p><h3 id="3-删除线"><a href="#3-删除线" class="headerlink" title="3. 删除线"></a>3. 删除线</h3><p>使用 ~~ 表示删除线。</p><p><del>这是一段错误的文本。</del></p><h3 id="4-注脚"><a href="#4-注脚" class="headerlink" title="4. 注脚"></a>4. 注脚</h3><p>使用 [^keyword] 表示注脚。</p><p>这是一个注脚[^footnote]的样例。</p><p>这是第二个注脚[^footnote2]的样例。</p><h3 id="5-LaTeX-公式"><a href="#5-LaTeX-公式" class="headerlink" title="5. LaTeX 公式"></a>5. LaTeX 公式</h3><p>$ 表示行内公式： </p><p>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</p><p>$$ 表示整行公式：</p><p>$$\sum_{i=1}^n a_i=0$$</p><p>$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$</p><p>$$\sum^{j-1}<em>{k=0}{\widehat{\gamma}</em>{kj} z_k}$$</p><p>访问 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">MathJax</a> 参考更多使用方法。</p><h3 id="6-加强的代码块"><a href="#6-加强的代码块" class="headerlink" title="6. 加强的代码块"></a>6. 加强的代码块</h3><p>支持四十一种编程语言的语法高亮的显示，行号显示。</p><p>非代码示例：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install vim-gnome</span><br></pre></td></tr></table></figure><p>Python 示例：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(param1=<span class="string">''</span>, param2=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">'''A docstring'''</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Greater'</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">'''interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt'''</span></span><br></pre></td></tr></table></figure><p>JavaScript 示例：</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* nth element in the fibonacci series.</span></span><br><span class="line"><span class="comment">* @param n &gt;= 0</span></span><br><span class="line"><span class="comment">* @return the nth element, &gt;= 0.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> tmp;</span><br><span class="line">  <span class="keyword">while</span> (--n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    tmp = a;</span><br><span class="line">    a += b;</span><br><span class="line">    b = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(fib(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><h3 id="7-流程图"><a href="#7-流程图" class="headerlink" title="7. 流程图"></a>7. 流程图</h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start:&gt;https://www.zybuluo.com</span><br><span class="line">io=&gt;inputoutput: verification</span><br><span class="line">op=&gt;operation: Your Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">sub=&gt;subroutine: Your Subroutine</span><br><span class="line">e=&gt;end</span><br><span class="line"></span><br><span class="line">st-&gt;io-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;sub-&gt;io</span><br></pre></td></tr></table></figure><h4 id="更多语法参考：流程图语法参考"><a href="#更多语法参考：流程图语法参考" class="headerlink" title="更多语法参考：流程图语法参考"></a>更多语法参考：<a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="noopener">流程图语法参考</a></h4><h3 id="8-序列图"><a href="#8-序列图" class="headerlink" title="8. 序列图"></a>8. 序列图</h3><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Title: Here is a title</span><br><span class="line">A-&gt;B: Normal line</span><br><span class="line">B--&gt;C: Dashed line</span><br><span class="line">C-&gt;&gt;D: Open arrow</span><br><span class="line">D--&gt;&gt;A: Dashed open arrow</span><br></pre></td></tr></table></figure><h4 id="更多语法参考：序列图语法参考"><a href="#更多语法参考：序列图语法参考" class="headerlink" title="更多语法参考：序列图语法参考"></a>更多语法参考：<a href="http://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="noopener">序列图语法参考</a></h4><h3 id="9-甘特图"><a href="#9-甘特图" class="headerlink" title="9. 甘特图"></a>9. 甘特图</h3><p>甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">title 项目开发流程</span><br><span class="line">section 项目确定</span><br><span class="line">    需求分析       :a1, 2016-06-22, 3d</span><br><span class="line">    可行性报告     :after a1, 5d</span><br><span class="line">    概念验证       : 5d</span><br><span class="line">section 项目实施</span><br><span class="line">    概要设计      :2016-07-05  , 5d</span><br><span class="line">    详细设计      :2016-07-08, 10d</span><br><span class="line">    编码          :2016-07-15, 10d</span><br><span class="line">    测试          :2016-07-22, 5d</span><br><span class="line">section 发布验收</span><br><span class="line">    发布: 2d</span><br><span class="line">    验收: 3d</span><br></pre></td></tr></table></figure><h4 id="更多语法参考：甘特图语法参考"><a href="#更多语法参考：甘特图语法参考" class="headerlink" title="更多语法参考：甘特图语法参考"></a>更多语法参考：<a href="https://knsv.github.io/mermaid/#gant-diagrams" target="_blank" rel="noopener">甘特图语法参考</a></h4><h3 id="10-Mermaid-流程图"><a href="#10-Mermaid-流程图" class="headerlink" title="10. Mermaid 流程图"></a>10. Mermaid 流程图</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A[Hard edge] --&gt;|Link text| B(Round edge)</span><br><span class="line">B --&gt; C&#123;Decision&#125;</span><br><span class="line">C --&gt;|One| D[Result one]</span><br><span class="line">C --&gt;|Two| E[Result two]</span><br></pre></td></tr></table></figure><h4 id="更多语法参考：Mermaid-流程图语法参考"><a href="#更多语法参考：Mermaid-流程图语法参考" class="headerlink" title="更多语法参考：Mermaid 流程图语法参考"></a>更多语法参考：<a href="https://knsv.github.io/mermaid/#flowcharts-basic-syntax" target="_blank" rel="noopener">Mermaid 流程图语法参考</a></h4><h3 id="11-Mermaid-序列图"><a href="#11-Mermaid-序列图" class="headerlink" title="11. Mermaid 序列图"></a>11. Mermaid 序列图</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;John: Hello John, how are you?</span><br><span class="line">loop every minute</span><br><span class="line">    John--&gt;Alice: Great!</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="更多语法参考：Mermaid-序列图语法参考"><a href="#更多语法参考：Mermaid-序列图语法参考" class="headerlink" title="更多语法参考：Mermaid 序列图语法参考"></a>更多语法参考：<a href="https://knsv.github.io/mermaid/#sequence-diagrams" target="_blank" rel="noopener">Mermaid 序列图语法参考</a></h4><h3 id="12-表格支持"><a href="#12-表格支持" class="headerlink" title="12. 表格支持"></a>12. 表格支持</h3><table><thead><tr><th>项目</th><th style="text-align:right">价格</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td>计算机</td><td style="text-align:right">\$1600</td><td style="text-align:center">5</td></tr><tr><td>手机</td><td style="text-align:right">\$12</td><td style="text-align:center">12</td></tr><tr><td>管线</td><td style="text-align:right">\$1</td><td style="text-align:center">234</td></tr></tbody></table><h3 id="13-定义型列表"><a href="#13-定义型列表" class="headerlink" title="13. 定义型列表"></a>13. 定义型列表</h3><p>名词 1<br>:   定义 1（左侧有一个可见的冒号和四个不可见的空格）</p><p>代码块 2<br>:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）</p><pre><code>代码块（左侧有八个不可见的空格）</code></pre><h3 id="14-Html-标签"><a href="#14-Html-标签" class="headerlink" title="14. Html 标签"></a>14. Html 标签</h3><p>本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格：</p><pre><code>&lt;table&gt;    &lt;tr&gt;        &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt;        &lt;th&gt;星期一&lt;/th&gt;        &lt;th&gt;星期二&lt;/th&gt;        &lt;th&gt;星期三&lt;/th&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;李强&lt;/td&gt;        &lt;td&gt;张明&lt;/td&gt;        &lt;td&gt;王平&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;</code></pre><table><br>    <tr><br>        <th rowspan="2">值班人员</th><br>        <th>星期一</th><br>        <th>星期二</th><br>        <th>星期三</th><br>    </tr><br>    <tr><br>        <td>李强</td><br>        <td>张明</td><br>        <td>王平</td><br>    </tr><br></table><h3 id="15-内嵌图标"><a href="#15-内嵌图标" class="headerlink" title="15. 内嵌图标"></a>15. 内嵌图标</h3><p>本站的图标系统对外开放，在文档中输入</p><pre><code>&lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt;</code></pre><p>即显示微博的图标： <i class="icon-weibo icon-2x"></i></p><p>替换 上述 <code>i 标签</code> 内的 <code>icon-weibo</code> 以显示不同的图标，例如：</p><pre><code>&lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt;</code></pre><p>即显示人人的图标： <i class="icon-renren icon-2x"></i></p><p>更多的图标和玩法可以参看 <a href="http://fortawesome.github.io/Font-Awesome/3.2.1/icons/" target="_blank" rel="noopener">font-awesome</a> 官方网站。</p><h3 id="16-待办事宜-Todo-列表"><a href="#16-待办事宜-Todo-列表" class="headerlink" title="16. 待办事宜 Todo 列表"></a>16. 待办事宜 Todo 列表</h3><p>使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：</p><pre><code>- [ ] **Cmd Markdown 开发**    - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率    - [ ] 支持以 PDF 格式导出文稿    - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments)    - [x] 改进 LaTex 功能        - [x] 修复 LaTex 公式渲染问题        - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers)- [ ] **七月旅行准备**    - [ ] 准备邮轮上需要携带的物品    - [ ] 浏览日本免税店的物品    - [x] 购买蓝宝石公主号七月一日的船票</code></pre><p>对应显示如下待办事宜 Todo 列表：</p><ul><li style="list-style: none"><input type="checkbox"> <strong>Cmd Markdown 开发</strong><ul><li style="list-style: none"><input type="checkbox"> 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li><li style="list-style: none"><input type="checkbox"> 支持以 PDF 格式导出文稿</li><li style="list-style: none"><input type="checkbox" checked> 新增Todo列表功能 <a href="https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments" target="_blank" rel="noopener">语法参考</a></li><li style="list-style: none"><input type="checkbox" checked> 改进 LaTex 功能<ul><li style="list-style: none"><input type="checkbox" checked> 修复 LaTex 公式渲染问题</li><li style="list-style: none"><input type="checkbox" checked> 新增 LaTex 公式编号功能 <a href="http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers" target="_blank" rel="noopener">语法参考</a></li></ul></li></ul></li><li style="list-style: none"><input type="checkbox"> <strong>七月旅行准备</strong><ul><li style="list-style: none"><input type="checkbox"> 准备邮轮上需要携带的物品</li><li style="list-style: none"><input type="checkbox"> 浏览日本免税店的物品</li><li style="list-style: none"><input type="checkbox" checked> 购买蓝宝石公主号七月一日的船票</li></ul></li></ul><p>[^footnote]: 这是一个 <em>注脚</em> 的 <strong>文本</strong>。</p><p>[^footnote2]: 这是另一个 <em>注脚</em> 的 <strong>文本</strong>。</p>]]></content>
      
      
        <tags>
            
            <tag> markdown语法 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
  
</search>
