<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>test_my_site</title>
      <link href="/2018/07/05/test-my-site/"/>
      <url>/2018/07/05/test-my-site/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/07/05/hello-world/"/>
      <url>/2018/07/05/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><p>顺序：<br>先：hexo clean 清除缓存</p><p>然后： hexo g 生成待发布的文件</p><p>最后： hexo d 发布</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>斐波那契查找</title>
      <link href="/2018/06/30/Fibonacci_Search/"/>
      <url>/2018/06/30/Fibonacci_Search/</url>
      <content type="html"><![CDATA[<p>斐波那契查找就是在二分查找的基础上根据斐波那契数列进行分割的。在斐波那契数列找一个等于略大于查找表中元素个数的数F[n]，将原查找表扩展为长度为F<a href="如果要补充元素，则补充重复最后一个元素，直到满足F[n]个元素">n</a>，完成后进行斐波那契分割，即F[n]个元素分割为前半部分F[n-1]个元素，后半部分F[n-2]个元素，找出要查找的元素在那一部分并递归，直到找到。</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>斐波那契查找也是有序查找的一种，它是利用黄金分割原理来实现的。该查找方法的精髓在于采用最接近查找长度的斐波那契数值来确定拆分点。</p><h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><p>既然叫斐波那契查找，首先得弄明白什么是斐波那契数列。相信大家对这个著名的数列也并不陌生，无论是C语言的循环、递归，还是高数的数列，斐波那契数列都是一个重要的存在。而此处主要是用到了它的一条性质：前一个数除以相邻的后一个数，比值无限接近黄金分割。<br>&nbsp;<br>斐波那契数列指的是这样一个数列 1，1，2，3，5，8，13， 21，34，55， 89，144，233……这个数列从第3项开始，每一项都等于前两项之和。如果我们用数学函数来定义是：<br><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/pic/inter.png" alt=""></p><p>&nbsp;<br>当数列趋向于无穷大时，前一项与后一项的比值越来越逼近黄金分割0.618（或者说后一项与前一项的比值小数部分越来越逼近0.618）。<br>&nbsp;<br>1÷1=1，1÷2=0.5，2÷3=0.666…，3÷5=0.6，5÷8=0.625…，55÷89=0.617977…，144÷233=0.618025…，越到后面，这些比值越接近黄金比。</p><h1 id="斐波那契查找原理"><a href="#斐波那契查找原理" class="headerlink" title="斐波那契查找原理"></a>斐波那契查找原理</h1><p>斐波那契查找是一种在有序表中高效查找指定元素的算法，比折半查找要复杂一些，主要复杂在要多做不少准备工作。下面看它的工作流程：</p><ol><li>计算并保存一个斐波那契序列的数组，方便以后取值。数组名记为F，例如F[1]=1，F[2]=1，F[3]=2，F[4]=3，F[5]=5，F[6]=8，F[7]=13，F[8]=21</li><li>把有序数组的长度扩充到A.length=F[k]-1，k是满足条件的最小值，比如数组长度为13，那么就把它长度扩充到F[8]-1=20，所有在末尾添加的扩充元素都是原数组最后一个元素的复制品。</li><li>找到mid元素，不断进行二分比较，直到找到目标元素为止，这一步的做法与折半查找一模一样，仅仅是计算mid的公式从(low+high)/2改为low+(F[k-1]-1)。</li></ol><p>举个例子来讲，现有长度为9的数组，要对它进行拆分，对应的斐波那契数列（长度先随便取，只要最大数大于9即可）{1，1，2，3，5，8，13，21，34}，不难发现，大于9且最接近9的斐波那契数值是f[6]=13，为了满足所谓的黄金分割，所以它的第一个拆分点应该就是f[6]的前一个值f[5]=8，即待查找数组array的第8个数，对应到下标就是array[7]，依次类推。</p><p>推演到一般情况，假设有待查找数组array[n]和斐波那契数组F[k],并且n满足n&gt;=F[k]-1&amp;&amp;n&lt;F[k+1]-1，则它的第一个拆分点middle=F[k]-1。</p><p>这里得注意，如果n刚好等于F[k]-1,待查找数组刚好拆成F[k-1]和F[k-2]两部分，那万事大吉你好我好；然而大多数情况并不能尽人意，n会小于F[k]-1,这时候可以拆成完整F[k-1]和残疾的F[k-2]两部分，那怎么办呢？</p><p>聪明的前辈们早已想好了解决办法，对了，就是补齐，用最大的数来填充F[k-2]的残缺部分，如果查找的位置落到补齐的部分，那就可以确定要找的那个数就是最后一个最大的了。<br><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/pic/feibo.png" alt="image"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">public class FbonacciSearch &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * &lt;p&gt;name: main&lt;/p&gt;</span><br><span class="line">     * &lt;p&gt;description: &lt;/p&gt;</span><br><span class="line">     * &lt;p&gt;return: void&lt;/p&gt;</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        int[] array = &#123; 1, 5, 15, 22, 25, 31, 39, 42, 47, 49, 59, 68, 88, 88,</span><br><span class="line">                88, 88, 88 &#125;;</span><br><span class="line">        System.out.println(&quot;result: &quot; + fbSearch(array, 31));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * name: fbSearch</span><br><span class="line">     * &lt;/p&gt;</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * description: 斐波那契查找实现</span><br><span class="line">     * &lt;/p&gt;</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * return: int</span><br><span class="line">     * &lt;/p&gt;</span><br><span class="line">     */</span><br><span class="line">    public static int fbSearch(int[] array, int a) &#123;</span><br><span class="line">        if (array == null || array.length == 0) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int length = array.length;</span><br><span class="line">            int[] fb = makeFbArray(20);// 制造一个长度为10的斐波数列</span><br><span class="line">            int k = 0;</span><br><span class="line">            while (length &gt; fb[k] - 1) &#123;// 找出数组的长度在斐波数列（减1）中的位置，将决定如何拆分</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            int[] temp = Arrays.copyOf(array, fb[k] - 1);// 构造一个长度为fb[k] - 1的新数列</span><br><span class="line">            for (int i = length; i &lt; temp.length; i++) &#123;</span><br><span class="line">                if (i &gt;= length) &#123;</span><br><span class="line">                    temp[i] = array[length - 1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            int low = 0;</span><br><span class="line">            int hight = array.length - 1;</span><br><span class="line">            while (low &lt;= hight) &#123;</span><br><span class="line">                int middle = low + fb[k - 1] - 1;</span><br><span class="line">                if (temp[middle] &gt; a) &#123;</span><br><span class="line">                    hight = middle - 1;</span><br><span class="line">                    k = k - 1;</span><br><span class="line">                &#125; else if (temp[middle] &lt; a) &#123;</span><br><span class="line">                    low = middle + 1;</span><br><span class="line">                    k = k - 2;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (middle &lt;= hight) &#123;</span><br><span class="line">                        return middle;// 若相等则说明mid即为查找到的位置</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        return hight;// middle的值已经大于hight,进入扩展数组的填充部分,即最后一个数就是要查找的数。</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return -1;</span><br><span class="line">            // return recurse(array, fb, a, low, hight, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * name: makeFbArray</span><br><span class="line">     * &lt;/p&gt;</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * description: 生成指定长度的斐波数列</span><br><span class="line">     * &lt;/p&gt;</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * return: int[]</span><br><span class="line">     * &lt;/p&gt;</span><br><span class="line">     */</span><br><span class="line">    public static int[] makeFbArray(int length) &#123;</span><br><span class="line">        int[] array = null;</span><br><span class="line">        if (length &gt; 2) &#123;</span><br><span class="line">            array = new int[length];</span><br><span class="line">            array[0] = 1;</span><br><span class="line">            array[1] = 1;</span><br><span class="line">            for (int i = 2; i &lt; length; i++) &#123;</span><br><span class="line">                array[i] = array[i - 1] + array[i - 2];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * name: recurse</span><br><span class="line">     * &lt;/p&gt;</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * description: 递归实现，可以来代替while (low &lt;= hight)遍历</span><br><span class="line">     * &lt;/p&gt;</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * return: int</span><br><span class="line">     * &lt;/p&gt;</span><br><span class="line">     */</span><br><span class="line">    public static int recurse(int[] array, int[] fb, int a, int low, int hight,</span><br><span class="line">            int k) &#123;</span><br><span class="line">        if (array == null || array.length == 0 || a &lt; array[low]</span><br><span class="line">                || a &gt; array[hight] || low &gt; hight) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int middle = low + fb[k - 1] - 1;</span><br><span class="line">        if (a &lt; array[middle]) &#123;</span><br><span class="line">            return recurse(array, fb, a, low, middle - 1, k - 1);</span><br><span class="line">        &#125; else if (a &gt; array[middle]) &#123;</span><br><span class="line">            return recurse(array, fb, a, middle + 1, hight, k - 2);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (middle &lt;= hight) &#123;</span><br><span class="line">                return middle;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return hight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>斐波那契查找算法的核心在于:</p><ol><li>当 key=a[mid]时，查找就成功；</li><li>当 key&lt;a[mid)时，新范围是第 Iow 个到第 mid-l 个，此时范围个数为 F[k-1]-1 个;</li><li>当 key&gt;a[mid]时，新范围是第 m+l 个到第 high 个，此时范围个数为 F[k-2] -1 个。</li></ol><p>也就是说，如果要查找的记录在右侧，则左侧的数据都不用再判断了，不断反复进行下去，对处于当中的大部分数据，其工作效率要高一些。所以尽管斐波那契查找的时间复杂也为0(logn)， 但就平均性能来说，斐波那契查找要优于折半查找。可惜如果是最坏情况，比如这里 key=l ， 那么始终都处于左侧长半区在查找，则查找效率要低于折半查找。</p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>插值查找</title>
      <link href="/2018/06/29/Interpolation_Search/"/>
      <url>/2018/06/29/Interpolation_Search/</url>
      <content type="html"><![CDATA[<p>我们很容易理解折半查找（二分查找），那么在折半查找原理的基础上我们会进一步思考，为什么一定要折半呢，而不是折四分之一，或者其他呢？比如说我们要搜索的值更接近最后一个元素，为什么还要从中间开始搜索，而不是从较后面的一部分开始搜索呢？因此研究学者们在折半查找的基础上进行了改进，以便更迅速准确的找到要搜素的目标值。</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>插值查找是对二分查找的改进，其中排序数组中的值是均匀分布。 插值查找根据正在搜索的键的值，可以去不同的位置。插值查找也是有序表查找算法。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>插值查找的前提是有序数列元素的值是成线性增长的。对于大多数有序数列来说，这前提是可以成立的。我们不妨假设它就是成立的，那样，当我们知道一个要查找值的大小后。就可以根据数列线性增长的性质，求出要查找的值在数列中的大概位置。比如说在数列A[low,high]中查找key。我们key的下标为mid。由于数列线性增长，我们不难得到这个等式：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\frac&#123;mid-low&#125;&#123;high-low&#125;=\frac&#123;key-A[low]&#125;&#123;A[high]-A[low]&#125;</span><br></pre></td></tr></table></figure><p>进而得出：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mid = low+\frac&#123;key-A[low]&#125;&#123;A[high]-A[low]&#125;*(high-low)</span><br></pre></td></tr></table></figure><p>因此我们可求出mid的值，以它为轴点，可以极大的提高查找的收敛速度。说到这里，大家也都明白了，其实插值查找就是更准的二分查找而已。我们可以将插值查找与折半查找进行对比分析，看看插值查找的改进优化之处：</p><p>我们先将折半查找的核心公式变换得到：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mid = \frac&#123;low+high&#125;&#123;2&#125;=low+\frac&#123;1&#125;&#123;2&#125;(high-low)</span><br></pre></td></tr></table></figure><p>将此公式与插值公式进行对比可发现：折半查找的公式中的<code>$\frac{1}{2}$</code>变成<code>$\frac{key-A[low]}{A[high]-A[low]}$</code>就成了插值查找的核心公式。这样的改进有什么道理呢？</p><p>纯粹从公式上分析，如果key的值和下界的值的差值<code>$key-A[low]$</code>相对于上下界的差值<code>$A[high]-A[low]$</code>占比例较大，说明key值更靠近上界，mid的值会较大；反之如果比例较小，说明关键字与下界的值差别不大，mid较小，说明我们更倾向于在下界附近来寻找key值。</p><p>通过一个简单的例子进一步说明改进之后的优势。假设A[11]={0，1，16，24，35，47，59，62，73，88，99}，则low=1，hig=10，A[low]=1，A[high]=99。如果我们要找的是key=16时，按照折半查找的原理，我们需要四次才可以得到结果（读者可以自行计算），但如果用插值查找，则<code>$\frac{key-A[low]}{A[high]-A[low]}=\frac{16-1}{99-1}=0.153$</code>即mid = 1 + 0.153 *（10 - 1）= 2.377，取整得到mid=2，我们只需要二次就可以查找到结果，显然大大提高了查找的效率。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line">int InterpolationSearch(int *A,int e,int lo,int hi)  </span><br><span class="line">&#123;  </span><br><span class="line">    while(lo&lt;hi)  </span><br><span class="line">    &#123;  </span><br><span class="line">        int mi=lo+(hi-lo-1)*(e-A[lo])/(A[hi-1]-A[lo]);//获取查找轴点   </span><br><span class="line">        if(mi&gt;=10)//排除越界情况   </span><br><span class="line">        &#123;  </span><br><span class="line">            return -1;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if(e&lt;A[mi])  </span><br><span class="line">        &#123;  </span><br><span class="line">            hi=mi;//深入左侧[lo,hi)   </span><br><span class="line">        &#125;  </span><br><span class="line">        else if(e&gt;A[mi])  </span><br><span class="line">        &#123;  </span><br><span class="line">            lo=mi+1;//深入右侧[mi+1,hi)   </span><br><span class="line">        &#125;  </span><br><span class="line">        else  </span><br><span class="line">        &#123;  </span><br><span class="line">            return mi;//命中   </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return -1;//查找失败   </span><br><span class="line">&#125;  </span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    /*******插值查找测试******/  </span><br><span class="line">    int a[10];  </span><br><span class="line">    cout&lt;&lt;&quot;测试数组：&quot;;  </span><br><span class="line">    for(int i=0;i&lt;10;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        a[i]=(float)(i);  </span><br><span class="line">        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;   </span><br><span class="line">    &#125;  </span><br><span class="line">    cout&lt;&lt;endl;  </span><br><span class="line">    cout&lt;&lt;&quot;查找结果：&quot; ;  </span><br><span class="line">    for(int i=0;i&lt;13;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        cout&lt;&lt;InterpolationSearch(a,i-1,0,10)&lt;&lt;&quot; &quot;;   </span><br><span class="line">    &#125;   </span><br><span class="line">    cout&lt;&lt;endl;  </span><br><span class="line">    /***************************/  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>插值查找比二分查找有所改进，但是其效率提高的并不明显(除非所查找的数列特别庞大，它的用处才能显现)。算法中引用了乘法和除法，增加了额外的消耗。如果所需查找的数列不大，由于每次深入都要进行乘除操作，用此算法可能得不偿失。所以，在实际应用中，该算法常常与二分查找算法联合使用，来处理较大的数据：用插值查找将数据缩小到一定范围，再用二分查找完成查询。时间复杂性：如果元素均匀分布，则O（log log n）），在最坏的情况下可能需要O（n）。<br>辅助空间：O（1）</p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>八皇后问题</title>
      <link href="/2018/06/28/Eight_queens/"/>
      <url>/2018/06/28/Eight_queens/</url>
      <content type="html"><![CDATA[<p>八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。 高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果。计算机发明后，有多种计算机语言可以解决此问题。</p><p>八皇后问题可以推广为更一般的n皇后摆放问题：这时棋盘的大小变为n×n，而皇后个数也变成n。而且仅当 n = 1 或 n ≥ 4 时问题有解。</p><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/doc/Eight%20queens/pic/E-Q-1.png" alt="image"><br><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/doc/Eight%20queens/pic/E-Q-2.PNG" alt="image"><br><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/doc/Eight%20queens/pic/E-Q-3.PNG" alt="image"></p><h1 id="历史发展"><a href="#历史发展" class="headerlink" title="历史发展"></a>历史发展</h1><ul><li>1848年，国际象棋作曲家马克斯·贝泽尔发表了八个皇后拼图。</li><li>弗朗茨·瑙克在1850年发表了第一个解决方案。瑙克还将这个拼图延伸到n皇后问题，其中n个皇后位于n×n个方格的棋盘上。此后，包括卡尔弗里德里希高斯在内的许多数学家都参与了八个皇后拼图和其广义的n-queens版本。</li><li>1874年，S.冈瑟提出了一种使用决定因素来寻找解决方案的方法。 JWL Glaisher改进了Gunther的方法。</li><li>1972年，Edsger Dijkstra用这个问题来说明他称之为结构化编程的力量。他发表了深度优先 回溯算法的高度详细的描述。</li></ul><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这是典型的回溯算法.从根结点开始,依次遍历所有的结点,若有一个节点错误，则说明该路径走不通，返回上一节点，以此类推，直到遍历所有节点。</p><p>针对这一类的回溯问题，有以下步骤：</p><ul><li>定义一个解空间，该解空间至少包含一个问题的解；</li><li>组织解空间；</li><li>按深度优先的遍历方法进行节点搜索，在搜索执行的同时产生解空间。</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ol><li>要将n个皇后放到n×n的棋盘中，则每一列必须且只能放一个皇后。所以问题转化为确定皇后在每一列中的位置（在第几行上）。</li><li>从第一列开始，依次考察每一列。</li><li>在考察每一列的时候，总是从第一行开始，尝试将皇后放入，如果可以放入，就接着考察下一列的第一行。如果不可以放入，就接着考察这一列的下一行，直到成功，然后接着考察下一列的第一行。</li><li>如果这一列的每一行都不可以放入，说明这一列前面各列的皇后放置有问题，导致这一列无法放入，需要回溯。</li><li>回溯的时候，如果前面的一列每一行都已经被尝试过了，就需要接着往前回溯，直到找到还有行未被尝试过的列，然后尝试这一列的下一行。</li><li>在回溯过程中经过的每一列都需要将已经放入的皇后取出来，以备后面重新选择位置放入。</li><li>如果每一列都被考察完毕，即每一列中的皇后都找到了合适的位置，则找到一个解。</li><li>在找到一个解后，如果还要寻找其它解，则需要回溯，尝试其它情况。</li><li>当回溯到第0列时，说明1~n列的所有行都已经被尝试过了，没有其它情况可以尝试，结束程序。</li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">c语言:</span><br><span class="line">    #include &lt;stdio.h&gt;  </span><br><span class="line">    #include &lt;stdlib.h&gt;  </span><br><span class="line"></span><br><span class="line">    #define max 8  </span><br><span class="line"></span><br><span class="line">    int queen[max], sum=0; /* max为棋盘最大坐标 */  </span><br><span class="line"></span><br><span class="line">    void show() /* 输出所有皇后的坐标 */  </span><br><span class="line">    &#123;  </span><br><span class="line">        int i;  </span><br><span class="line">        for(i = 0; i &lt; max; i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">             printf(&quot;(%d,%d) &quot;, i, queen[i]);  </span><br><span class="line">        &#125;  </span><br><span class="line">        printf(&quot;\n&quot;);  </span><br><span class="line">        sum++;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    int check(int n) /* 检查当前列能否放置皇后 */  </span><br><span class="line">    &#123;  </span><br><span class="line">        int i;  </span><br><span class="line">        for(i = 0; i &lt; n; i++) /* 检查横排和对角线上是否可以放置皇后 */  </span><br><span class="line">        &#123;  </span><br><span class="line">            if(queen[i] == queen[n] || abs(queen[i] - queen[n]) == (n - i))  </span><br><span class="line">            &#123;  </span><br><span class="line">                return 1;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return 0;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    void put(int n) /* 回溯尝试皇后位置,n为横坐标 */  </span><br><span class="line">    &#123;  </span><br><span class="line">        int i;  </span><br><span class="line">        for(i = 0; i &lt; max; i++)  </span><br><span class="line">        &#123;         </span><br><span class="line">            queen[n] = i; /* 将皇后摆到当前循环到的位置 */  </span><br><span class="line">            if(!check(n))  </span><br><span class="line">            &#123;             </span><br><span class="line">                if(n == max - 1)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    show(); /* 如果全部摆好，则输出所有皇后的坐标 */  </span><br><span class="line">                &#125;           </span><br><span class="line">                else  </span><br><span class="line">                &#123;  </span><br><span class="line">                    put(n + 1); /* 否则继续摆放下一个皇后 */  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    int main()  </span><br><span class="line">    &#123;  </span><br><span class="line">        put(0); /* 从横坐标为0开始依次尝试 */  </span><br><span class="line">        printf(&quot;%d&quot;, sum);  </span><br><span class="line">        return 0;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>八皇后问题历来被研究已久，本文档只介绍了用回溯思想解体的方法，网上还有更多的研究资料和优化算法，感兴趣的同学可以深入学习。</p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 应用 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LZW压缩算法</title>
      <link href="/2018/06/27/LZW_Flow_Chart/"/>
      <url>/2018/06/27/LZW_Flow_Chart/</url>
      <content type="html"><![CDATA[<p>LZW压缩算法是一种压缩方法，由Lemple-Ziv-Welch 三人共同创造，用他们的名字命名。</p><h1 id="算法概念"><a href="#算法概念" class="headerlink" title="算法概念"></a>算法概念</h1><ul><li>LZW逐个地输入源数据，使用贪婪分析算法来形成词典的每一个条目。</li><li>每一次都力图从输入串中分解出已经识别的最长的字串，即把已在词典中出现的最长字串作为前缀Prefix，然后加上下一个输入字符C，组成新的扩展字符串Prefix.C。</li><li>这个新的字符串是否要加到词典中，要看词典中是否存有和它相同的字符串。如有，那么这个字符串就变成新的前缀，继续输入新的字符，否则就把这个字符串加到词典中生成一个新的词条，并给它分配一个代码。<h1 id="LZW算法编码流程"><a href="#LZW算法编码流程" class="headerlink" title="LZW算法编码流程"></a>LZW算法编码流程</h1>1)初始化：将所有的单字符串放入词典<br>2)读第一个输入字符给前缀串P<br>3)Step: 读下一个输入字符C;<br>　　　if  没有这样的C(输入已穷尽)：<br>　　　 　 码字(P) 输出；结束。<br>　　　if  P+C 已存在于词典中：<br>　　　　P:=P+C；repeat Step；<br>　　　else P+C不在于词典中:<br>　　　　　P+C加进词典；<br>　　　　　码字(P) 输出；<br>　　　      P:=C；repeat Step.<br>##流程图<br><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/yuanJiaLi/pic/LZW_Flow_Chart.png" alt=""></li></ul><h1 id="LZW算法译码流程"><a href="#LZW算法译码流程" class="headerlink" title="LZW算法译码流程"></a>LZW算法译码流程</h1><p>1）初始化词典<br>2）初始化P=空<br>3）CW=读入码字<br>4）CW是否在词典中<br>      是：P+CW对应的串中的第一个字符(C1)放入词典（注：如果已经在串表中了就无需放入）<br>      否：P+P中的第一个字符(P1)放入词典<br>5）：P:=CW对应的串<br>6）：输出CW对应的串<br>7）：是否还有下一个码字，如果有跳转到步骤3，否则结束</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/yuanJiaLi/pic/LZW_Flow_Chart_Decoding.png" alt=""></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line"> </span><br><span class="line">/* -------- aux stuff ---------- */</span><br><span class="line">void* mem_alloc(size_t item_size, size_t n_item)</span><br><span class="line">&#123;</span><br><span class="line">  size_t *x = calloc(1, sizeof(size_t)*2 + n_item * item_size);</span><br><span class="line">  x[0] = item_size;</span><br><span class="line">  x[1] = n_item;</span><br><span class="line">  return x + 2;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void* mem_extend(void *m, size_t new_n)</span><br><span class="line">&#123;</span><br><span class="line">  size_t *x = (size_t*)m - 2;</span><br><span class="line">  x = realloc(x, sizeof(size_t) * 2 + *x * new_n);</span><br><span class="line">  if (new_n &gt; x[1])</span><br><span class="line">    memset((char*)(x + 2) + x[0] * x[1], 0, x[0] * (new_n - x[1]));</span><br><span class="line">  x[1] = new_n;</span><br><span class="line">  return x + 2;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">inline void _clear(void *m)</span><br><span class="line">&#123;</span><br><span class="line">  size_t *x = (size_t*)m - 2;</span><br><span class="line">  memset(m, 0, x[0] * x[1]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#define _new(type, n) mem_alloc(sizeof(type), n)</span><br><span class="line">#define _del(m)   &#123; free((size_t*)(m) - 2); m = 0; &#125;</span><br><span class="line">#define _len(m)   *((size_t*)m - 1)</span><br><span class="line">#define _setsize(m, n)  m = mem_extend(m, n)</span><br><span class="line">#define _extend(m)  m = mem_extend(m, _len(m) * 2)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/* ----------- LZW stuff -------------- */</span><br><span class="line">typedef uint8_t byte;</span><br><span class="line">typedef uint16_t ushort;</span><br><span class="line"> </span><br><span class="line">#define M_CLR 256 /* clear table marker */</span><br><span class="line">#define M_EOD 257 /* end-of-data marker */</span><br><span class="line">#define M_NEW 258 /* new code index */</span><br><span class="line"> </span><br><span class="line">/* encode and decode dictionary structures.</span><br><span class="line">   for encoding, entry at code index is a list of indices that follow current one,</span><br><span class="line">   i.e. if code 97 is &apos;a&apos;, code 387 is &apos;ab&apos;, and code 1022 is &apos;abc&apos;,</span><br><span class="line">   then dict[97].next[&apos;b&apos;] = 387, dict[387].next[&apos;c&apos;] = 1022, etc. */</span><br><span class="line">typedef struct &#123;</span><br><span class="line">  ushort next[256];</span><br><span class="line">&#125; lzw_enc_t;</span><br><span class="line"> </span><br><span class="line">/* for decoding, dictionary contains index of whatever prefix index plus trailing</span><br><span class="line">   byte.  i.e. like previous example,</span><br><span class="line">    dict[1022] = &#123; c: &apos;c&apos;, prev: 387 &#125;,</span><br><span class="line">    dict[387]  = &#123; c: &apos;b&apos;, prev: 97 &#125;,</span><br><span class="line">    dict[97]   = &#123; c: &apos;a&apos;, prev: 0 &#125;</span><br><span class="line">   the &quot;back&quot; element is used for temporarily chaining indices when resolving</span><br><span class="line">   a code to bytes</span><br><span class="line"> */</span><br><span class="line">typedef struct &#123;</span><br><span class="line">  ushort prev, back;</span><br><span class="line">  byte c;</span><br><span class="line">&#125; lzw_dec_t;</span><br><span class="line"> </span><br><span class="line">byte* lzw_encode(byte *in, int max_bits)</span><br><span class="line">&#123;</span><br><span class="line">  int len = _len(in), bits = 9, next_shift = 512;</span><br><span class="line">  ushort code, c, nc, next_code = M_NEW;</span><br><span class="line">  lzw_enc_t *d = _new(lzw_enc_t, 512);</span><br><span class="line"> </span><br><span class="line">  if (max_bits &gt; 15) max_bits = 15;</span><br><span class="line">  if (max_bits &lt; 9 ) max_bits = 12;</span><br><span class="line"> </span><br><span class="line">  byte *out = _new(ushort, 4);</span><br><span class="line">  int out_len = 0, o_bits = 0;</span><br><span class="line">  uint32_t tmp = 0;</span><br><span class="line"> </span><br><span class="line">  inline void write_bits(ushort x) &#123;</span><br><span class="line">    tmp = (tmp &lt;&lt; bits) | x;</span><br><span class="line">    o_bits += bits;</span><br><span class="line">    if (_len(out) &lt;= out_len) _extend(out);</span><br><span class="line">    while (o_bits &gt;= 8) &#123;</span><br><span class="line">      o_bits -= 8;</span><br><span class="line">      out[out_len++] = tmp &gt;&gt; o_bits;</span><br><span class="line">      tmp &amp;= (1 &lt;&lt; o_bits) - 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  //write_bits(M_CLR);</span><br><span class="line">  for (code = *(in++); --len; ) &#123;</span><br><span class="line">    c = *(in++);</span><br><span class="line">    if ((nc = d[code].next[c]))</span><br><span class="line">      code = nc;</span><br><span class="line">    else &#123;</span><br><span class="line">      write_bits(code);</span><br><span class="line">      nc = d[code].next[c] = next_code++;</span><br><span class="line">      code = c;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /* next new code would be too long for current table */</span><br><span class="line">    if (next_code == next_shift) &#123;</span><br><span class="line">      /* either reset table back to 9 bits */</span><br><span class="line">      if (++bits &gt; max_bits) &#123;</span><br><span class="line">        /* table clear marker must occur before bit reset */</span><br><span class="line">        write_bits(M_CLR);</span><br><span class="line"> </span><br><span class="line">        bits = 9;</span><br><span class="line">        next_shift = 512;</span><br><span class="line">        next_code = M_NEW;</span><br><span class="line">        _clear(d);</span><br><span class="line">      &#125; else  /* or extend table */</span><br><span class="line">        _setsize(d, next_shift *= 2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  write_bits(code);</span><br><span class="line">  write_bits(M_EOD);</span><br><span class="line">  if (tmp) write_bits(tmp);</span><br><span class="line"> </span><br><span class="line">  _del(d);</span><br><span class="line"> </span><br><span class="line">  _setsize(out, out_len);</span><br><span class="line">  return out;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">byte* lzw_decode(byte *in)</span><br><span class="line">&#123;</span><br><span class="line">  byte *out = _new(byte, 4);</span><br><span class="line">  int out_len = 0;</span><br><span class="line"> </span><br><span class="line">  inline void write_out(byte c)</span><br><span class="line">  &#123;</span><br><span class="line">    while (out_len &gt;= _len(out)) _extend(out);</span><br><span class="line">    out[out_len++] = c;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  lzw_dec_t *d = _new(lzw_dec_t, 512);</span><br><span class="line">  int len, j, next_shift = 512, bits = 9, n_bits = 0;</span><br><span class="line">  ushort code, c, t, next_code = M_NEW;</span><br><span class="line"> </span><br><span class="line">  uint32_t tmp = 0;</span><br><span class="line">  inline void get_code() &#123;</span><br><span class="line">    while(n_bits &lt; bits) &#123;</span><br><span class="line">      if (len &gt; 0) &#123;</span><br><span class="line">        len --;</span><br><span class="line">        tmp = (tmp &lt;&lt; 8) | *(in++);</span><br><span class="line">        n_bits += 8;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        tmp = tmp &lt;&lt; (bits - n_bits);</span><br><span class="line">        n_bits = bits;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n_bits -= bits;</span><br><span class="line">    code = tmp &gt;&gt; n_bits;</span><br><span class="line">    tmp &amp;= (1 &lt;&lt; n_bits) - 1;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  inline void clear_table() &#123;</span><br><span class="line">    _clear(d);</span><br><span class="line">    for (j = 0; j &lt; 256; j++) d[j].c = j;</span><br><span class="line">    next_code = M_NEW;</span><br><span class="line">    next_shift = 512;</span><br><span class="line">    bits = 9;</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  clear_table(); /* in case encoded bits didn&apos;t start with M_CLR */</span><br><span class="line">  for (len = _len(in); len;) &#123;</span><br><span class="line">    get_code();</span><br><span class="line">    if (code == M_EOD) break;</span><br><span class="line">    if (code == M_CLR) &#123;</span><br><span class="line">      clear_table();</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (code &gt;= next_code) &#123;</span><br><span class="line">      fprintf(stderr, &quot;Bad sequence\n&quot;);</span><br><span class="line">      _del(out);</span><br><span class="line">      goto bail;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    d[next_code].prev = c = code;</span><br><span class="line">    while (c &gt; 255) &#123;</span><br><span class="line">      t = d[c].prev; d[t].back = c; c = t;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    d[next_code - 1].c = c;</span><br><span class="line"> </span><br><span class="line">    while (d[c].back) &#123;</span><br><span class="line">      write_out(d[c].c);</span><br><span class="line">      t = d[c].back; d[c].back = 0; c = t;</span><br><span class="line">    &#125;</span><br><span class="line">    write_out(d[c].c);</span><br><span class="line"> </span><br><span class="line">    if (++next_code &gt;= next_shift) &#123;</span><br><span class="line">      if (++bits &gt; 16) &#123;</span><br><span class="line">        /* if input was correct, we&apos;d have hit M_CLR before this */</span><br><span class="line">        fprintf(stderr, &quot;Too many bits\n&quot;);</span><br><span class="line">        _del(out);</span><br><span class="line">        goto bail;</span><br><span class="line">      &#125;</span><br><span class="line">      _setsize(d, next_shift *= 2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  /* might be ok, so just whine, don&apos;t be drastic */</span><br><span class="line">  if (code != M_EOD) fputs(&quot;Bits did not end in EOD\n&quot;, stderr);</span><br><span class="line"> </span><br><span class="line">  _setsize(out, out_len);</span><br><span class="line">bail: _del(d);</span><br><span class="line">  return out;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int i, fd = open(&quot;unixdict.txt&quot;, O_RDONLY);</span><br><span class="line"> </span><br><span class="line">  if (fd == -1) &#123;</span><br><span class="line">    fprintf(stderr, &quot;Can&apos;t read file\n&quot;);</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  struct stat st;</span><br><span class="line">  fstat(fd, &amp;st);</span><br><span class="line"> </span><br><span class="line">  byte *in = _new(char, st.st_size);</span><br><span class="line">  read(fd, in, st.st_size);</span><br><span class="line">  _setsize(in, st.st_size);</span><br><span class="line">  close(fd);</span><br><span class="line"> </span><br><span class="line">  printf(&quot;input size:   %d\n&quot;, _len(in));</span><br><span class="line"> </span><br><span class="line">  byte *enc = lzw_encode(in, 9);</span><br><span class="line">  printf(&quot;encoded size: %d\n&quot;, _len(enc));</span><br><span class="line"> </span><br><span class="line">  byte *dec = lzw_decode(enc);</span><br><span class="line">  printf(&quot;decoded size: %d\n&quot;, _len(dec));</span><br><span class="line"> </span><br><span class="line">  for (i = 0; i &lt; _len(dec); i++)</span><br><span class="line">    if (dec[i] != in[i]) &#123;</span><br><span class="line">      printf(&quot;bad decode at %d\n&quot;, i);</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  if (i == _len(dec)) printf(&quot;Decoded ok\n&quot;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  _del(in);</span><br><span class="line">  _del(enc);</span><br><span class="line">  _del(dec);</span><br><span class="line"> </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line"> </span><br><span class="line">// Compress a string to a list of output symbols.</span><br><span class="line">// The result will be written to the output iterator</span><br><span class="line">// starting at &quot;result&quot;; the final iterator is returned.</span><br><span class="line">template &lt;typename Iterator&gt;</span><br><span class="line">Iterator compress(const std::string &amp;uncompressed, Iterator result) &#123;</span><br><span class="line">  // Build the dictionary.</span><br><span class="line">  int dictSize = 256;</span><br><span class="line">  std::map&lt;std::string,int&gt; dictionary;</span><br><span class="line">  for (int i = 0; i &lt; 256; i++)</span><br><span class="line">    dictionary[std::string(1, i)] = i;</span><br><span class="line"> </span><br><span class="line">  std::string w;</span><br><span class="line">  for (std::string::const_iterator it = uncompressed.begin();</span><br><span class="line">       it != uncompressed.end(); ++it) &#123;</span><br><span class="line">    char c = *it;</span><br><span class="line">    std::string wc = w + c;</span><br><span class="line">    if (dictionary.count(wc))</span><br><span class="line">      w = wc;</span><br><span class="line">    else &#123;</span><br><span class="line">      *result++ = dictionary[w];</span><br><span class="line">      // Add wc to the dictionary.</span><br><span class="line">      dictionary[wc] = dictSize++;</span><br><span class="line">      w = std::string(1, c);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  // Output the code for w.</span><br><span class="line">  if (!w.empty())</span><br><span class="line">    *result++ = dictionary[w];</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// Decompress a list of output ks to a string.</span><br><span class="line">// &quot;begin&quot; and &quot;end&quot; must form a valid range of ints</span><br><span class="line">template &lt;typename Iterator&gt;</span><br><span class="line">std::string decompress(Iterator begin, Iterator end) &#123;</span><br><span class="line">  // Build the dictionary.</span><br><span class="line">  int dictSize = 256;</span><br><span class="line">  std::map&lt;int,std::string&gt; dictionary;</span><br><span class="line">  for (int i = 0; i &lt; 256; i++)</span><br><span class="line">    dictionary[i] = std::string(1, i);</span><br><span class="line"> </span><br><span class="line">  std::string w(1, *begin++);</span><br><span class="line">  std::string result = w;</span><br><span class="line">  std::string entry;</span><br><span class="line">  for ( ; begin != end; begin++) &#123;</span><br><span class="line">    int k = *begin;</span><br><span class="line">    if (dictionary.count(k))</span><br><span class="line">      entry = dictionary[k];</span><br><span class="line">    else if (k == dictSize)</span><br><span class="line">      entry = w + w[0];</span><br><span class="line">    else</span><br><span class="line">      throw &quot;Bad compressed k&quot;;</span><br><span class="line"> </span><br><span class="line">    result += entry;</span><br><span class="line"> </span><br><span class="line">    // Add w+entry[0] to the dictionary.</span><br><span class="line">    dictionary[dictSize++] = w + entry[0];</span><br><span class="line"> </span><br><span class="line">    w = entry;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">  std::vector&lt;int&gt; compressed;</span><br><span class="line">  compress(&quot;TOBEORNOTTOBEORTOBEORNOT&quot;, std::back_inserter(compressed));</span><br><span class="line">  copy(compressed.begin(), compressed.end(), std::ostream_iterator&lt;int&gt;(std::cout, &quot;, &quot;));</span><br><span class="line">  std::cout &lt;&lt; std::endl;</span><br><span class="line">  std::string decompressed = decompress(compressed.begin(), compressed.end());</span><br><span class="line">  std::cout &lt;&lt; decompressed &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"> </span><br><span class="line">public class LZW &#123;</span><br><span class="line">    /** Compress a string to a list of output symbols. */</span><br><span class="line">    public static List&lt;Integer&gt; compress(String uncompressed) &#123;</span><br><span class="line">        // Build the dictionary.</span><br><span class="line">        int dictSize = 256;</span><br><span class="line">        Map&lt;String,Integer&gt; dictionary = new HashMap&lt;String,Integer&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 256; i++)</span><br><span class="line">            dictionary.put(&quot;&quot; + (char)i, i);</span><br><span class="line"> </span><br><span class="line">        String w = &quot;&quot;;</span><br><span class="line">        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        for (char c : uncompressed.toCharArray()) &#123;</span><br><span class="line">            String wc = w + c;</span><br><span class="line">            if (dictionary.containsKey(wc))</span><br><span class="line">                w = wc;</span><br><span class="line">            else &#123;</span><br><span class="line">                result.add(dictionary.get(w));</span><br><span class="line">                // Add wc to the dictionary.</span><br><span class="line">                dictionary.put(wc, dictSize++);</span><br><span class="line">                w = &quot;&quot; + c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        // Output the code for w.</span><br><span class="line">        if (!w.equals(&quot;&quot;))</span><br><span class="line">            result.add(dictionary.get(w));</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /** Decompress a list of output ks to a string. */</span><br><span class="line">    public static String decompress(List&lt;Integer&gt; compressed) &#123;</span><br><span class="line">        // Build the dictionary.</span><br><span class="line">        int dictSize = 256;</span><br><span class="line">        Map&lt;Integer,String&gt; dictionary = new HashMap&lt;Integer,String&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 256; i++)</span><br><span class="line">            dictionary.put(i, &quot;&quot; + (char)i);</span><br><span class="line"> </span><br><span class="line">        String w = &quot;&quot; + (char)(int)compressed.remove(0);</span><br><span class="line">        StringBuffer result = new StringBuffer(w);</span><br><span class="line">        for (int k : compressed) &#123;</span><br><span class="line">            String entry;</span><br><span class="line">            if (dictionary.containsKey(k))</span><br><span class="line">                entry = dictionary.get(k);</span><br><span class="line">            else if (k == dictSize)</span><br><span class="line">                entry = w + w.charAt(0);</span><br><span class="line">            else</span><br><span class="line">                throw new IllegalArgumentException(&quot;Bad compressed k: &quot; + k);</span><br><span class="line"> </span><br><span class="line">            result.append(entry);</span><br><span class="line"> </span><br><span class="line">            // Add w+entry[0] to the dictionary.</span><br><span class="line">            dictionary.put(dictSize++, w + entry.charAt(0));</span><br><span class="line"> </span><br><span class="line">            w = entry;</span><br><span class="line">        &#125;</span><br><span class="line">        return result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Integer&gt; compressed = compress(&quot;TOBEORNOTTOBEORTOBEORNOT&quot;);</span><br><span class="line">        System.out.println(compressed);</span><br><span class="line">        String decompressed = decompress(compressed);</span><br><span class="line">        System.out.println(decompressed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>[84, 79, 66, 69, 79, 82, 78, 79, 84, 256, 258, 260, 265, 259, 261, 263]<br>TOBEORNOTTOBEORTOBEORNOT</p></blockquote><hr><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h5><ol><li>多媒体技术基础（第三版）</li></ol>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 压缩 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>哈希方法</title>
      <link href="/2018/06/26/Conflict_Resolution/"/>
      <url>/2018/06/26/Conflict_Resolution/</url>
      <content type="html"><![CDATA[<h1 id="链接法（开散列方法）"><a href="#链接法（开散列方法）" class="headerlink" title="链接法（开散列方法）"></a>链接法（开散列方法）</h1><p>拉链法解决冲突的做法是：将所有关键字为同义词的结点链接在同一个单链表中。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于 1，但一般均取α≤1。</p><h1 id="开放寻址法（闭散列方法）"><a href="#开放寻址法（闭散列方法）" class="headerlink" title="开放寻址法（闭散列方法）"></a>开放寻址法（闭散列方法）</h1><p>用开放定址法解决冲突的做法是：当冲突发生时，使用某种探测技术在散列表中形成一个探测序列。沿此序列逐个单元地查找，直到找到给定的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。查找时探查到开放的 地址则表明表中无待查的关键字，即查找失败。</p><p><code>注意：</code></p><p>①用开放定址法建立散列表时，建表前须将表中所有单元(更严格地说，是指单元中存储的关键字)置空。</p><p>②空单元的表示与具体的应用相关。</p><p>按照形成探查序列的方法不同，可将开放定址法区分为线性探查法、线性补偿探测法、随机探测等。</p><h2 id="线性探查法-Linear-Probing"><a href="#线性探查法-Linear-Probing" class="headerlink" title="线性探查法(Linear Probing)"></a>线性探查法(Linear Probing)</h2><p>该方法的基本思想是:<br>:<br>将散列表T[0..m-1]看成是一个循环向量，若初始探查的地址为d(即h(key)=d)，则最长的探查序列为：</p><blockquote><p>d，d+l，d+2，…，m-1，0，1，…，d-1</p></blockquote><p> 即:探查时从地址d开始，首先探查T[d]，然后依次探查T[d+1]，…，直到T[m-1]，此后又循环到T[0]，T[1]，…，直到探查到T[d-1]为止。</p><p> 探查过程终止于三种情况：<br>　(1)若当前探查的单元为空，则表示查找失败（若是插入则将key写入其中）；<br>　(2)若当前探查的单元中含有key，则查找成功，但对于插入意味着失败；<br>　(3)若探查到T[d-1]时仍未发现空单元也未找到key，则无论是查找还是插入均意味着失败(此时表满)。<br>　<br>利用开放地址法的一般形式，线性探查法的探查序列为：</p><blockquote><p>hi=(h(key)+i)％m 0≤i≤m-1 //即di=i</p></blockquote><p> 用线性探测法处理冲突，思路清晰，算法简单，但存在下列缺点：<br>① 处理溢出需另编程序。一般可另外设立一个溢出表，专门用来存放上述哈希表中放不下的记录。此溢出表最简单的结构是顺序表，查找方法可用顺序查找。<br>② 按上述算法建立起来的哈希表，删除工作非常困难。假如要从哈希表 HT 中删除一个记录，按理应将这个记录所在位置置为空，但我们不能这样做，而只能标上已被删除的标记，否则，将会影响以后的查找。<br>③ 线性探测法很容易产生堆聚现象。所谓堆聚现象，就是存入哈希表的记录在表中连成一片。按照线性探测法处理冲突，如果生成哈希地址的连续序列愈长 ( 即不同关键字值的哈希地址相邻在一起愈长 ) ，则当新的记录加入该表时，与这个序列发生冲突的可能性愈大。因此，哈希地址的较长连续序列比较短连续序列生长得快，这就意味着，一旦出现堆聚 ( 伴随着冲突 ) ，就将引起进一步的堆聚。</p><h2 id="线性补偿探测法"><a href="#线性补偿探测法" class="headerlink" title="线性补偿探测法"></a>线性补偿探测法</h2><p>线性补偿探测法的基本思想是：<br>:<br>将线性探测的步长从 1 改为 Q ，即将上述算法中的 j ＝ (j ＋ 1) % m 改为： j ＝ (j ＋ Q) % m ，而且要求 Q 与 m 是互质的，以便能探测到哈希表中的所有单元。</p><p><code>例</code> PDP-11 小型计算机中的汇编程序所用的符合表，就采用此方法来解决冲突，所用表长 m ＝ 1321 ，选用 Q ＝ 25 。</p><h2 id="随机探测"><a href="#随机探测" class="headerlink" title="随机探测"></a>随机探测</h2><p>随机探测的基本思想是：<br>:<br>将线性探测的步长从常数改为随机数，即令： j ＝ (j ＋ RN) % m ，其中 RN 是一个随机数。在实际程序中应预先用随机数发生器产生一个随机序列，将此序列作为依次探测的步长。这样就能使不同的关键字具有不同的探测次序，从而可以避 免或减少堆聚。基于与线性探测法相同的理由，在线性补偿探测法和随机探测法中，删除一个记录后也要打上删除标记。</p><h1 id="再散列法"><a href="#再散列法" class="headerlink" title="再散列法"></a>再散列法</h1><p>这种方法是同时构造多个不同的哈希函数：</p><blockquote><p>Hi=RH1（key）  i=1，2，…，k</p></blockquote><p>当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。</p><h1 id="建立公共溢出区"><a href="#建立公共溢出区" class="headerlink" title="建立公共溢出区"></a>建立公共溢出区</h1><p>这种方法的基本思想是：<br>: 将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>哈希方法</title>
      <link href="/2018/06/25/Construction_Method/"/>
      <url>/2018/06/25/Construction_Method/</url>
      <content type="html"><![CDATA[<h1 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h1><p>直接定址法是以数据元素关键字k本身或它的线性函数作为它的哈希地址，即：H（k）=k或 H（k）=a×k+b ； (其中a,b为常数)<br><code>例</code> 有一个人口统计表，记录了从1岁到100岁的人口数目，其中年龄作为关键字，哈希函数取关键字本身，如图：</p><table><thead><tr><th style="text-align:center">地址</th><th style="text-align:center">年龄</th><th style="text-align:center">人数</th></tr></thead><tbody><tr><td style="text-align:center">A1</td><td style="text-align:center">1</td><td style="text-align:center">980</td></tr><tr><td style="text-align:center">A2</td><td style="text-align:center">2</td><td style="text-align:center">800</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr><tr><td style="text-align:center">A99</td><td style="text-align:center">99</td><td style="text-align:center">495</td></tr><tr><td style="text-align:center">A100</td><td style="text-align:center">100</td><td style="text-align:center">107</td></tr></tbody></table><p>可以看到，当需要查找某一年龄的人数时，直接查找相应的项即可。如查找99岁的老人数，则直接读出第99项即可。</p><table><thead><tr><th style="text-align:center">地址</th><th style="text-align:center">年龄</th><th style="text-align:center">人数</th></tr></thead><tbody><tr><td style="text-align:center">A0</td><td style="text-align:center">1980</td><td style="text-align:center">980</td></tr><tr><td style="text-align:center">A1</td><td style="text-align:center">1981</td><td style="text-align:center">800</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr><tr><td style="text-align:center">A99</td><td style="text-align:center">1999</td><td style="text-align:center">495</td></tr><tr><td style="text-align:center">A100</td><td style="text-align:center">2000</td><td style="text-align:center">107</td></tr></tbody></table><p>如果我们要统计的是80后出生的人口数，如上表所示，那么我们队出生年份这个关键字可以用年份减去1980来作为地址，此时f(key)=key-1980</p><p>这种哈希函数简单，并且对于不同的关键字不会产生冲突，但可以看出这是一种较为特殊的哈希函数，实际生活中，关键字的元素很少是连续的。用该方法产生的哈希表会造成空间大量的浪费，因此这种方法适应性并不强。</p><p><code>适用</code>：地址集合的大小与关键字集合的大小相同情况下，其中a和b为常数。</p><h1 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h1><p>假设关键字集合中的每个关键字都是由 s 位数字组成 (u1, u2, …, us)，分析关键字集中的全体，并从中提取分布均匀的若干位或它们的组合作为地址。</p><p>数字分析法是取数据元素关键字中某些取值较均匀的数字位作为哈希地址的方法。即当关键字的位数很多时，可以通过对关键字的各位进行分析，丢掉分布不均匀的位，作为哈希值。它只适合于所有关键字值已知的情况。通过分析分布情况把关键字取值区间转化为一个较小的关键字取值区间。</p><p><code>例</code> 要构造一个数据元素个数n=80,哈希长度m=100的哈希表。不失一般性，我们这里只给出其中8个关键字进行分析，8个关键字如下所示：</p><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/yuanJiaLi/pic/Hash/Hash_Method2.png" alt=""><br>分析上述8个关键字可知，关键字从左到右的第1、2、3、6位取值比较集中，不宜作为哈希地址，剩余的第4、5、7、8位取值较均匀，可选取其中的两位作为哈希地址。设选取最后两位作为哈希地址，则这8个关键字的哈希地址分别为：2，75，28，34，15，38，62，20。</p><p><code>适用</code>：能预先估计出全体关键字的每一位上各种数字出现的频度。</p><h1 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h1><p>将关键字分割成若干部分，然后取它们的叠加和为哈希地址。两种叠加处理的方法：<br><strong>移位叠加</strong>：将分 割后的几部分低位对齐相加；<br><strong>边界叠加</strong>：从一端沿分割界来回折叠，然后对齐相加。</p><p>所谓<strong>折叠法</strong>是将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位），这方法称为折叠法。这种方法适用于关键字位数较多，而且关键字中每一位上数字分布大致均匀的情况。<br>  折叠法中数位折叠又分为移位叠加和边界叠加两种方法，移位叠加是将分割后是每一部分的最低位对齐，然后相加；边界叠加是从一端向另一端沿分割界来回折叠，然后对齐相加。</p><p><code>例</code> 当哈希表长为1000时，关键字key=110108331119891，允许的地址空间为三位十进制数，则这两种叠加情况如图：<br><strong>由折叠法求哈希地址</strong>：</p><table><thead><tr><th style="text-align:right">移位叠加</th><th style="text-align:center"></th><th style="text-align:right">边界叠加</th></tr></thead><tbody><tr><td style="text-align:right">8 9 1</td><td style="text-align:center"></td><td style="text-align:right">8 9 1</td></tr><tr><td style="text-align:right">1 1 9</td><td style="text-align:center"></td><td style="text-align:right">1 1 9</td></tr><tr><td style="text-align:right">3 3 1</td><td style="text-align:center"></td><td style="text-align:right">3 3 1</td></tr><tr><td style="text-align:right">1 0 8</td><td style="text-align:center"></td><td style="text-align:right">1 0 8</td></tr><tr><td style="text-align:right">+1 1 0</td><td style="text-align:center"></td><td style="text-align:right">+1 1 0</td></tr><tr><td style="text-align:right">(1) 5 5 9</td><td style="text-align:center"></td><td style="text-align:right">(3) 0 4 4</td></tr></tbody></table><p>用移位叠加得到的哈希地址是559，而用边界叠加所得到的哈希地址是44。如果关键字不是数值而是字符串，则可先转化为数。转化的办法可以用ASCⅡ字符或字符的次序值。</p><p><code>适用</code>：关键字的数字位数特别多。</p><h1 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h1><p><strong>平方取中法</strong>是一种常用的哈希函数构造方法。这个方法是先取关键字的平方，然后根据可使用空间的大小，选取平方数是中间几位为哈希地址。</p><p>哈希函数 H(key)=“key2的中间几位”因为这种方法的原理是通过取平方扩大差别，平方值的中间几位和这个数的每一位都相关，则对不同的关键字得到的哈希函数值不易产生冲突，由此产生的哈希地址也较为均匀。<br><code>例</code> 若设哈希表长为1000则可取关键字平方值的中间三位，如图所示：</p><table><thead><tr><th style="text-align:center">关键字</th><th style="text-align:center">关键字的平方</th><th style="text-align:center">哈希函数值</th></tr></thead><tbody><tr><td style="text-align:center">1234</td><td style="text-align:center">1522756</td><td style="text-align:center">227</td></tr><tr><td style="text-align:center">2143</td><td style="text-align:center">4592449</td><td style="text-align:center">924</td></tr><tr><td style="text-align:center">4132</td><td style="text-align:center">17073424</td><td style="text-align:center">734</td></tr><tr><td style="text-align:center">3214</td><td style="text-align:center">10329796</td><td style="text-align:center">297</td></tr></tbody></table><p>下面给出平方取中法的哈希函数<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//平方取中法哈希函数，结设关键字值32位的整数</span><br><span class="line">//哈希函数将返回key * key的中间10位</span><br><span class="line">Int  Hash (int key)&#123;</span><br><span class="line">    //计算key的平方</span><br><span class="line">    Key * = key ;</span><br><span class="line">    //去掉低11位</span><br><span class="line">    Key&gt;&gt;=11;</span><br><span class="line">    // 返回低10位（即key * key的中间10位）</span><br><span class="line">    Return key %1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>适用</code>：关键字中的每一位都有某些数字重复出现频度很高的现象。</p><h1 id="减去法"><a href="#减去法" class="headerlink" title="减去法"></a>减去法</h1><p><strong>减去法</strong>是数据的键值减去一个特定的数值以求得数据存储的位置。</p><p><code>例</code> 公司有一百个员工，而员工的编号介于1001到1100，减去法就是员工编号减去1000后即为数据的位置。编号1001员工的数据在数据中的第一笔。编号1002员工的数据在数据中的第二笔…依次类推。从而获得有关员工的所有信息，因为编号1000以前并没有数据，所有员工编号都从1001开始编号。</p><h1 id="基数转换法"><a href="#基数转换法" class="headerlink" title="基数转换法"></a>基数转换法</h1><p>将十进制数X看作其他进制，比如十三进制，再按照十三进制数转换成十进制数，提取其中若干为作为X的哈希值。一般取大于原来基数的数作为转换的基数，并且两个基数应该是互素的。<br><code>例</code> Hash(80127429)=(80127429)13=8<em>137+0</em>136+1<em>135+2</em>134+7<em>133+4</em>132+2*131+9=(502432641)10如果取中间三位作为哈希值，得Hash（80127429）=432</p><p>为了获得良好的哈希函数，可以将几种方法联合起来使用，比如先变基，再折叠或平方取中等等，只要散列均匀，就可以随意拼凑。</p><h1 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h1><p>假设哈希表长为m，p为小于等于m的最大素数，则哈希函数为<br>h（k）=k  %  p ，其中%为模p取余运算。<br><code>例</code> 已知待散列元素为（18，75，60，43，54，90，46），表长m=10，p=7，则有</p><blockquote><p>  h(18)=18 % 7=4    h(75)=75 % 7=5    h(60)=60 % 7=4<br>  h(43)=43 % 7=1    h(54)=54 % 7=5    h(90)=90 % 7=6<br>  h(46)=46 % 7=4</p></blockquote><p>此时冲突较多。为减少冲突，可取较大的m值和p值，如m=p=13，结果如下：</p><blockquote><p>  h(18)=18 % 13=5    h(75)=75 % 13=10    h(60)=60 % 13=8<br>  h(43)=43 % 13=4    h(54)=54 % 13=2    h(90)=90 % 13=12<br>  h(46)=46 % 13=7</p></blockquote><p>此时没有冲突，如图所示。</p><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/yuanJiaLi/pic/Hash/Hash_Method7.png" alt=""><br>理论研究表明，除留余数法的模p取不大于表长且最接近表长m素数时效果最好，且p最好取1.1n～1.7n之间的一个素数（n为存在的数据元素个数）。</p><h1 id="随机数法"><a href="#随机数法" class="headerlink" title="随机数法"></a>随机数法</h1><p>设定哈希函数为:H(key) = Random(key)其中，Random 为伪随机函数</p><p>实际构造表时，采用何种构造哈希函数的方法取决于建表的关键字集合的情况(包括关键字的范围和形态)，以及哈希表长度（哈希地址范围），总的原则是使产生冲突的可能性降到尽可能地小。</p><p><code>适用</code>：对长度不等的关键字构造哈希函数。</p><h1 id="随机乘数法"><a href="#随机乘数法" class="headerlink" title="随机乘数法"></a>随机乘数法</h1><p>也称为“乘余取整法”。随机乘数法使用一个随机实数f,0≤f&lt;1,乘积f<em>k的分数部分在0～1之间，用这个分数部分的值与n（哈希表的长度）相乘，乘积的整数部分就是对应的哈希值，显然这个哈希值落在0～n-1之间。其表达公式为：Hash(k)=「n</em>(f<em>k%1)」其中“f</em>k%1”表示f<em>k 的小数部分，即f</em>k%1=f<em>k-「f</em>k」</p><p><code>例</code> 对下列关键字值集合采用随机乘数法计算哈希值，随机数f=0.103149002 哈希表长度n=100得图：</p><table><thead><tr><th style="text-align:center">k</th><th style="text-align:center">f*k</th><th style="text-align:center">n<em>((f</em>k)的小数部分)</th><th style="text-align:center">Hash(k)</th></tr></thead><tbody><tr><td style="text-align:center">319426</td><td style="text-align:center">32948.47311</td><td style="text-align:center">47.78411</td><td style="text-align:center">47</td></tr><tr><td style="text-align:center">718309</td><td style="text-align:center">74092.85648</td><td style="text-align:center">86.50488</td><td style="text-align:center">86</td></tr><tr><td style="text-align:center">629443</td><td style="text-align:center">64926.41727</td><td style="text-align:center">42.14427</td><td style="text-align:center">42</td></tr><tr><td style="text-align:center">919697</td><td style="text-align:center">84865.82769</td><td style="text-align:center">83.59669</td><td style="text-align:center">83</td></tr></tbody></table><p>此方法的优点是对n的选择不很关键。通常若地址空间为p位就是选n=2p.Knuth对常数f的取法做了仔细的研究，他认为f取任何值都可以，但某些值效果更好。(如f=（-1）/2=0.6180329…比较理想)</p><h1 id="字符串数值哈希法"><a href="#字符串数值哈希法" class="headerlink" title="字符串数值哈希法"></a>字符串数值哈希法</h1><p>在很都情况下关键字是字符串，因此这样对字符串设计Hash函数是一个需要讨论的问题。下列函数是取字符串前10个字符来设计的哈希函数<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Int Hash _ char (char *X)</span><br><span class="line">&#123;</span><br><span class="line">  int I ,sum</span><br><span class="line">  i=0;</span><br><span class="line">  while (i 10 &amp;&amp; X[i])</span><br><span class="line">  Sum +=X[i++];</span><br><span class="line">  sum%=N;      //N是记录的条数</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这种函数把字符串的前10个字符的ASCⅡ值之和对N取摸作为Hash地址，只要N较小，Hash地址将较均匀分布[0，N]区间内，因此这个函数还是可用的。对于N很大的情形，可使用下列函数<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int ELFhash (char *key )</span><br><span class="line">&#123;</span><br><span class="line"> Unsigned long h=0,g;</span><br><span class="line">whie (*key)</span><br><span class="line">&#123;</span><br><span class="line">h=(h&lt;&lt;4)+ *key;</span><br><span class="line">key++;</span><br><span class="line">g=h &amp; 0 xF0000000L;</span><br><span class="line">if (g) h^=g&gt;&gt;24;</span><br><span class="line">h &amp; =～g;</span><br><span class="line">&#125;</span><br><span class="line">h=h % N</span><br><span class="line">return （h）;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个函数称为ELFHash(Exextable and Linking Format ,ELF,可执行链接格式)函数。它把一个字符串的绝对长度作为输入，并通过一种方式把字符的十进制值结合起来，对长字符串和短字符串都有效，这种方式产生的位置不可能不均匀分布。</p><h1 id="旋转法"><a href="#旋转法" class="headerlink" title="旋转法"></a>旋转法</h1><p><strong>旋转法</strong>是将数据的键值中进行旋转。旋转法通常并不直接使用在哈希函数上，而是搭配其他哈希函数使用。<br><code>例</code> 某学校同一个系的新生（小于100人）的学号前5位数是相同的，只有最后2位数不同，我们将最后一位数，旋转放置到第一位，其余的往右移。</p><table><thead><tr><th style="text-align:center">新生学号</th><th style="text-align:center">旋转过程</th><th style="text-align:center">旋转后的新键值</th></tr></thead><tbody><tr><td style="text-align:center">5062101</td><td style="text-align:center">506210 1</td><td style="text-align:center">1506210</td></tr><tr><td style="text-align:center">5062102</td><td style="text-align:center">506210 2</td><td style="text-align:center">2506210</td></tr><tr><td style="text-align:center">5062103</td><td style="text-align:center">506210 3</td><td style="text-align:center">3506210</td></tr><tr><td style="text-align:center">5062104</td><td style="text-align:center">506210 4</td><td style="text-align:center">4506210</td></tr><tr><td style="text-align:center">5062105</td><td style="text-align:center">506210 5</td><td style="text-align:center">5506210</td></tr></tbody></table><p>运用这种方法可以只输入一个数值从而快速地查到有关学生的信息。</p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>图</title>
      <link href="/2018/06/24/Graph/"/>
      <url>/2018/06/24/Graph/</url>
      <content type="html"><![CDATA[<h1 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h1><p>图是由顶点的有穷非空集合和顶点之间边的集合组成。图可以用G = ( V , E )来表示，V表示顶点集合，E表示边集合，E中的边由A中的一对顶点连接而成。顶点总数为|V|，边的总数为|E|。</p><h1 id="图的分类"><a href="#图的分类" class="headerlink" title="图的分类"></a>图的分类</h1><p>稀疏图（sparse graph）：边数很少的图（|E|远小于|V|²）。</p><p>稠密图（dense graph）：边数较多的图（|E|接近|V|²）。</p><p>完全图（complete graph）：每对顶点之间都有唯一的边连接。</p><p>有向图（directed graph）：图点边限定为从一个顶点指向另一个顶点。</p><p>无向图（undirected graph）：图中的边没有方向。</p><p>标号图（labled graph）：图中各顶点均带有标号。</p><p>带权图（weighted graph）：边上标有权的图。（权（weight）：边可能附带的值。）</p><p>无环图（acyclic graph）：不带回路的图。</p><p>有向无环图（directed acyclic graph）：不带回路的有向图。</p><h1 id="图的抽象数据类型（ADT）"><a href="#图的抽象数据类型（ADT）" class="headerlink" title="图的抽象数据类型（ADT）"></a>图的抽象数据类型（ADT）</h1><p>基本操作<br>:<br>adjacent（x，y）：检测顶点x，y之间是否存在边；<br>neighbors（x）：列出所有存在到顶点x的顶点y;<br>add_vertex（x）：如果不存在则添加顶点x ;<br>remove_vertex（x）：如果存在顶点x则删除顶点x;<br>add_edge（x，y）：如果不存在从顶点x到顶点y的边则添加这条边;<br>remove_edge（x，y）：如果存在从顶点x到顶点y的边，则删除这条边;<br>get_vertex_value（x）：返回顶点x的值;<br>set_vertex_value（x，v）：给顶点x赋值为v;<br>get_edge_value（x，y）：返回边（x，y）的权;<br>set_edge_value（x，y，v）：将边（x，y）的权设置为v。</p><h1 id="图的表示方法"><a href="#图的表示方法" class="headerlink" title="图的表示方法"></a>图的表示方法</h1><p>一般稀疏图用邻接表来表示，稠密图用邻接矩阵来表示。</p><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/yuanJiaLi/pic/Graph.png" alt=""></p><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>阶为n的图G的邻接矩阵A是n×n的二维矩阵。将G的顶点标签为v1，v2，…，vn。<br>若（vi，vj）∈E（G），Aij=1,否则Aij=0。<br>无向图的邻接矩阵是对称矩阵。</p><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/yuanJiaLi/pic/Graph_Undirected_Matrix.png" alt=""></p><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>如果是无向图，那么每条边由两个结点组成，分别代表边的两个端点；如果是有向图，那么每条边是一个结点对，分别代表边的始点和终点。</p><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/yuanJiaLi/pic/Graph_Adjacency_Table.png" alt=""></p><h1 id="基本图算法"><a href="#基本图算法" class="headerlink" title="基本图算法"></a>基本图算法</h1><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h2 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h2><h3 id="Bellman-Ford算法（单源最短路径问题）"><a href="#Bellman-Ford算法（单源最短路径问题）" class="headerlink" title="Bellman-Ford算法（单源最短路径问题）"></a>Bellman-Ford算法（单源最短路径问题）</h3><h3 id="Dijkstra算法（单源最短路径问题）"><a href="#Dijkstra算法（单源最短路径问题）" class="headerlink" title="Dijkstra算法（单源最短路径问题）"></a>Dijkstra算法（单源最短路径问题）</h3><h3 id="Floyd-Warshall算法（所有结点对的最短路径问题）"><a href="#Floyd-Warshall算法（所有结点对的最短路径问题）" class="headerlink" title="Floyd-Warshall算法（所有结点对的最短路径问题）"></a>Floyd-Warshall算法（所有结点对的最短路径问题）</h3><h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h5><hr><ol><li>数据结构与算法分析第三版（C++版）。第十一章，图。</li><li>维基百科。Graph (abstract data type)，邻接矩阵。</li><li>算法导论。图算法章节。</li></ol>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>散列</title>
      <link href="/2018/06/23/Hash/"/>
      <url>/2018/06/23/Hash/</url>
      <content type="html"><![CDATA[<p>通过一些计算，即散列函数（Hash function），把关键码值映射到数组中的特定位置来访问记录，这个过程称为散列。通过散列函数得到的固定长度的输出值就是散列值，一般关键码范围中的值比散列值多，有些不同关键码会被映射到相同的散列值的槽里，这种现象称为冲突（碰撞）。</p><h1 id="散列的用途"><a href="#散列的用途" class="headerlink" title="散列的用途"></a>散列的用途</h1><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>哈希函数用于散列表，可以快速定位给定其搜索关键字（词条）的数据记录（例如字典定义）。具体地，哈希函数用于将搜索关键字映射到列表; 索引给出哈希表中应存储相应记录的位置。哈希表也用于实现关联数组和动态集。</p><p>通常，哈希函数的域（可能的键的集合）大于其范围（不同表索引的数量），因此它将映射几个不同的键到同一个索引。那么，哈希表的每个插槽与（隐含或明确地）一个相关的一系列的记录，而不是单一的记录。因此，哈希表的每个时隙通常称为存储桶，散列值也称为桶列表[ 需要引用 ]或桶索引。</p><p>因此，哈希函数只会在记录的位置提示。然而，在半满表中，好的散列函数通常将搜索缩小到只有一个或两个条目。</p><p>编写完整的哈希表实现的人员会选择一个特定的哈希函数，例如Jenkins哈希或Zobrist哈希，并且独立地选择哈希表冲突解决方案，例如合并散列，杜鹃哈希或跳房子散列散列。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>散列函数也用于为缓存介质中存储的大型数据集构建高速缓存。缓存通常比散列搜索表更简单，因为任何冲突都可以通过丢弃或写回两个较小的碰撞项来解决。这也用于文件比较。</p><h2 id="保护数据"><a href="#保护数据" class="headerlink" title="保护数据"></a>保护数据</h2><p>散列值可用于唯一标识秘密信息。这要求散列函数是防冲突的，这意味着很难找到将生成相同哈希值的数据。这些功能分为加密哈希函数和可证明的安全哈希函数。第二类中的功能是最安全的，但对于大多数实际目的也是太慢。碰撞抵抗是通过产生非常大的哈希值来实现的。例如，最广泛使用的密码散列函数之一的SHA-1生成160位值。</p><h2 id="查找重复记录"><a href="#查找重复记录" class="headerlink" title="查找重复记录"></a>查找重复记录</h2><p>在大型未分类文件中存储记录时，可以使用散列函数将每个记录映射到表T中的索引，并在每个存储桶T [ i ]中收集具有相同散列值的所有记录的编号列表我。一旦表完成，任何两个重复的记录将结束在同一个桶中。然后可以通过扫描包含两个或多个成员的每个桶T [ i ]，获取这些记录并进行比较来找到重复项。使用适当大小的表，该方法可能比任何替代方法（例如排序文件并比较所有连续对）快得多。</p><h2 id="查找类似记录"><a href="#查找类似记录" class="headerlink" title="查找类似记录"></a>查找类似记录</h2><p>散列函数也可用于定位与给定键相似但不完全相同的表记录; 或具有类似键的大文件中的记录对。为此，需要一个散列函数，将类似的键映射到不同于m的散列值，其中m是一个小整数（例如1或2）。如果使用这样的哈希函数建立所有记录号的表T，则类似的记录将在同一个桶或附近的桶中结束。然后，只需要检查每个桶T [ i ]中的记录与桶T [ i + k ]中的记录，其中k的范围在-m和  m。</p><p>该类包括所谓的声音指纹算法，用于在大量音频文件集合中定位类似声音的条目。对于此应用程序，散列函数必须尽可能不敏感，数据捕获或传输错误，以及时间和体积更改，压缩等简单的更改。</p><h2 id="错误校正"><a href="#错误校正" class="headerlink" title="错误校正"></a>错误校正</h2><p>使用一个散列函数可以很直观的检测出数据在传输时发生的错误。在数据的发送方，对将要发送的数据应用散列函数，并将计算的结果同原始数据一同发送。在数据的接收方，同样的散列函数被再一次应用到接收到的数据上，如果两次散列函数计算出来的结果不一致，那么就说明数据在传输的过程中某些地方有错误了。这就叫做冗余校验。</p><p>对于错误校正，假设相似扰动的分布接近最小(a distribution of likely perturbations is assumed at least approximately)。对于一个信息串的微扰可以被分为两类，大的（不可能的）错误和小的（可能的）错误。我们对于第二类错误重新定义如下，假如给定 H(x) 和 x+s，那么只要s足够小，我们就能有效的计算出x。那样的散列函数被称作错误校正编码。这些错误校正编码有两个重要的分类：循环冗余校验和里德所罗门码。</p><h2 id="在信息安全上的应用"><a href="#在信息安全上的应用" class="headerlink" title="在信息安全上的应用"></a>在信息安全上的应用</h2><h3 id="验证文件或消息的完整性"><a href="#验证文件或消息的完整性" class="headerlink" title="验证文件或消息的完整性"></a>验证文件或消息的完整性</h3><p>使用HMAC（哈希消息认证码），以一个密钥和一个消息作为输入，生成一个消息摘要作为输出。通过比较传输之前和传输之后的消息摘要来完成校验。</p><p>HMAC的作用：<br>（1）验证TPM接受的授权数据和认证数据；<br>（2）确认TPM接受到的命令请求是已授权的请求，并且，命令在传送的过程中没有被改动过。</p><p>过程简述：首先根据消息内容提取一个随机长度的信息（可以直接利用关键字，也可以对其进行折叠、平方取中等运算），然后对信息进行补位，使信息的字节长度是32的倍数，经过一系列补位和附加值处理，产生一个128位的消息摘要。</p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>Hash签名也称为数字摘要法（digital digest）、数字指纹法（digital finger print）。<br>最常见的实现方法是建立在公钥密码体制和单向安全散列函数的组合基础上的。</p><p>过程简述：将要发送的消息作为输入，用哈希算法得到此消息的消息摘要，并用自己的私钥加密此消息摘要，然后将消息本身和加密后的消息摘要一同发送出去。接收方收到后利用公钥解密加密消息得到消息摘要，然后通过接收到的消息本身利用哈希算法得到用于验证的消息摘要，比较这两个消息摘要是否相同，从而对消息发送者进行身份验证。<br><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/yuanJiaLi/pic/Hash/Hash_Application1.png" alt=""></p><h3 id="密码验证"><a href="#密码验证" class="headerlink" title="密码验证"></a>密码验证</h3><p>使用MD5、SHA1等单向Hash算法可以让原密码无法通过计算还原。<br>过程简述：储存原密码的哈希摘要，当需要进行身份验证时，用户输入的密码被散列并鱼储存的散列进行比较。</p><h4 id="1-7-4-伪随机生成和密钥推导"><a href="#1-7-4-伪随机生成和密钥推导" class="headerlink" title="1.7.4 伪随机生成和密钥推导"></a>1.7.4 伪随机生成和密钥推导</h4><p>散列函数也可用于生成伪随机位，或者从单个安全密钥或密码导出新密钥或密码。</p><h1 id="Hash构造函数的方法"><a href="#Hash构造函数的方法" class="headerlink" title="Hash构造函数的方法"></a>Hash构造函数的方法</h1><p><a href="http://101.132.150.179:4000/publish/data_structure/Construction_Method.html" target="_blank" rel="noopener">详细内容</a></p><h1 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h1><p><a href="https://www.zybuluo.com/AlphaYuan/note/1037471" target="_blank" rel="noopener">详细内容</a></p><h1 id="冲突解决方法"><a href="#冲突解决方法" class="headerlink" title="冲突解决方法"></a>冲突解决方法</h1><p><a href="https://www.zybuluo.com/AlphaYuan/note/1037497" target="_blank" rel="noopener">详细内容</a></p><h1 id="散列算法"><a href="#散列算法" class="headerlink" title="散列算法"></a>散列算法</h1><h2 id="MD5算法"><a href="#MD5算法" class="headerlink" title="MD5算法"></a>MD5算法</h2><p><strong>MD5</strong>即 Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理，MD5的前身有MD2、MD3和MD4。</p><p>MD5算法具有以下特点：<br>1、压缩性：任意长度的数据，算出的MD5值长度都是固定的。<br>2、容易计算：从原数据计算出MD5值很容易。<br>3、抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。<br>4、强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。</p><p><a href="https://www.baidu.com" target="_blank" rel="noopener">MD5介绍</a></p><h2 id="SHA-1算法"><a href="#SHA-1算法" class="headerlink" title="SHA-1算法"></a>SHA-1算法</h2><p>SHA (Secure Hash Algorithm，译作安全散列算法) 是美国国家安全局 (NSA) 设计，美国国家标准与技术研究院(NIST) 发布的一系列密码散列函数。正式名称为 SHA 的家族第一个成员发布于 1993年。然而人们给它取了一个非正式的名称 SHA-0 以避免与它的后继者混淆。两年之后， SHA-1，第一个 SHA 的后继者发布了。 另外还有四种变体，曾经发布以提升输出的范围和变更一些细微设计： SHA-224, SHA-256, SHA-384 和 SHA-512 (这些有时候也被称做 SHA-2)。</p><hr><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h5><ol><li>维基百科。哈希函数，加密散列函数。</li><li>百度百科。<a href="https://baike.baidu.com/item/MD5/212708?fr=aladdin" target="_blank" rel="noopener">MD5</a>、<a href="https://baike.baidu.com/item/SHA-1/1699692?fr=aladdin" target="_blank" rel="noopener">SHA-1</a></li><li>算法导论。第十一章散列表，机械工业出版社。</li><li>数据结构与算法分析第三版（C++版）。第九章，散列方法。</li><li><a href="http://www.jiamisoft.com/blog/21553-hxsf.html" target="_blank" rel="noopener">浅析几种典型的哈希算法</a></li><li><a href="http://blog.csdn.net/tanggao1314/article/details/51457585" target="_blank" rel="noopener">hash算法原理详解</a></li><li><a href="http://blog.csdn.net/jn1158359135/article/details/7205688" target="_blank" rel="noopener">浅谈散列</a></li><li><a href="http://hunteagle.javaeye.com" target="_blank" rel="noopener">几种经典的hash算法</a></li><li><a href="http://blog.csdn.net/lightty/article/details/11191971" target="_blank" rel="noopener">解决哈希（HASH）冲突的主要方法</a></li></ol>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 散列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>散列方法</title>
      <link href="/2018/06/22/Hash_Function/"/>
      <url>/2018/06/22/Hash_Function/</url>
      <content type="html"><![CDATA[<h1 id="除法散列法"><a href="#除法散列法" class="headerlink" title="除法散列法"></a>除法散列法</h1><p>设<code>hash(key)=key mod m</code>，其中key表示被散列的关键字，而m则表示散列表的大小，mod则为取余操作。</p><p>这是一种比较简单的散列函数，但简单并不意味着高效。当待散列的元素之间存在某种模式时，这种散列法会有相当糟糕的性能表现。对该函数一个有用的指导原则是将m选取为接近待散列集合大小的质数。</p><h1 id="乘法散列法"><a href="#乘法散列法" class="headerlink" title="乘法散列法"></a>乘法散列法</h1><p>设 <code>hash(key)=floor(m×(A×key mod 1))</code>，其中floor()表示对表达式进行下取整，A∈(0,1)，m如上同样表示散列表的大小，且在这种方法中对m并无任何特殊的要求。<br>[A×key mod 1]表示将key乘上某个在0~1之间的数并取乘积的小数部分，该表达式等价于A×key-floor(A×key)</p><p>这里最重要的是A的值应该如何设定，Don•Knuth老大认为A=(√5-1)/2 [黄金分割点] 比较好。</p><h1 id="全域散列法"><a href="#全域散列法" class="headerlink" title="全域散列法"></a>全域散列法</h1><p>设<code>hasha,b(key)=(a×key+b) mod m</code>，如同除余散列法中一样，m的值应为质数，而a∈{1,2,3,…,m-1}，b∈{0,1,2,…,m-1}且a,b的值应在运行时动态确定。</p><p>全域散列的基本思想是给出hash函数的基本“骨架”，而其中的某些参数通过运行时在指定范围内随机选取确定，从而实际上形成了一个函数簇。根据上述a,b的取值范围，我们知道这个函数簇中存在m×(m-1)个函数。因为对于同一个输入，每次执行时选取不同的参数将拥有不同的性能表现，因此设计的函数实际上独立于任意被散列的关键字。只有当一个相对糟糕的输入——即该输入不构成随机分布，遇到一个选取的相对糟糕的散列函数时，才将导致较差的性能，在多数情况下这类散列往往具有较好的运行时性能表现。</p><h1 id="平方散列法"><a href="#平方散列法" class="headerlink" title="平方散列法"></a>平方散列法</h1><p>求hash(key)是非常频繁的操作，而乘法的运算要比除法更省时，所以考虑把除法换成乘法和一个位移操作，公式为： </p><blockquote><p>hash(key)= (key * key) &gt;&gt; 28   （右移28位，除以2^28。）</p></blockquote><p>如果数值分配比较均匀的话这种方法能得到不错的结果。</p><h1 id="斐波那契（Fibonacci）散列法"><a href="#斐波那契（Fibonacci）散列法" class="headerlink" title="斐波那契（Fibonacci）散列法"></a>斐波那契（Fibonacci）散列法</h1><p>为了解决平方散列法的缺点,我们需要找出一个理想的乘数，而不是拿key本身当作乘数。<br>1，对于16位整数而言，这个乘数是40503<br>2，对于32位整数而言，这个乘数是2654435769<br>3，对于64位整数而言，这个乘数是11400714819323198485<br>这几个“理想乘数”的得出跟一个法则有关，叫黄金分割法则，而描述黄金分割法则的最经典表达式无疑就是著名的斐波那契数列，即如此形式的序列：0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233,377, 610，987, 1597, 2584, 4181, 6765, 10946，… </p><p>常见的32位整数，使用公式： </p><blockquote><p>Hash（key）= (key * 2654435769) &gt;&gt; 28</p></blockquote><h1 id="加法Hash"><a href="#加法Hash" class="headerlink" title="加法Hash"></a>加法Hash</h1><p>所谓的加法Hash就是把输入元素一个一个的加起来构成最后的结果。标准的加法Hash的构造如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static int additiveHash(String key, int prime)</span><br><span class="line">&#123;</span><br><span class="line"> int hash, i;</span><br><span class="line"> for (hash = key.length(), i = 0; i &lt; key.length(); i++)</span><br><span class="line">  hash += key.charAt(i);</span><br><span class="line"> return (hash % prime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 这里的prime是任意的质数，看得出，结果的值域为[0,prime-1]。</p><h2 id="位运算Hash"><a href="#位运算Hash" class="headerlink" title="位运算Hash"></a>位运算Hash</h2><p>这类型Hash函数通过利用各种位运算（常见的是移位和异或）来充分的混合输入元素。比如，标准的旋转Hash的构造如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static int rotatingHash(String key, int prime)</span><br><span class="line">&#123;</span><br><span class="line">  int hash, i;</span><br><span class="line">  for (hash=key.length(), i=0; i&lt;key.length(); ++i)</span><br><span class="line">    hash = (hash&lt;&lt;4)^(hash&gt;&gt;28)^key.charAt(i);</span><br><span class="line">  return (hash % prime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先移位，然后再进行各种位运算是这种类型Hash函数的主要特点。比如，以上的那段计算hash的代码还可以有如下几种变形：</p><blockquote><ol><li>hash = (hash&lt;&lt;5)^(hash&gt;&gt;27)^key.charAt(i);</li><li>hash += key.charAt(i);<br>hash += (hash &lt;&lt; 10);<br>hash ^= (hash &gt;&gt; 6);</li><li>if((i&amp;1) == 0)<br>{<br> hash ^= (hash&lt;&lt;7) ^ key.charAt(i) ^ (hash&gt;&gt;3);<br>}<br>else<br>{<br> hash ^= ~((hash&lt;&lt;11) ^ key.charAt(i) ^ (hash &gt;&gt;5));<br>}</li><li>hash += (hash&lt;&lt;5) + key.charAt(i);</li><li>hash = key.charAt(i) + (hash&lt;&lt;6) + (hash&gt;&gt;16) – hash;</li><li>hash ^= ((hash&lt;&lt;5) + key.charAt(i) + (hash&gt;&gt;2));</li></ol></blockquote><h1 id="乘法Hash"><a href="#乘法Hash" class="headerlink" title="乘法Hash"></a>乘法Hash</h1><p>这种类型的Hash函数利用了乘法的不相关性（乘法的这种性质，最有名的莫过于平方取头尾的随机数生成算法，虽然这种算法效果并不好）。比如，<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static int bernstein(String key)</span><br><span class="line">&#123;</span><br><span class="line">  int hash = 0;</span><br><span class="line">  int i;</span><br><span class="line">  for (i=0; i&lt;key.length(); ++i) hash = 33*hash + key.charAt(i);</span><br><span class="line">  return hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>jdk5.0里面的String类的hashCode()方法也使用乘法Hash。不过，它使用的乘数是31。推荐的乘数还有：131, 1313, 13131, 131313等等。<br>使用这种方式的著名Hash函数还有：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//  32位FNV算法</span><br><span class="line">int M_SHIFT = 0;</span><br><span class="line">public int FNVHash(byte[] data)</span><br><span class="line">&#123;</span><br><span class="line">    int hash = (int)2166136261L;</span><br><span class="line">    for(byte b : data)</span><br><span class="line">        hash = (hash * 16777619) ^ b;</span><br><span class="line">    if (M_SHIFT == 0)</span><br><span class="line">        return hash;</span><br><span class="line">    return (hash ^ (hash &gt;&gt; M_SHIFT)) &amp; M_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以及改进的FNV算法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static int FNVHash1(String data)</span><br><span class="line">&#123;</span><br><span class="line">    final int p = 16777619;</span><br><span class="line">    int hash = (int)2166136261L;</span><br><span class="line">    for(int i=0;i&lt;data.length();i++)</span><br><span class="line">        hash = (hash ^ data.charAt(i)) * p;</span><br><span class="line">    hash += hash &lt;&lt; 13;</span><br><span class="line">    hash ^= hash &gt;&gt; 7;</span><br><span class="line">    hash += hash &lt;&lt; 3;</span><br><span class="line">    hash ^= hash &gt;&gt; 17;</span><br><span class="line">    hash += hash &lt;&lt; 5;</span><br><span class="line">    return hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除了乘以一个固定的数，常见的还有乘以一个不断改变的数，比如：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static int RSHash(String str)</span><br><span class="line">&#123;</span><br><span class="line">    int b    = 378551;</span><br><span class="line">    int a    = 63689;</span><br><span class="line">    int hash = 0;</span><br><span class="line">   for(int i = 0; i &lt; str.length(); i++)</span><br><span class="line">   &#123;</span><br><span class="line">      hash = hash * a + str.charAt(i);</span><br><span class="line">      a    = a * b;</span><br><span class="line">   &#125;</span><br><span class="line">   return (hash &amp; 0x7FFFFFFF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>虽然Adler32算法的应用没有CRC32广泛，不过，它可能是乘法Hash里面最有名的一个。关于它的介绍，大家可以去看RFC 1950规范。</p><h1 id="除法Hash"><a href="#除法Hash" class="headerlink" title="除法Hash"></a>除法Hash</h1><p>除法和乘法一样，同样具有表面上看起来的不相关性。不过，因为除法太慢，这种方式几乎找不到真正的应用。需要注意的是，我们在前面看到的hash的 结果除以一个prime的目的只是为了保证结果的范围。如果你不需要它限制一个范围的话，可以使用如下的代码替代”hash%prime”：</p><blockquote><p>hash = hash ^ (hash&gt;&gt;10) ^ (hash&gt;&gt;20)。</p></blockquote><h1 id="查表Hash"><a href="#查表Hash" class="headerlink" title="查表Hash"></a>查表Hash</h1><p>查表Hash最有名的例子莫过于CRC系列算法。虽然CRC系列算法本身并不是查表，但是，查表是它的一种最快的实现方式。查表Hash中有名的例子有：Universal Hashing和Zobrist Hashing。他们的表格都是随机生成的。</p><h1 id="混合Hash"><a href="#混合Hash" class="headerlink" title="混合Hash"></a>混合Hash</h1><p>混合Hash算法利用了以上各种方式。各种常见的Hash算法，比如MD5、Tiger都属于这个范围。它们一般很少在面向查找的Hash函数里面使用。</p><h1 id="数组hash"><a href="#数组hash" class="headerlink" title="数组hash"></a>数组hash</h1><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inline int hashcode(const int *v)</span><br><span class="line">&#123;</span><br><span class="line">int s = 0;</span><br><span class="line">for(int i=0; i&lt;k; i++)</span><br><span class="line">s=((s&lt;&lt;2)+(v[i]&gt;&gt;4))^(v[i]&lt;&lt;10);</span><br><span class="line">s = s % M;</span><br><span class="line">s = s &lt; 0 ? s + M : s;</span><br><span class="line">return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 散列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>堆</title>
      <link href="/2018/06/21/Heap/"/>
      <url>/2018/06/21/Heap/</url>
      <content type="html"><![CDATA[<p>堆通是一种近似的完全二叉树，树上每一个结点对应数组中的一个元素。除最底层外，该树是完全充满的，且最底层的元素从左往右填入。</p><p>设计目的<br>: 在队列中，调度程序反复提取队列中第一个作业并运行，因为实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。</p><h1 id="逻辑定义"><a href="#逻辑定义" class="headerlink" title="逻辑定义"></a>逻辑定义</h1><p>n个元素序列{k1, k2… ki…kn},当且仅当满足下列关系时称之为堆：<br>(ki &lt;= k2i, ki &lt;= k2i+1)或者(ki &gt;= k2i, ki &gt;= k2i+1), (i = 1, 2, 3, 4… n/2)</p><h1 id="堆的结构"><a href="#堆的结构" class="headerlink" title="堆的结构"></a>堆的结构</h1><p>一个堆结构将由一个数组和一个代表当前堆大小的整数组成。</p><h1 id="堆序性质"><a href="#堆序性质" class="headerlink" title="堆序性质"></a>堆序性质</h1><p>使操作被快速执行的性质是堆序性质(heap-order-property)。由于我们想要能够快速地找出最小元， 因此最小元应该在根上。如果考虑任意子树也应该是一个堆，那么任意节点就应该小千它的所有后裔。</p><p>应用这个逻辑， 我们得到堆序性质。在一个堆中，对于每一个节点X,X的父亲中的关键字小于（或等于）X中的关键字，根节点除外（它没有父亲）。在图6.5中左边的树是一个堆，但是，右边的树则不是（虚线表示堆的有序性被破坏）。</p><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/yuanJiaLi/pic/Heap_Binary_Tree.png" alt=""><br>根据堆序性质， 最小元总可以在根处找到。因此，我们以常数时间得到附加操作丘find.Min。</p><h1 id="堆操作"><a href="#堆操作" class="headerlink" title="堆操作"></a>堆操作</h1><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">描述</th><th style="text-align:center">时间复杂度</th></tr></thead><tbody><tr><td style="text-align:center">biuld</td><td style="text-align:center">创建一个空堆</td><td style="text-align:center">Ο(n)</td></tr><tr><td style="text-align:center">insert</td><td style="text-align:center">将一个新元素插入到堆中</td><td style="text-align:center">Ο(log n)</td></tr><tr><td style="text-align:center">update</td><td style="text-align:center">将新元素提升使其匹配堆的性质</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">get</td><td style="text-align:center">获取当前堆顶元素的值</td><td style="text-align:center">Ο(1)</td></tr><tr><td style="text-align:center">delete</td><td style="text-align:center">删除堆顶元素</td><td style="text-align:center">Ο(log  n)</td></tr><tr><td style="text-align:center">heapify</td><td style="text-align:center">使删除堆顶元素的堆再次成为堆</td></tr></tbody></table><h4 id="其他的堆操作"><a href="#其他的堆操作" class="headerlink" title="其他的堆操作"></a>其他的堆操作</h4><p>decreaseKey（降低关键字的值）<br>: decreaseKey(p,Δ)操作降低在位置p处的项的值，降低的幅度为正的量Δ。由于这可能破坏堆序性质，因此必须通过上滤对堆进行调整。该操作对系统挂历程序是有用的：系统管理程序能够使他们的程序以最高的优先级来运行。</p><p>increaseKey（增加关键字的值）<br>: increaseKey(p,Δ)操作增加在位置p处的值，增值的幅度为正的量Δ。这可以用下滤来完成。许多调度程序自动降低正在过多地小号CPU时间的进程的优先级。</p><p>为将元素X插入堆中，找到空闲位置，创建一个空穴，若满足堆序性（英文：heap order），则插入完成；否则将父节点元素装入空穴，删除该父节点元素，完成空穴上移。直至满足堆序性。这种策略叫做<strong>上滤</strong>（percolate up）。</p><p>删除该节点元素后，队列最后一个元素必须移动到堆得某个位置，使得堆仍然满足堆序性质。这种向下替换元素的过程叫作<strong>下滤</strong>。</p><h2 id="最小-最大堆的插入"><a href="#最小-最大堆的插入" class="headerlink" title="最小-最大堆的插入"></a>最小-最大堆的插入</h2><p>最小-最大堆：各层交替为最小层和最大层的堆。</p><p>最大层：该层上的节点大于等于以其为根节点的子树上的所有节点。</p><p>最小层：该层上的节点小于等于以其为根节点的子树上的所有节点。</p><p>本文中，我们令堆的层数从1开始，节点编号也从1开始，即根节点为第1层，编号为1。</p><p>最小最大对具有如下性质：</p><p>对于任一节点，从该节点到叶节点的任意一条路径，</p><p>（1）处于最小层的节点关键字逐渐增大；</p><p>（2）处于最大层的节点关键字逐渐减小；</p><p>（3）所有处于最大层的节点关键字大于所有处于最小层的节点的关键字。</p><p>具体实现见下面，我们使用min_max_insert将item插入到堆heap中，插入前节点个数为*n。边界条件不进行详细解释。</p><p>首先将item存入heap[*n+1]处，检查该元素的父节点是最大层还是最小层。</p><p><strong>1）父节点是最小层，且该元素小于父节点</strong></p><p>该节点是最后一个节点且处于最大层，本次插入只增加最大层节点数，最小层节点数不变；</p><p>父节点是最小层的最后一个元素，是最小层节点中最大的节点；</p><p>假设插入前最小层节点数为ms，最大层节点数为mt，则插入后最小层节点数不变，最小层节点数为mt+1。由推论可知，最小层节点是所有节点中最小的前ms个节点，父节点属于这ms个节点中最大的节点，现在新插入的节点小于父节点，就意味着，新节点将代替父节点成为最小的前ms个节点之一，因此父节点属于最大层节点。</p><p>又由于父节点原先小于最小层，因此小于所有原先最大层的节点，现在转入最大层后，成为最大层节点中最小的节点，根据最小最大堆的性质可知，父节点必属于其所属路径上的最后一个节点。因此我们直接把父节点放入heap[*n+1]处即可。</p><p>对于新加入节点，我们不需要改动其它路径，只需沿着heap[*n+1]到根节点的这条路径，找出所有最小层节点，将其放在某位置，使得该路径上节点顺序满足最小最大堆性质(1)即可。</p><p><strong>2）父节点是最小层，且该元素大于父节点</strong></p><p>同理，新加入节点只是改变了最大层节点数，不会改变最小层节点数。</p><p>父节点是前ms个最小节点中最大的，新节点大于父节点，所以新节点不可能是前ms个最小节点，所以新节点属于最大层。</p><p>因此，我们只需找出heap[*n+1]到根节点的这条路径上所有最大层节点，将新节点放入某个位置，其它节点依次后移，使得这些节点满足最小最大堆的性质(2).</p><p><strong>3）父节点是最大层，且该元素大于父节点</strong></p><p>此时，新加入的节点处于最小层，所以新节点的加入改变的是最小层节点数，不会改变最大层节点数。</p><p>最大层节点是所有节点中最大的mt个节点，且父节点是则mt个节点中最小的节点，新节点大于父节点，就意味着父节点不可能再成为最大的前mt个节点，所以新节点代替父节点成为最大层节点。</p><p>由于父节点大于所有最小层节点，所以父节点应该是出于该路径上的最后一个位置，因此直接将父节点放入heap[*n+1]即可。</p><p>对于新节点，只需找出heap[*n+1]到根节点路径上的所有最大层节点，将新节点放入某位置，其它节点依次后移，使得该路径上所有最小层节点满足性质(1)即可。</p><p><strong>4）父节点是最大层，且该元素小于父节点</strong></p><p>最大层节点不变，仍是原先的mt个节点。</p><p>新节点属于最小层节点，将新节点加入heap[<em>n+1]，找出heap[</em>n+1]到根节点路径上所有最小层节点，重新排序，满足性质（1）。</p><h2 id="最小-最大堆的删除（最小元素）"><a href="#最小-最大堆的删除（最小元素）" class="headerlink" title="最小-最大堆的删除（最小元素）"></a>最小-最大堆的删除（最小元素）</h2><p>基本思想：最小元素就是最小-最大堆根节点对应的元素，所以每次都是直接删除该节点。如果还有剩余节点，接着要做的就是将剩余节点重新组织成一个新的最小-最大堆。</p><p>最直接的方式就是对所有元素重新建堆，即把剩余元素逐个输入堆里，每输入一个元素调用一次函数min_max_insert，将已输入元素建成最小-最大堆，直到所有元素输入为止。但这么做显然效率是比较低的，原先的堆里所包含的信息被全部丢弃。直觉告诉我们，可以利用原先堆的信息，找到更简便的方法。</p><p>我们现在将剩余节点全部保留在原位置，缺了一个根节点，于是，我们很自然的想到要找一个节点放入根节点位置，我们找到剩余节点中最小的节点放入根节点。</p><p>因为最小最大堆的根节点是整个堆中最小的元素，所有首先在剩余节点中找到最小的节点，并将该节点放入根节点处；假设最小节点位置为k。</p><p>现在k位置空了下来。另外，现在堆节点数少了一个，最后一个节点需要删除，也就意味着该节点存放的元素将没有位置存放，用item表示，我们很自然地想到，将item放在k位置。那么这么做究竟是否可行呢？通过分析，直接放在有些情况下会违反最小-最大堆，下面我们具体分析：</p><p>（1）只剩一个节点，不需进行任何操作（该节点已被放入根节点）；</p><p>（2）剩余两个或两个以上节点且k是最后一个节点，不需进行任何操作（该节点已被放入根节点）；</p><p>（3）剩余两个或两个以上节点且k不是最后一个节点其它情况，则需要根据k可能出现的位置来进一步分析：</p><p>首先，k只可能出现在第二层或第三层（否则不可能是最小节点）。</p><p>如果出现在第二层，则有两种可能：左儿子、右儿子。</p><p>如果是左儿子，说明左儿子没有子节点，右儿子也没有子节点（完全二叉树），我们只需要将item直接放入k节点处即可；</p><p>如果是右儿子，则右儿子没有子节点，左儿子可能有子节点。不管左儿子有没有子节点，都只需将item放入k节点即可；</p><p>如果出现在第三层，不管最后一个节点是不是k节点的后代，甚至不管k是否有后代，将item放入k节点后，都只会影响从根节点出发到到叶节点结束，且经过k节点的路径，其它路径仍满足最小最大堆的性质。</p><p>我们由最小最大堆的性质和定义可知，检查一个堆是否为最小最大堆，只需检查其各条路径是否满足最小-最大堆性质即可。</p><p>违反最小-最大堆有下面几种情况：</p><p>item大于k的父节点：我们只需要item和父节点调换，此时其它路径仍不会违反，父节点仍是那些路径上的最大节点。接下来，只需把item（此时已变为原先k的父节点元素）放入k节点，但同样不能直接放入，插入方式与最开始将最后一个元素插入根节点一样。</p><p>因为此时k是第三层，其父节点是第二层，为最大层，所以父节点应大于k节点；父节点处于第二层，大于以其为根的堆中所有元素。item既然大于父节点，且即将成为这个堆中的元素之一，因此item是新堆中最大的元素，应将其放在父节点的位置，且不管后面如何排，都不会改变，也就是说，我们接下来只需考虑以k节点及k节点的兄弟为根的子树。另外，以k节点的兄弟为根的子树在父节点和item交换后并不违反最小-最大堆性质，因此，我们只需考虑以k为根的子树。问题就变成了将新的item插入以k为根的子树的根节点（即k节点）。这和最先将最后一个元素插入根节点完全相同。</p><p>item大于k的子节点：把item插入k节点，插入方式与最开始将最后一个元素插入根节点一样。</p><p>通过上面的分析，item插入以k的父节点为根的堆中后，堆的最大元素仍然是k的父节点，所以父节点不变，因此，k的兄弟节点所在的路径或子堆也未违反最小-最大堆性质，不需改变，所以我们就只考虑将item插入以k为根的堆中的根节点（即k节点）即可。</p><p>总结起来就是三种情况：</p><p>a)     k处于第二层：</p><p>b)    k处于第三层且item大于k的父节点；</p><p>c)    k处于第三层且item大于k的子节点；</p><p>结合边界条件，我们很容易进行实现。</p><hr><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h5><p>1.<a href="https://zh.wikipedia.org/wiki/%E5%A0%86_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">中文维基百科——堆 (数据结构)</a>)</p><p>2.数据结构与算法分析——C++描述版(第四版)</p><p>3.<a href="http://blog.sina.com.cn/s/blog_70ec9a6f01012l0v.html" target="_blank" rel="noopener">最小-最大堆的插入和删除</a></p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 堆 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>队列</title>
      <link href="/2018/06/20/Queue/"/>
      <url>/2018/06/20/Queue/</url>
      <content type="html"><![CDATA[<h1 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>队列是只允许在一端进行插入操作，而在另一端进行删除操纵的特殊的线性表。</p><p>允许进行元素插入操作的一端称为队尾（rear），允许进行元素删除操作的一端称为队头（front）。在队尾插入元素的操作称为入队（Enqueue），在队头删除元素的操作称为出队（Dequeue）如图1-1-1所示。<br><img src="https://raw.githubusercontent.com/Yojiaku/MarkdownPhotos/a99a04b1c807a382cb838a0152393470c1335f86/pic/queue-1-1-1.png" alt=""></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>先进先出（First In First Out）</p><p>#队列的抽象数据类型<br>同样是线性表，队列也有类似线性表的各种操作，不同的就是插入数据只能在队尾进行，输出数据只能在队头进行。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT</span><br><span class="line">  队列（Queue）</span><br><span class="line">Data</span><br><span class="line">  同线性表。元素具有相同的类型，相邻元素具有线性关系。</span><br><span class="line">Operation</span><br><span class="line">  InitQueue(*Q):初始化操作，建立一个空队列Q。</span><br><span class="line">  DestroyQueue(*Q):若队列Q存在，则销毁它。</span><br><span class="line">  ClearQueue(*Q):将队列Q清空。</span><br><span class="line">  QueueEmpty(*Q):若队列Q为空，则返回true，否则返回false。</span><br><span class="line">  GetHead(Q,*e):若队列Q存在且非空，用e返回队列Q的队头元素。</span><br><span class="line">  EnQueue(*Q,e):若队列Q存在，插入新元素e到队列Q中并成为队尾元素。</span><br><span class="line">  DeQueue(*Q,*e):删除队列Q中队头元素并用e返回其值。</span><br><span class="line">  QueueLength(Q):返回队列Q的元素个数。</span><br></pre></td></tr></table></figure><h1 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h1><p>栈作为一种特殊的线性表，栈有链表栈和顺序栈两种实现方式。同样对于队列来说，队列也是一种特殊的线性表，因此也同样有两种实现方式，但队列更为特殊一点，实现队列常用的两种方式分别是循环队列和链式队列。</p><h2 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h2><p>在引入循环队列之前，我们先来分析一下队列顺序存储的不足。</p><p>和顺序栈相类似，在队列的顺序存储结构中，除了用一组地址连续的存储单元依次存放从队头到队尾的元素之外，还需要两个指针进行管理。一个是队头指针（front）指向队头元素，另一个是队尾指针（rear）指向下一个入队元素的存储位置。</p><p>当我们需要向队列添加一个元素时，只要在队尾追加一个元素就可以了，不需要移动任何元素，因此时间复杂度为θ(1)，如图3-1-1所示。</p><p><img src="https://raw.githubusercontent.com/Yojiaku/MarkdownPhotos/a99a04b1c807a382cb838a0152393470c1335f86/pic/queue-3-1-1.png" alt=""></p><p>当我们需要队头的元素出队时，第一个位置就空出来了。那就意味着，队列中剩下的所有元素都得向前移动，以保证队列的队头有元素存放（如图3-1-2所示）。这就好比我们排队买票，前面的人买好了离开，后面的人就要向前不缺空位，这似乎很合理。但在队列中，若要完成这一行为，此时的时间复杂度为θ(n)，显然这中行为是浪费的。</p><p><img src="https://raw.githubusercontent.com/Yojiaku/MarkdownPhotos/a99a04b1c807a382cb838a0152393470c1335f86/pic/queue-3-1-2.png" alt=""></p><p>既然补缺空位的做法是浪费的，那何必出队列时一定要全部移动呢。如果不去限制队列的元素必须存储在数组的前n个单元这一条件，出队的性能就会大大增加。也就是说，队头(front)不需要一定在存储空间的最前面，如图3-1-3所示。</p><p><img src="https://raw.githubusercontent.com/Yojiaku/MarkdownPhotos/a99a04b1c807a382cb838a0152393470c1335f86/pic/queue-3-1-3.png" alt=""></p><p>但是，当我们这样定义的时候，会出现一种比较的特殊的情况，如图3-1-4所示。</p><p><img src="https://raw.githubusercontent.com/Yojiaku/MarkdownPhotos/a99a04b1c807a382cb838a0152393470c1335f86/pic/queue-3-1-4.png" alt=""></p><p>正如图3-1-4所示，A5入队之后，rear指针移动了数组之外，数组之外是哪里呢？是不是出错了？如果再有一个A6入队，因为队列添加元素只能在队尾进行操作，但数组末尾已经备注占用了，再向后加产生了错误。是不是就不能添加元素了呢？如果你上了俩公交车，发现前两排有个空座位，而后排所有座位都已经占满了，那你会说车上已经没有座位了，所以你要下车。显然这是不可能的。</p><p>在队列中若出现的这种情况，我们称为“假上溢”现象，除此之外，还有“真上溢”，“下溢”现象。</p><p>“假上溢”现象：由于入队和出队操作中，头尾指针只增加不减小，致使被删元素的空间永远无法重新利用。当队列中实际的元素个数远远小于向量空间的规模时，也可能由于尾指针已超越向量空间的上界而不能做入队操作。该现象称为”假上溢”现象。</p><p>“真上溢”现象：当队列满时，做进栈运算产生空间溢出的现象。“真上溢”是一种出错状态，应设法避免。</p><p>“下溢”现象：当队列为空时，做出队运算产生的溢出现象。“下溢”是正常现象，常用作程序控制转移的条件。</p><p>“假上溢”现象显然是很浪费的一种情况，我们肯定是要想办法解决这一问题的，随之而来的也就引入了循环队列。</p><h2 id="循环队列-1"><a href="#循环队列-1" class="headerlink" title="循环队列"></a>循环队列</h2><p>很简单，假上溢的时候，既然后面的满了，前面的还有空缺，那就从头在开始呗，也就是头尾想接的循环。我们把队列的这种头尾相接的顺序储存结构称为循环队列。在图3-1-4中，我们就可以根据循环队列的定义将rear改为下标为0的位置，如图3-2-1所示。</p><p><img src="https://raw.githubusercontent.com/Yojiaku/MarkdownPhotos/a99a04b1c807a382cb838a0152393470c1335f86/pic/queue-3-2-1.png" alt=""></p><p>事实上，我们换一种方式更容易理解循环队列，如图3-2-1所示。</p><p><img src="https://raw.githubusercontent.com/Yojiaku/MarkdownPhotos/a99a04b1c807a382cb838a0152393470c1335f86/pic/queue-3-2-2.png" alt=""></p><p>若我们这样定义循环队列时，我们会发现还有问题：<br>当队列没有元素，为空队列，此时rear=front，如图3-2-3所示；</p><p>当队列满时，此时rear=front，如图3-2-4所示。<br><img src="https://raw.githubusercontent.com/Yojiaku/MarkdownPhotos/a99a04b1c807a382cb838a0152393470c1335f86/pic/queue-3-2-3.png" alt=""></p><p>也就是说当rear=front时，我们并不能确定此时队列究竟是空队列还是满队列。此时有两种方法解决这一问题：</p><ol><li>设置一个标志变量flag，，当front=rear，且flag=0时为空队列，当front=rear。且flag=1是为满队列。</li><li>少用一个空间，也就是说当数组中还有一个空闲单元时，我们认为队列已经满了。如图3-2-5所示。而当队列空时，条件就是front=rear，即我们不允许图3-2-4所示的情况出现。</li></ol><p><img src="https://raw.githubusercontent.com/Yojiaku/MarkdownPhotos/a99a04b1c807a382cb838a0152393470c1335f86/pic/queue-3-2-5.png" alt=""></p><p>除了上面我们分析的一些情况，在具体的设计中，必须为循环队列设定一个最大队列的长度。具体的代码可参考下面。</p><figure class="hljs highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 队列的顺序存储结构(循环队列) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_QSIZE 5 <span class="comment">/* 最大队列长度+1 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  QElemType *base; <span class="comment">/* 初始化的动态分配存储空间 */</span></span><br><span class="line">  <span class="keyword">int</span> front; <span class="comment">/* 头指针，若队列不空，指向队列头元素 */</span></span><br><span class="line">  <span class="keyword">int</span> rear; <span class="comment">/* 尾指针，若队列不空，指向队列尾元素的下一个位置 */</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 循环队列的基本操作(9个) */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 构造一个空队列Q */</span></span><br><span class="line">  Q-&gt;base=<span class="built_in">malloc</span>(MAX_QSIZE*<span class="keyword">sizeof</span>(QElemType));</span><br><span class="line">  <span class="keyword">if</span>(!Q-&gt;base) <span class="comment">/* 存储分配失败 */</span></span><br><span class="line">    <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">  Q-&gt;front=Q-&gt;rear=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyQueue</span><span class="params">(SqQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 销毁队列Q，Q不再存在 */</span></span><br><span class="line">  <span class="keyword">if</span>(Q-&gt;base)</span><br><span class="line">    <span class="built_in">free</span>(Q-&gt;base);</span><br><span class="line">  Q-&gt;base=<span class="literal">NULL</span>;</span><br><span class="line">  Q-&gt;front=Q-&gt;rear=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearQueue</span><span class="params">(SqQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 将Q清为空队列 */</span></span><br><span class="line">  Q-&gt;front=Q-&gt;rear=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 若队列Q为空队列，则返回TRUE；否则返回FALSE */</span></span><br><span class="line">  <span class="keyword">if</span>(Q.front==Q.rear) <span class="comment">/* 队列空的标志 */</span></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 返回Q的元素个数，即队列的长度 */</span></span><br><span class="line">  <span class="keyword">return</span>(Q.rear-Q.front+MAX_QSIZE)%MAX_QSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">GetHead</span><span class="params">(SqQueue Q,QElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 若队列不空，则用e返回Q的队头元素，并返回OK；否则返回ERROR */</span></span><br><span class="line">  <span class="keyword">if</span>(Q.front==Q.rear) <span class="comment">/* 队列空 */</span></span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  *e=Q.base[Q.front];</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue *Q,QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 插入元素e为Q的新的队尾元素 */</span></span><br><span class="line">  <span class="keyword">if</span>((Q-&gt;rear+<span class="number">1</span>)%MAX_QSIZE==Q-&gt;front) <span class="comment">/* 队列满 */</span></span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  Q-&gt;base[Q-&gt;rear]=e;</span><br><span class="line">  Q-&gt;rear=(Q-&gt;rear+<span class="number">1</span>)%MAX_QSIZE;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(SqQueue *Q,QElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 若队列不空，则删除Q的队头元素，用e返回其值，并返回OK；否则返回ERROR */</span></span><br><span class="line">  <span class="keyword">if</span>(Q-&gt;front==Q-&gt;rear) <span class="comment">/* 队列空 */</span></span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  *e=Q-&gt;base[Q-&gt;front];</span><br><span class="line">  Q-&gt;front=(Q-&gt;front+<span class="number">1</span>)%MAX_QSIZE;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void QueueTraverse(SqQueue Q,void(*vi)(QElemType))</span><br><span class="line">&#123; <span class="comment">/* 从队头到队尾依次对队列Q中每个元素调用函数vi() */</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  i=Q.front;</span><br><span class="line">  <span class="keyword">while</span>(i!=Q.rear)</span><br><span class="line">  &#123;</span><br><span class="line">    vi(Q.base[i]);</span><br><span class="line">    i=(i+<span class="number">1</span>)%MAX_QSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-链式队列"><a href="#4-链式队列" class="headerlink" title="4.链式队列"></a>4.链式队列</h2><p>在队列的形成过程中，可以利用线性链表的原理，来生成一个队列。基于链表的队列，要动态动态创建和删除节点，效率较低，但是可以动态增长。一个链队列显然需要两个分别指示队头和队尾的指针才能唯一确定，，为了操作上的方便，我们将队头指针指向链队列的头结点，而队尾指针指向终端结点，如图4-1-1所示。</p><p><img src="https://raw.githubusercontent.com/Yojiaku/MarkdownPhotos/a99a04b1c807a382cb838a0152393470c1335f86/pic/queue-4-1-1.png" alt=""></p><p>空队列时，front和rear都指向头结点，如图4-1-2所示。</p><p><img src="https://raw.githubusercontent.com/Yojiaku/MarkdownPhotos/a99a04b1c807a382cb838a0152393470c1335f86/pic/queue-4-1-2.png" alt=""></p><p>入队操作就是在链表尾部插入结点，如图4-1-3所示。</p><p><img src="https://raw.githubusercontent.com/Yojiaku/MarkdownPhotos/a99a04b1c807a382cb838a0152393470c1335f86/pic/queue-4-1-3.png" alt=""></p><p>出队操作时，就是头结点的后继结点出队，将头结点的后继改为它后面的结点如图4-1-4所示。</p><p><img src="https://raw.githubusercontent.com/Yojiaku/MarkdownPhotos/a99a04b1c807a382cb838a0152393470c1335f86/pic/queue-4-1-4.png" alt=""></p><p>若链表除头结点只剩一个元素时，则需将rear指向头结点，如图4-1-5所示。</p><p><img src="https://raw.githubusercontent.com/Yojiaku/MarkdownPhotos/a99a04b1c807a382cb838a0152393470c1335f86/pic/queue-4-1-5.png" alt=""></p><p>链式队列使用链表作为基本数据结果，所以不存在伪溢出的问题，队列长度也没有限制。但插入和读取的时间代价较高</p><figure class="hljs highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 单链队列——队列的链式存储结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  QElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  QueuePtr front,rear; <span class="comment">/* 队头、队尾指针 */</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 链队列的基本操作(9个) */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 构造一个空队列Q */</span></span><br><span class="line">  Q-&gt;front=Q-&gt;rear=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">  <span class="keyword">if</span>(!Q-&gt;front)</span><br><span class="line">    <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">  Q-&gt;front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyQueue</span><span class="params">(LinkQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 销毁队列Q(无论空否均可) */</span></span><br><span class="line">  <span class="keyword">while</span>(Q-&gt;front)</span><br><span class="line">  &#123;</span><br><span class="line">    Q-&gt;rear=Q-&gt;front-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(Q-&gt;front);</span><br><span class="line">    Q-&gt;front=Q-&gt;rear;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearQueue</span><span class="params">(LinkQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 将Q清为空队列 */</span></span><br><span class="line">  QueuePtr p,q;</span><br><span class="line">  Q-&gt;rear=Q-&gt;front;</span><br><span class="line">  p=Q-&gt;front-&gt;next;</span><br><span class="line">  Q-&gt;front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">while</span>(p)</span><br><span class="line">  &#123;</span><br><span class="line">    q=p;</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">QueueEmpty</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 若Q为空队列，则返回TRUE，否则返回FALSE */</span></span><br><span class="line">  <span class="keyword">if</span>(Q.front-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 求队列的长度 */</span></span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  QueuePtr p;</span><br><span class="line">  p=Q.front;</span><br><span class="line">  <span class="keyword">while</span>(Q.rear!=p)</span><br><span class="line">  &#123;</span><br><span class="line">    i++;</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">GetHead_Q</span><span class="params">(LinkQueue Q,QElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 若队列不空，则用e返回Q的队头元素，并返回OK，否则返回ERROR */</span></span><br><span class="line">  QueuePtr p;</span><br><span class="line">  <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  p=Q.front-&gt;next;</span><br><span class="line">  *e=p-&gt;data;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue *Q,QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 插入元素e为Q的新的队尾元素 */</span></span><br><span class="line">  QueuePtr p= (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="comment">/* 存储分配失败 */</span></span><br><span class="line">    <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">  p-&gt;data=e;</span><br><span class="line">  p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">  Q-&gt;rear-&gt;next=p;</span><br><span class="line">  Q-&gt;rear=p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue *Q,QElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* 若队列不空，删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR */</span></span><br><span class="line">  QueuePtr p;</span><br><span class="line">  <span class="keyword">if</span>(Q-&gt;front==Q-&gt;rear)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  p=Q-&gt;front-&gt;next; <span class="comment">/* 指向头结点 */</span></span><br><span class="line">  *e=p-&gt;data;</span><br><span class="line">  Q-&gt;front=p-&gt;next; <span class="comment">/* 摘下头节点 */</span></span><br><span class="line">  <span class="keyword">if</span>(Q-&gt;rear==p)</span><br><span class="line">    Q-&gt;rear=Q-&gt;front;</span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void QueueTraverse(LinkQueue Q,void(*vi)(QElemType))</span><br><span class="line">&#123; <span class="comment">/* 从队头到队尾依次对队列Q中每个元素调用函数vi() */</span></span><br><span class="line">  QueuePtr p;</span><br><span class="line">  p=Q.front-&gt;next;</span><br><span class="line">  <span class="keyword">while</span>(p)</span><br><span class="line">  &#123;</span><br><span class="line">    vi(p-&gt;data);</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于循环队列与链队列的比较，可以从两方面来考虑：</p><ol><li><p>从时间上，其实它们的基本操作都是常数时间，即都为0(1)的，不过循环队列是事先申请好空间，使用期间不释放，而对于链队列，每次申请和释放结点也会存在一些时间开销，如果入队出队频繁，则两者还是有细微差异。</p></li><li><p>对于空间上来说，循环队列必须有一个固定的长度，所以就有了存储元素个数和空间浪费的问题。而链队列不存在这个问题，尽管它需要一个指针域，会产生一些空间上的开销，但也可以接受。所以在空间上，链队列更加灵活。</p></li><li>总的来说，在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列。</li></ol><p>用数组实现队列时，如果不移动，随着数据的不断读写，会出现假满队列的情况。即尾数组已满但头数组还是空的。循环队列也是一种数组，只是它在逻辑上把数组的头和尾相连，形成循环队列，当数组尾满的时候，要判断数组头是否为空，不为空继续存放数据，可以有效的利用资源。但是用循环队列有个小麻烦，不好判断数列是为空还是为满；<br>链队列就不存在上面的问题。“循环队列”最大优点就是节省空间和少分配空间，而链队列多了一点点地址存储开销。</p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>广度优先搜索算法</title>
      <link href="/2018/06/19/BFS/"/>
      <url>/2018/06/19/BFS/</url>
      <content type="html"><![CDATA[<p>广度优先搜索算法（Breadth First Search，又称宽度优先搜索算法）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法原型。Dijkstra单源最短路径算法和Prim最小生成树算法都采用了和广度优先搜索类似的思想。广度优先搜索算法属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。</p><h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>广度优先搜索遍历类似于树的按层次遍历。</p><p>对于无向连通图，广度优先搜索是从图的某个顶点V0出发，在访问V0之后，依次搜索访问V0的各个未被访问过的邻接点W1，W2，…。然后顺序搜索访问W1的各未被访问过的邻接点，W2的各未被访问过的邻接点，……即从v0开始，由近至远，按层次依次访问与V0有路径相通且路径长度分别为1，2，……的顶点，直至连通图中所有顶点都被访问一次。</p><p>广度优先搜索的顺序不是唯一的。具体描述如下：</p><ol><li>从图中的某个顶点V出发，访问之；并将其访问标志置为已被访问，即visited[i]=1；</li><li>依次访问顶点V的各个未被访问过的邻接点，将V的全部邻接点都访问到；</li><li>分别从这些邻接点出发，依次访问它们的未被访问过的邻接点，并使“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接点”被访问，直到图中所有已被访问过的顶点的邻接点都被访问到。</li></ol><p>依此类推，直到图中所有顶点都被访问完为止 。</p><p>广度优先搜索在搜索访问一层时，需要记住已被访问的顶点，以便在访问下层顶点时，从已被访问的顶点出发搜索访问其邻接点。所以在广度优先搜索中需要设置一个队列Queue，使已被访问的顶点顺序由队尾进入队列。在搜索访问下层顶点时，先从队首取出一个已被访问的上层顶点，再从该顶点出发搜索访问它的各个邻接点。</p><h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><p>一般来说，BFS使用队列来实现。在存储数据时，除了需要存储当前状态外，还需要存储当前状态的父状态以及父状态转换过来所执行的操作。</p><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/doc/BFS/pic/bfs-2.png" alt="image"></p><ul><li>初始状态入队Op :=1；</li><li>对队首状态进行操作Op，得到新状态；</li><li>检查此状态是否出现过：如果此状态为目标状态，则输出；如果所有操作都已完成，则队首出列，否则Op:=Op+1。<h2 id="广度优先搜索算法描述"><a href="#广度优先搜索算法描述" class="headerlink" title="广度优先搜索算法描述"></a>广度优先搜索算法描述</h2></li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Program Bfs;</span><br><span class="line">  初始化，初始状态存入OPEN表(即队列);</span><br><span class="line">  队列首指针head:=0;尾指针tail:=1;</span><br><span class="line">  repeat</span><br><span class="line">    指针head后移一位，指向待扩展结点;</span><br><span class="line">    for l=1 to max do  &#123;max为产生子结点的规则数&#125;</span><br><span class="line">    begin</span><br><span class="line">     if 子结点符合条件 then</span><br><span class="line">      begin</span><br><span class="line">       tail指针增1，把新结点存入队尾;</span><br><span class="line">       if新结点与原已产生结点重复then删去该结点(取消入队，tail减1)</span><br><span class="line">        else</span><br><span class="line">         if新结点是目标结点then输出并退出;</span><br><span class="line">       end;</span><br><span class="line">     end;</span><br><span class="line">until(head&gt;=tail);&#123;队列空&#125;</span><br></pre></td></tr></table></figure><h1 id="算法实例"><a href="#算法实例" class="headerlink" title="算法实例"></a>算法实例</h1><ol><li>如图所示，初始化：</li></ol><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/doc/BFS/pic/bfs-3.png" alt="image"></p><ol start="2"><li>在List中选择结点i=1</li></ol><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/doc/BFS/pic/bfs-4.png" alt="image"></p><ol start="3"><li>如果结点i和一条可进入弧关联，则如图所示：</li></ol><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/doc/BFS/pic/bfs-5.png" alt="image"></p><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/doc/BFS/pic/bfs-6.png" alt="image"></p><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/doc/BFS/pic/bfs-7.png" alt="image"></p><ol start="4"><li>当结点i没有与可进入弧关联之后，则删除结点i，如图所示：</li></ol><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/doc/BFS/pic/bfs-8.png" alt="image"></p><ol start="5"><li>再次选择结点i=2，如图所示</li></ol><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/doc/BFS/pic/bfs-9.png" alt="image"></p><ol start="6"><li>结点i有与可进入弧关联，如图所示：</li></ol><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/doc/BFS/pic/bfs-10.png" alt="image"></p><ol start="7"><li>当结点i没有与可进入弧关联之后，则删除结点i（i=2），如图所示：</li></ol><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/doc/BFS/pic/bfs-11.png" alt="image"></p><ol start="8"><li>把List上的第一个结点变成结点i，则结点i=5</li></ol><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/doc/BFS/pic/bfs-12.png" alt="image"></p><ol start="9"><li>结点i有与可进入弧关联，如图所示：</li></ol><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/doc/BFS/pic/bfs-13.png" alt="image"></p><ol start="10"><li>当结点i没有与可进入弧关联之后，则删除结点i（i=5），如图所示：</li></ol><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/doc/BFS/pic/bfs-14.png" alt="image"></p><ol start="11"><li>把List上的第一个结点变成结点i，则结点i=3；结点i=3没有与可进入弧关联，则删除结点i（i=3），如图所示：</li></ol><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/doc/BFS/pic/bfs-15.png" alt="image"></p><ol start="12"><li>把List上的第一个结点变成结点i，则结点i=4</li></ol><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/doc/BFS/pic/bfs-16.png" alt="image"></p><ol start="13"><li>当结点i没有与可进入弧关联之后，则删除结点i（i=4），如图所示：</li></ol><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/doc/BFS/pic/bfs-17.png" alt="image"></p><ol start="14"><li>把List上的第一个结点变成结点i，则结点i=6</li></ol><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/doc/BFS/pic/bfs-18.png" alt="image"></p><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/doc/BFS/pic/bfs-19.png" alt="image"></p><ol start="15"><li>当结点i没有与可进入弧关联之后，删除结点i（i=6）；剩下的结点8、7、9均没有与可进入弧关联，则从List中删除这些结点</li></ol><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/doc/BFS/pic/bfs-20.png" alt="image"></p><h1 id="广度优先搜索算法的特性"><a href="#广度优先搜索算法的特性" class="headerlink" title="广度优先搜索算法的特性"></a>广度优先搜索算法的特性</h1><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>因为所有节点都必须被储存，因此BFS的空间复杂度为 O(|V| + |E|)，其中 |V|是节点的数目，而|E|是图中边的数目。</p><blockquote><p>另一种说法称BFS的空间复杂度为O(B)，其中B是最大分支系数，而M是树的最长路径长度。由于对空间的大量需求，因此BFS并不适合解非常大的问题。</p></blockquote><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>最差情形下，BFS必须寻找所有到可能节点的所有路径，因此其时间复杂度为 O(|V| + |E|)，其中 |V|是节点的数目，而 |E| 是图中边的数目。</p><h3 id="完全性"><a href="#完全性" class="headerlink" title="完全性"></a>完全性</h3><p>广度优先搜索算法具有完全性。这意指无论图形的种类如何，只要目标存在，则BFS一定会找到。然而，若目标不存在，且图为无限大，则BFS将不收敛（不会结束）。</p><h4 id="最佳解"><a href="#最佳解" class="headerlink" title="最佳解"></a>最佳解</h4><p>若所有边的长度相等，广度优先搜索算法是最佳解——亦即它找到的第一个解，距离根节点的边数目一定最少；但对一般的图来说，BFS并不一定回传最佳解。这是因为当图形为加权图（亦即各边长度不同）时，BFS仍然回传从根节点开始，经过边数目最少的解；而这个解距离根节点的距离不一定最短。这个问题可以使用考虑各边权值，BFS的改良算法成本一致搜寻法（en:uniform-cost search）来解决。然而，若非加权图形，则所有边的长度相等，BFS就能找到最近的最佳解。</p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深度优先搜索</title>
      <link href="/2018/06/18/DFS/"/>
      <url>/2018/06/18/DFS/</url>
      <content type="html"><![CDATA[<p>深度优先搜索属于图算法的一种，英文缩写为DFS即Depth First Search。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。深度优先搜索的搜索过程类似树的先序遍历，也叫回溯法。</p><h1 id="深度优先搜索算法的基本思想"><a href="#深度优先搜索算法的基本思想" class="headerlink" title="深度优先搜索算法的基本思想"></a>深度优先搜索算法的基本思想</h1><p>如算法名称那样，深度优先搜索所遵循的搜索策略是尽可能“深”地搜索树。在深度优先搜索中，对于当前发现的结点，如果它还存在以此结点为起点而未探测到的边，就沿此边继续搜索下去，若当结点的所有边都己被探寻过。将回溯到当前结点的父结点，继续上述的搜索过程直到所有结点都被探寻为止。</p><p>深度优先搜索在树的遍历中也称作树的先序遍历。对于树而言，深度优先搜索的思路可以描述为：</p><ol><li>将根结点置为出发结点。</li><li>访问该出发结点。</li><li>依次将出发结点的子结点置为新的出发结点．进行深度优先遍历(执行2）。</li><li>退回上一层的出发结点。</li></ol><p>深度优先搜索的具体编程可用递归过程或模拟递归来实现。他们各有各的优缺点。递归形式的程序符合思维习惯。编写起来较容易。但由于递归过程的调用借助较慢的系统栈空间传递参数和存放局部变量，故降低了执行效率。模拟递归使用数组存放堆栈数据，在管理指针和每层选择决策上不如递归容易编程。但一旦熟悉了程序框架，调试起来要比递归程序方便，由于数组一般使用静态内存。访问速度较快，执行效率也较高。</p><p>为了在遍历过程中区分顶点是否被访问，往往可以引入一个数组，如以mark[1..n]作为标记。数组的元素取0和1，初值为0。当节点被访问时，与节点相应得数组元素为1，每次访问节点时，都得先检查它的标记值，找0值得节点访问，并深度继续。深度大的先得到扩展，具有“后产生先扩展”的特点，因此在数据结构上采用堆栈来存储（新节点入栈，节点不能扩展时，栈定出栈）。</p><h1 id="深度优先搜索算法的特点"><a href="#深度优先搜索算法的特点" class="headerlink" title="深度优先搜索算法的特点"></a>深度优先搜索算法的特点</h1><ol><li>由于深度搜索过程中有保留已扩展节点，则不致于重复构造不必要的子树系统。</li><li>深度优先搜索并不是以最快的方式搜索到解，因为若目标节点在第i层的某处，必须等到该节点左边所有子树系统搜索完毕之后，才会访问到该节点，因此，搜索效率还取决于目标节点在解答树中的位置。</li><li>由于要存储所有已被扩展节点，所以需要的内存空间往往比较大。</li><li>深度优先搜索所求得的是仅仅是目前第一条从起点至目标节点的树枝路径，而不是所有通向目标节点的树枝节点的路径中最短的路径。</li><li>适用范围：适用于求解一条从初始节点至目标节点的可能路径的试题。若要存储所有解答路径，可以再建立其它空间，用来存储每个已求得的解。若要求得最优解，必须记下达到目前目标的路径和相应的路程值，并与前面已记录的值进行比较，保留其中最优解，等全部搜索完成后，把保留的最优解输出。</li></ol><h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><h2 id="算法数据结构描述："><a href="#算法数据结构描述：" class="headerlink" title="算法数据结构描述："></a>算法数据结构描述：</h2><p>深度优先搜索时，最关键的是结点扩展（OPEN）表的生成，它是一个栈，用于存放目前搜索到待扩展的结点，当结点到达深度界限或结点不能再扩展时，栈顶结点出栈，放入CLOSE表（存放已扩展节点），继续生成新的结点入栈OPEN表，直到搜索到目标结点或OPEN栈空为止。具体算法如下：</p><ul><li>把起始结点S放到非扩展结点OPEN表中(后进先出的堆栈)，如果此结点为一目标结点，则得到一个解。</li><li>如果OPEN为一空表，则搜索失败退出。</li><li>取OPEN表最前面(栈顶)的结点，并把它放入CLOSED的扩展结点表中，并冠以顺序编号n。</li><li>如果结点n的深度等于最大深度，则转向第二步。</li><li>否则，扩展结点n，产生其全部子结点，把它们放入OPEN表的前头(入栈)，并配上指向的n返回指针；如果没有后裔，则转向第二步。</li><li>如果后继结点中有任一个为目标结点，则求得一个解，成功退出；否则，转向第二步。</li></ul><h2 id="算法程序描述："><a href="#算法程序描述：" class="headerlink" title="算法程序描述："></a>算法程序描述：</h2><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">递归过程为：</span><br><span class="line"> Procedure DEF-GO(step)</span><br><span class="line"> for i:=1 to max do</span><br><span class="line">   if 子结点符合条件 then</span><br><span class="line">     产生新的子结点入栈;</span><br><span class="line">       if 子结点是目标结点 then 输出</span><br><span class="line">         else DEF-GO(step+1);</span><br><span class="line">           栈顶结点出栈;</span><br><span class="line">        endif;</span><br><span class="line">    enddo;</span><br><span class="line"></span><br><span class="line">主程序为：</span><br><span class="line"> Program DFS;</span><br><span class="line">   初始状态入栈;</span><br><span class="line">   DEF-GO(1);</span><br></pre></td></tr></table></figure><h1 id="深度优先搜索算法与广度优先搜索算法的对比图解"><a href="#深度优先搜索算法与广度优先搜索算法的对比图解" class="headerlink" title="深度优先搜索算法与广度优先搜索算法的对比图解"></a>深度优先搜索算法与广度优先搜索算法的对比图解</h1><h2 id="无向图的深度优先搜索"><a href="#无向图的深度优先搜索" class="headerlink" title="无向图的深度优先搜索"></a>无向图的深度优先搜索</h2><p>下面以无向图为例，来对深度优先搜索进行演示。</p><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/doc/DFS/pic/dfs-1.jpg" alt="image"></p><p>对上面的图G1进行深度优先遍历，从顶点A开始。</p><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/doc/DFS/pic/dfs-2.jpg" alt="image"></p><ul><li>第1步：访问A。</li><li>第2步：访问(A的邻接点)C。在第1步访问A之后，接下来应该访问的是A的邻接点，即”C,D,F”中的一个。但在本文的实现中，顶点ABCDEFG是按照顺序存储，C在”D和F”的前面，因此，先访问C。</li><li>第3步：访问(C的邻接点)B。在第2步访问C之后，接下来应该访问C的邻接点，即”B和D”中一个(A已经被访问过，就不算在内)。而由于B在D之前，先访问B。</li><li>第4步：访问(C的邻接点)D。在第3步访问了C的邻接点B之后，B没有未被访问的邻接点；因此，返回到访问C的另一个邻接点D。</li><li>第5步：访问(A的邻接点)F。前面已经访问了A，并且访问完了”A的邻接点B的所有邻接点(包括递归的邻接点在内)”；因此，此时返回到访问A的另一个邻接点F。</li><li>第6步：访问(F的邻接点)G。</li><li>第7步：访问(G的邻接点)E。</li></ul><p>因此访问顺序是：<strong>A -&gt; C -&gt; B -&gt; D -&gt; F -&gt; G -&gt; E</strong></p><h2 id="有向图的深度优先搜索"><a href="#有向图的深度优先搜索" class="headerlink" title="有向图的深度优先搜索"></a>有向图的深度优先搜索</h2><p>下面以有向图为例，来对深度优先搜索进行演示。</p><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/doc/DFS/pic/dfs-3.jpg" alt="image"></p><p>对上面的图G2进行深度优先遍历，从顶点A开始。</p><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/doc/DFS/pic/dfs-4.jpg" alt="image"></p><ul><li>第1步：访问A。</li><li>第2步：访问B。在访问了A之后，接下来应该访问的是A的出边的另一个顶点，即顶点B。</li><li>第3步：访问C。在访问了B之后，接下来应该访问的是B的出边的另一个顶点，即顶点C,E,F。在本文实现的图中，顶点ABCDEFG按照顺序存储，因此先访问C。</li><li>第4步：访问E。接下来访问C的出边的另一个顶点，即顶点E。</li><li>第5步：访问D。接下来访问E的出边的另一个顶点，即顶点B,D。顶点B已经被访问过，因此访问顶点D。</li><li>第6步：访问F。接下应该回溯”访问A的出边的另一个顶点F”。</li><li>第7步：访问G。</li></ul><p>因此访问顺序是：<strong>A -&gt; B -&gt; C -&gt; E -&gt; D -&gt; F -&gt; G</strong></p><h2 id="无向图的广度优先搜索"><a href="#无向图的广度优先搜索" class="headerlink" title="无向图的广度优先搜索"></a>无向图的广度优先搜索</h2><p>以无向图为例，来对广度优先搜索进行演示。还是图G1为例进行说明。</p><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/doc/DFS/pic/dfs-1.jpg" alt="image"></p><p>对上面的图G1进行深度优先遍历，从顶点A开始。</p><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/doc/DFS/pic/dfs-5.jpg" alt="image"></p><ul><li>第1步：访问A。</li><li>第2步：依次访问C,D,F。在访问了A之后，接下来访问A的邻接点。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，C在”D和F”的前面，因此，先访问C。再访问完C之后，再依次访问D,F。</li><li>第3步：依次访问B,G。在第2步访问完C,D,F之后，再依次访问它们的邻接点。首先访问C的邻接点B，再访问F的邻接点G。</li><li>第4步：访问E。在第3步访问完B,G之后，再依次访问它们的邻接点。只有G有邻接点E，因此访问G的邻接点E。</li></ul><p>因此访问顺序是：<strong>A -&gt; C -&gt; D -&gt; F -&gt; B -&gt; G -&gt; E</strong></p><h2 id="有向图的广度优先搜索"><a href="#有向图的广度优先搜索" class="headerlink" title="有向图的广度优先搜索"></a>有向图的广度优先搜索</h2><p>以有向图为例，来对广度优先搜索进行演示。还是以图G2为例进行说明。</p><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/doc/DFS/pic/dfs-3.jpg" alt="image"></p><p>对上面的图G2进行深度优先遍历，从顶点A开始。</p><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/zhuHuiXia/doc/DFS/pic/dfs-6.jpg" alt="image"></p><ul><li>第1步：访问A。</li><li>第2步：访问B。</li><li>第3步：依次访问C,E,F。在访问了B之后，接下来访问B的出边的另一个顶点，即C,E,F。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，因此会先访问C，再依次访问E,F。</li><li>第4步：依次访问D,G。在访问完C,E,F之后，再依次访问它们的出边的另一个顶点。还是按照C,E,F的顺序访问，C的已经全部访问过了，那么就只剩下E,F；先访问E的邻接点D，再访问F的邻接点G。</li></ul><p>因此访问顺序是：<strong>A -&gt; B -&gt; C -&gt; E -&gt; F -&gt; D -&gt; G</strong></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>DFS 的时间和空间分析根据其应用领域而有所不同。在理论计算机科学中，DFS通常用于遍历整个图，并且其时间Θ（| V | + | E |），[4]在图的大小上是线性的。在这些应用程序中，它还使用空间O（|V|）在最坏的情况下存储当前搜索路径上的顶点堆栈以及已经访问的顶点集合。因此，在这种情况下，时间和空间范围与广度优先搜索相同，并且选择使用这两种算法中的哪一种更少取决于它们的复杂性，更多取决于两种算法产生的顶点排序的不同性质。</p><p>对于与特定域相关的DFS应用，例如在人工智能或网络爬行中搜索解决方案，要遍历的图通常太大而无法完整访问或无限（DFS可能会因无终止而受到影响）。在这种情况下，搜索只能进行到有限的深度;由于资源有限（如内存或磁盘空间），通常不会使用数据结构来跟踪所有以前访问过的顶点的集合。当搜索被执行到有限的深度时，时间仍然是线性扩展的顶点和边的数量（尽管这个数与整个图的大小不一样，因为一些顶点可能被搜索多次，其他的根本没有），但是这种DFS变体的空间复杂度仅与深度限制成正比，因此比使用广度优先搜索搜索相同深度所需的空间小得多。对于这样的应用程序，DFS也更适合用于选择可能分支的启发式方法。如果事先并不知道适当的深度限制，迭代加深深度优先搜索重复应用DFS以增加一系列限制。在人工智能分析模式中，在分支因子大于1的情况下，由于每层级的节点数量的几何增长，迭代加深使得运行时间仅增加一个常数因子，其中正确的深度限制是已知的。</p><p>DFS也可用于收集图形节点的样本。然而，不完整的DFS，类似于不完整的BFS，被偏压向高的节点度。</p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>桶排序 (Bucket sort)</title>
      <link href="/2018/06/17/BucketSort/"/>
      <url>/2018/06/17/BucketSort/</url>
      <content type="html"><![CDATA[<p>桶排序 (Bucket sort)或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。<br>桶排序以下列程序进行：</p><ol><li>设置一个定量的数组当作空桶子。</li><li>寻访序列，并且把项目一个一个放到对应的桶子去。</li><li>对每个不是空的桶子进行排序。</li><li>从不是空的桶子里把项目再放回原来的序列中。</li></ol><h2 id="代价"><a href="#代价" class="headerlink" title="代价"></a>代价</h2><p>桶排序利用函数的映射关系，减少了几乎所有的比较工作。实际上，桶排序的f(k)值的计算，其作用就相当于快排中划分，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做先进的比较排序即可。<br>对N个关键字进行桶排序的时间复杂度分为两个部分：<br>:<br>(1) 循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。<br>(2) 利用先进的比较排序算法对每个桶内的所有数据进行排序，其时间复杂度为 ∑ O(Ni*logNi) 。其中Ni 为第i个桶的数据量。</p><p>很显然，第(2)部分是桶排序性能好坏的决定因素。尽量减少桶内数据的数量是提高效率的唯一办法(因为基于比较排序的最好平均时间复杂度只能达到O(N*logN)了)。因此，我们需要尽量做到下面两点：<br>:<br>(1) 映射函数f(k)能够将N个数据平均的分配到M个桶中，这样每个桶就有[N/M]个数据量。<br>(2) 尽量的增大桶的数量。极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的“比较”排序操作。</p><p>当然，做到这一点很不容易，数据量巨大的情况下，f(k)函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。</p><p>对于N个待排数据，M个桶，平均每个桶[N/M]个数据的桶排序平均时间复杂度为：<br>O(N)+O(M<em>(N/M)</em>log(N/M))=O(N+N<em>(logN-logM))=O(N+N</em>logN-N*logM)<br>当N=M时，即极限情况下每个桶只有一个数据时。桶排序的最好效率能够达到O(N)。</p><p><strong>总结</strong>：桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。当然桶排序的空间复杂度为O(N+M)，如果输入数据非常庞大，而桶的数量也非常多，则空间代价无疑是昂贵的。此外，桶排序是稳定的。</p><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function bucket-sort(array, n) is</span><br><span class="line">  buckets ← new array of n empty lists</span><br><span class="line">  for i = 0 to (length(array)-1) do</span><br><span class="line">    insert array[i] into buckets[msbits(array[i], k)]</span><br><span class="line">  for i = 0 to n - 1 do</span><br><span class="line">    next-sort(buckets[i])</span><br><span class="line">  return the concatenation of buckets[0], ..., buckets[n-1]</span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>###C++<br>假设数据分布在[0，100)之间，每个桶内部用链表表示，在数据入桶的同时插入排序。然后把各个桶中的数据合并。<br><figure class="hljs highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BUCKET_NUM = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">explicit ListNode(int i=0):mData(i),mNext(NULL)&#123;&#125;</span><br><span class="line">ListNode* mNext;</span><br><span class="line"><span class="keyword">int</span> mData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">insert</span><span class="params">(ListNode* head,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">ListNode dummyNode;</span><br><span class="line">ListNode *newNode = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">ListNode *pre,*curr;</span><br><span class="line">dummyNode.mNext = head;</span><br><span class="line">pre = &amp;dummyNode;</span><br><span class="line">curr = head;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">NULL</span>!=curr &amp;&amp; curr-&gt;mData&lt;=val)&#123;</span><br><span class="line">pre = curr;</span><br><span class="line">curr = curr-&gt;mNext;</span><br><span class="line">&#125;</span><br><span class="line">newNode-&gt;mNext = curr;</span><br><span class="line">pre-&gt;mNext = newNode;</span><br><span class="line"><span class="keyword">return</span> dummyNode.mNext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode *head1,ListNode *head2)</span></span>&#123;</span><br><span class="line">ListNode dummyNode;</span><br><span class="line">ListNode *dummy = &amp;dummyNode;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">NULL</span>!=head1 &amp;&amp; <span class="literal">NULL</span>!=head2)&#123;</span><br><span class="line"><span class="keyword">if</span>(head1-&gt;mData &lt;= head2-&gt;mData)&#123;</span><br><span class="line">dummy-&gt;mNext = head1;</span><br><span class="line">head1 = head1-&gt;mNext;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">dummy-&gt;mNext = head2;</span><br><span class="line">head2 = head2-&gt;mNext;</span><br><span class="line">&#125;</span><br><span class="line">dummy = dummy-&gt;mNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span>!=head1) dummy-&gt;mNext = head1;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span>!=head2) dummy-&gt;mNext = head2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dummyNode.mNext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BucketSort</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;ListNode*&gt; buckets(BUCKET_NUM,(ListNode*)(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line"><span class="keyword">int</span> index = arr[i]/BUCKET_NUM;</span><br><span class="line">ListNode *head = buckets.at(index);</span><br><span class="line">buckets.at(index) = insert(head,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">ListNode *head = buckets.at(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;BUCKET_NUM;++i)&#123;</span><br><span class="line">head = Merge(head,buckets.at(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">arr[i] = head-&gt;mData;</span><br><span class="line">head = head-&gt;mNext;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> a 待排序数组元素</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> step 步长(桶的宽度/区间),具体长度可根据情况设定</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 桶的位置/索引</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> a/step;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> max=arr[<span class="number">0</span>],min=arr[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> a:arr) &#123;</span><br><span class="line">           <span class="keyword">if</span> (max&lt;a)</span><br><span class="line">               max=a;</span><br><span class="line">           <span class="keyword">if</span> (min&gt;a)</span><br><span class="line">               min=a;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//该值也可根据实际情况选择</span></span><br><span class="line">       <span class="keyword">int</span> bucketNum=max/<span class="number">10</span>-min/<span class="number">10</span>+<span class="number">1</span>;</span><br><span class="line">       List buckList=<span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">       <span class="comment">//create bucket</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=bucketNum;i++)&#123;</span><br><span class="line">           buckList.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//push into the bucket</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> index=indexFor(arr[i],<span class="number">10</span>);</span><br><span class="line">           ((ArrayList&lt;Integer&gt;)buckList.get(index)).add(arr[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       ArrayList&lt;Integer&gt; bucket=<span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bucketNum;i++)&#123;</span><br><span class="line">           bucket=(ArrayList&lt;Integer&gt;)buckList.get(i);</span><br><span class="line">           insertSort(bucket);</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> k : bucket) &#123;</span><br><span class="line">               arr[index++]=k;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//把桶内元素插入排序</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(List&lt;Integer&gt; bucket)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;bucket.size();i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> temp=bucket.get(i);</span><br><span class="line">           <span class="keyword">int</span> j=i-<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">for</span> (; j&gt;=<span class="number">0</span> &amp;&amp; bucket.get(j)&gt;temp;j--)&#123;</span><br><span class="line">               bucket.set(j+<span class="number">1</span>,bucket.get(j));</span><br><span class="line">           &#125;</span><br><span class="line">           bucket.set(j+<span class="number">1</span>,temp);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h5><ol><li><a href="https://zh.wikipedia.org/wiki/%E6%A1%B6%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">维基百科-桶排序</a></li><li><a href="https://baike.baidu.com/item/%E6%A1%B6%E6%8E%92%E5%BA%8F/4973777?fr=aladdin" target="_blank" rel="noopener">百度百科-桶排序</a></li></ol>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分块查找（Blocking Search）</title>
      <link href="/2018/06/16/Blocking_Search/"/>
      <url>/2018/06/16/Blocking_Search/</url>
      <content type="html"><![CDATA[<p>分块查找，又称索引顺序查找。它是一种性能介于顺序查找和二分查找之间的改进方法。它是为了找到 <strong>二分查找的高效但需要顺序存储</strong> 和 <strong>顺序查找可以解决元素动态变化但效率低下</strong> 之间更平衡的方法。</p><h2 id="1-基本思想"><a href="#1-基本思想" class="headerlink" title="1.基本思想"></a>1.基本思想</h2><p>①把线性表分成若干块，每块包含若干个元素<br>②块内无序，块间有序。<br>③建立一个索引表，把每块中的最大关键字值和每块的第一个元素在表中的位置和最后一个元素在表中的位置存放在索引项中。<br>④先确定待查数据元素所在的块，然后再块内顺序查找</p><h2 id="2-算法分析"><a href="#2-算法分析" class="headerlink" title="2.算法分析"></a>2.算法分析</h2><h3 id="2-1时间复杂度"><a href="#2-1时间复杂度" class="headerlink" title="2.1时间复杂度"></a>2.1时间复杂度</h3><p>分块查找算法的效率介于顺序查找和二分查找之间。</p><blockquote><p>时间复杂度为O(n)~O(log2n)</p></blockquote><h3 id="2-2平均查找长度ASL"><a href="#2-2平均查找长度ASL" class="headerlink" title="2.2平均查找长度ASL"></a>2.2平均查找长度ASL</h3><p>分块查找的平均查找长度由两部分组成，一个是对索引表进行查找的平均查找长度，一个是对快内节点进行查找的平均查找长度。<br>线性表中共有n个节点，分成大小相等的b块，每块有s=n/b个节点。</p><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/yuanJiaLi/pic/Blocking_Search_ASL.png" alt=""></p><h3 id="2-3存储结构"><a href="#2-3存储结构" class="headerlink" title="2.3存储结构"></a>2.3存储结构</h3><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/algorithmDocument/yuanJiaLi/pic/Blocking_Search_Structure.png" alt=""></p><h2 id="3-分块查找优缺点"><a href="#3-分块查找优缺点" class="headerlink" title="3.分块查找优缺点"></a>3.分块查找优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>在表中插入或删除一个记录时，只要找到该记录所属的块，然后在该块内进行插入和删除运算即可。由于块内记录的存放是任意的，所以插入或删除记录无需移动大量记录。</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>需要将待查表分块排序，并且要增加一个存储空间用来存储索引表。</p><h2 id="4-C语言实现"><a href="#4-C语言实现" class="headerlink" title="4.C语言实现"></a>4.C语言实现</h2><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">index</span> &#123;</span>  <span class="comment">//定义块的结构</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">&#125; newIndex[<span class="number">3</span>];   <span class="comment">//定义结构体数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> a[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a,<span class="keyword">const</span> <span class="keyword">void</span>* b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*(struct index*)a).key&gt;(*(struct index*)b).key?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j=<span class="number">-1</span>, k, key;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">33</span>,<span class="number">42</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">24</span>,<span class="number">48</span>, <span class="number">22</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">20</span>,  <span class="number">60</span>,<span class="number">58</span>,<span class="number">74</span>,<span class="number">49</span>,<span class="number">86</span>,<span class="number">53</span>&#125;;</span><br><span class="line">    <span class="comment">//确认模块的起始值和最大值</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">        newIndex[i].start = j+<span class="number">1</span>;  <span class="comment">//确定每个块范围的起始值</span></span><br><span class="line">        j += <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=newIndex[i].start; k&lt;=j; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newIndex[i].key&lt;a[k]) &#123;</span><br><span class="line">                newIndex[i].key=a[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对结构体按照 key 值进行排序</span></span><br><span class="line">    qsort(newIndex,<span class="number">3</span>, <span class="keyword">sizeof</span>(newIndex[<span class="number">0</span>]), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入要查询的数，并调用函数进行查找</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入您想要查找的数：\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;key);</span><br><span class="line">    k = search(key, a);</span><br><span class="line">    <span class="comment">//输出查找的结果</span></span><br><span class="line">    <span class="keyword">if</span> (k&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"查找成功！您要找的数在数组中的位置是：%d\n"</span>,k+<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"查找失败！您要找的数不在数组中。\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, startValue;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="number">3</span> &amp;&amp; key&gt;newIndex[i].key) &#123; <span class="comment">//确定在哪个块中，遍历每个块，确定key在哪个块中</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i&gt;=<span class="number">3</span>) &#123;  <span class="comment">//大于分得的块数，则返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    startValue = newIndex[i].start;  <span class="comment">//startValue等于块范围的起始值</span></span><br><span class="line">    <span class="keyword">while</span> (startValue &lt;= startValue+<span class="number">5</span> &amp;&amp; a[startValue]!=key)</span><br><span class="line">    &#123;</span><br><span class="line">        startValue++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (startValue&gt;startValue+<span class="number">5</span>) &#123;  <span class="comment">//如果大于块范围的结束值，则说明没有要查找的数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> startValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h6><p>1.百度百科——分块查找</p><p>2.<a href="http://blog.csdn.net/u013036274/article/details/49176027" title="【数据结构】静态查找之分块查找" target="_blank" rel="noopener">【数据结构】静态查找之分块查找</a></p><p>3.<a href="http://data.biancheng.net/view/56.html" target="_blank" rel="noopener">分块查找算法（索引顺序查找）及C语言实现</a></p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Prim最小生成树算法</title>
      <link href="/2018/06/15/Prim_Minimum_Spanning_Tree/"/>
      <url>/2018/06/15/Prim_Minimum_Spanning_Tree/</url>
      <content type="html"><![CDATA[<p>Prim最小生成树算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点，且其所有边的权值之和亦为最小。该算法于1930年由捷克数学家沃伊捷赫·亚尔尼克发现；并在1957年由美国计算机科学家罗伯特·普里姆独立发现；1959年，艾兹格·迪科斯彻再次发现了该算法。因此，在某些场合，普里姆算法又被称为DJP算法、亚尔尼克算法或普里姆－亚尔尼克算法。</p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>从单一顶点开始，普里姆算法按照以下步骤逐步扩大树中所含顶点的数目，直到遍及连通图的所有顶点。</p><ol><li>输入：一个加权连通图，其中顶点集合为V，边集合为E；</li><li>初始化：Vnew = {x}，其中x为集合V中的任一节点（起始点），Enew = {}；</li><li>重复下列操作，直到Vnew = V：<br>在集合E中选取权值最小的边（u, v），其中u为集合Vnew中的元素，而v则是V中没有加入Vnew的顶点（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；<br>将v加入集合Vnew中，将（u, v）加入集合Enew中；</li><li>输出：使用集合Vnew和Enew来描述所得到的最小生成树。<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2>|最小边、权的数据结构|时间复杂度（总计）|<br>|:—:|:—:|<br>|邻接矩阵、搜索|O(V²)|<br>|二叉堆（后文伪代码中使用的数据结构）、邻接表|O((V + E) log(V)) = O(E log(V))|<br>|斐波那契堆、邻接表|O(E + V log(V))|<h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2>已知图G的边数量为numEdge, 顶点数量为numVert, prim生成的树为T0, 最小生成树（MST）为Tmin<br>则有，cost(Tmin)&lt;=cost(T0)<br>设： T0 的 numVert-1 条边按照权重由小到大排列依次为：ek1, ek2, ek3, …, ekn<br>Tmin 的 numVert-1 条边按照权重由小到大排列依次为：eg1, eg2, eg3, …, egn<br>其中n=numVert-1<br>两棵树的边从小到大权重比较，设第一个属于 T0 但不属于 Tmin 的边为 ed1, 连接该边的两个顶点为 (vs, ve1)<br>同时存在第一个属于 Tmin 但不属于 T0 的边为 ed2, 连接该边的两个顶点为 (vs, ve2)。<br>两个边的起点相同。由Prim算法性质可知，w(ed2) &gt;= w(ed1)<br>此时，在 Tmin 中删除 ed2 ，添加 ed1，边的数量和顶点数量均不变，且不存在环，因此得到新的生成树Tnew,且cost(Tmin)&gt;=cost(Tnew)<br>又因为 Tmin 是MST 所以 cost(Tmin)=cost(Tnew)。<br>以此类推，cost(Tmin)=cost(T0)<br>T0是最小生成树， 得证.</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//来源：严蔚敏 吴伟民《数据结构(C语言版)》</span><br><span class="line">void MiniSpanTree_PRIM (MGraph G, VertexType u) &#123;</span><br><span class="line">    /*  用普利姆算法從第u個頂點出發構造網G 的最小生成樹T,輸出T的各條邊。</span><br><span class="line">        記錄從頂點集U到V-U的代價最小的邊的輔助數組定義：</span><br><span class="line">        struct</span><br><span class="line">        &#123;</span><br><span class="line">            VertexType adjvex;</span><br><span class="line">            VRtype lowcost;</span><br><span class="line">        &#125;closedge[MAX_VERTEX_NUM];</span><br><span class="line">    */</span><br><span class="line">    k = LocateVex(G, u);</span><br><span class="line">    for (j = 0 ; j &lt; G.vexnum; j++) &#123; //輔助數組初始化</span><br><span class="line">        if (j != k)</span><br><span class="line">            closedge[j] = &#123;u, G.arcs[k][j].adj&#125;; //&#123;adjvex, lowcost&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closedge[k].lowcost = 0; //初始，U=&#123;u&#125;</span><br><span class="line">    for (i = 1; i &lt; G.vexnum ; i++) &#123; //選擇其餘G.vexnum -1 個頂點</span><br><span class="line">        k = minimum(closedge); //求出T的下個結點：第k結點</span><br><span class="line">        //  此时 closedge[k].lowcost = MIN&#123; closedge[Vi].lowcost|closedge[Vi].lowcost&gt;0,Vi∈V-U&#125;</span><br><span class="line">        printf(closedge[k].adjvex, G.vexs[k]); //輸出生成樹的邊</span><br><span class="line">        closedge[k].lowcost = 0; //第k條邊併入U集</span><br><span class="line">        for (j = 0; j &lt; G.vexnum; j++) &#123;</span><br><span class="line">            if (G.arcs[k][j].adj &lt; closedge[j].lowcost) //新頂點併入U後重新選擇最小邊</span><br><span class="line">                closedge[j] = &#123;G.vex[k], G.arcs[k][j].adj&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class Prim &#123;</span><br><span class="line">    public static List&lt;Vertex&gt; vertexList = new ArrayList&lt;Vertex&gt;();//结点集</span><br><span class="line">    public static List&lt;Edge&gt; EdgeQueue = new ArrayList&lt;Edge&gt;();//边集</span><br><span class="line">    public static List&lt;Vertex&gt; newVertex = new ArrayList&lt;Vertex&gt;();//已经 访问过的结点</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        primTree();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void buildGraph() &#123;</span><br><span class="line">        Vertex v1 = new Vertex(&quot;a&quot;);</span><br><span class="line">        Prim.vertexList.add(v1);</span><br><span class="line">        Vertex v2 = new Vertex(&quot;b&quot;);</span><br><span class="line">        Prim.vertexList.add(v2);</span><br><span class="line">        Vertex v3 = new Vertex(&quot;c&quot;);</span><br><span class="line">        Prim.vertexList.add(v3);</span><br><span class="line">        Vertex v4 = new Vertex(&quot;d&quot;);</span><br><span class="line">        Prim.vertexList.add(v4);</span><br><span class="line">        Vertex v5 = new Vertex(&quot;e&quot;);</span><br><span class="line">        Prim.vertexList.add(v5);</span><br><span class="line">        addEdge(v1, v2, 6);</span><br><span class="line">        addEdge(v1, v3, 7);</span><br><span class="line">        addEdge(v2, v3, 8);</span><br><span class="line">        addEdge(v2, v5, 4);</span><br><span class="line">        addEdge(v2, v4, 5);</span><br><span class="line">        addEdge(v3, v4, 3);</span><br><span class="line">        addEdge(v3, v5, 9);</span><br><span class="line">        addEdge(v5, v4, 7);</span><br><span class="line">        addEdge(v5, v1, 2);</span><br><span class="line">        addEdge(v4, v2, 2);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void addEdge(Vertex a, Vertex b, int w) &#123;</span><br><span class="line">        Edge e = new Edge(a, b, w);</span><br><span class="line">        Prim.EdgeQueue.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void primTree() &#123;</span><br><span class="line">        buildGraph();</span><br><span class="line">        Vertex start = vertexList.get(0);</span><br><span class="line">        newVertex.add(start);</span><br><span class="line">        for (int n = 0; n &lt; vertexList.size() - 1; n++) &#123;</span><br><span class="line">            Vertex temp = new Vertex(start.key);</span><br><span class="line">            Edge tempedge = new Edge(start, start, 1000);</span><br><span class="line">            for (Vertex v : newVertex) &#123;</span><br><span class="line">                for (Edge e : EdgeQueue) &#123;</span><br><span class="line">                    if (e.start == v &amp;&amp; !containVertex(e.end)) &#123;</span><br><span class="line">                        if (e.key &lt; tempedge.key) &#123;</span><br><span class="line">                            temp = e.end;</span><br><span class="line">                            tempedge = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            newVertex.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        Iterator it = newVertex.iterator();</span><br><span class="line">        while (it.hasNext()) &#123;</span><br><span class="line">            Vertex v = (Vertex) it.next();</span><br><span class="line">            System.out.println(v.key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static boolean containVertex(Vertex vte) &#123;</span><br><span class="line">        for (Vertex v : newVertex) &#123;</span><br><span class="line">            if (v.key.equals(vte.key))</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Vertex &#123;</span><br><span class="line">    String key;</span><br><span class="line">    Vertex(String key) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Edge &#123;</span><br><span class="line">    Vertex start;</span><br><span class="line">    Vertex end;</span><br><span class="line">    int key;</span><br><span class="line">    Edge(Vertex start, Vertex end, int key) &#123;</span><br><span class="line">        this.start = start;</span><br><span class="line">        this.end  = end;</span><br><span class="line">        this.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><ol><li><a href="https://zh.wikipedia.org/wiki/%E6%99%AE%E6%9E%97%E5%A7%86%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">维基百科-普林姆算法</a></li></ol>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>区块链的技术原理和意义（论文祥读）</title>
      <link href="/2018/06/10/blockchainPage1/"/>
      <url>/2018/06/10/blockchainPage1/</url>
      <content type="html"><![CDATA[<h3 id="文章重点"><a href="#文章重点" class="headerlink" title="文章重点"></a>文章重点</h3><p>区块链技术原理、数据结构、运行机制、区块链的分叉</p><h3 id="区块链技术原理"><a href="#区块链技术原理" class="headerlink" title="区块链技术原理"></a>区块链技术原理</h3><blockquote><p>前言：今天在学校上了一门有关银行金融的课程，了解到一个术语<code>financial intermediation</code>——金融中介，早期的银行直至现在贷款人和被贷款人依旧采取中介的方式进行交易，究其原因是现在的交易是基于信用。<br>而区块链打破的正是基于信用的交易方式，它假设交易双方互不信任，完全依靠密码学原理进行交易和记账，由此打破交易需要第三方介入的传统贸易方式。</p></blockquote><h4 id="区块链定义和特点"><a href="#区块链定义和特点" class="headerlink" title="区块链定义和特点"></a>区块链定义和特点</h4><p>区块链，顾名思义，很容易就联想到<code>链表</code>这一数据结构。实际上，区块链就是一种分布式<em><code>(1)</code></em>数据库，通过去中心化<em><code>(2)</code></em>、去信任的方式，集体维护一个可靠数据库。<br>传统数据库的4中操作可以简写为CURD，C表示创建（create）、U表示更新（update）、R表示读取（read）、D表示删除（delete）。<br>而区块链作为分布式数据库，相当于放弃了更新（U）和删除（D）这两个操作，用“<code>无法篡改</code>”和“<code>不可抵赖</code>”两个重要特点代替，依托P2P网络提供的分布式端对端网络的特点，可将之归结为<code>CROSS</code>原则：</p><ul><li>C（create）：创建</li><li>R（retrieve）：可溯，依托区块彼此相连的链式结构，用户可以追溯至最初交易来查看整个交易过程（想象拉链，总能通过任一个链条项找到其他任意链条项）</li><li>O（open）：开放，任何一个人都可以通过接入P2P网络来记账</li><li>S（security）：安全，基于密码学的安全通信，以及工作量证明机制，无人可以篡改数据库中的数据</li><li>S（stable）：稳定，系统中任何节点的退出，都不会影响到整个系统的稳定性，不会遇到中心化节点通常遇到的“单点故障”问题。</li></ul><p>由此可见，具有CROSS特点的区块链技术极有可能改变现有的交易模式。传统的交易中，商家和消费者之间难以做到完全信任，为了保证对方是可信的，常常需要国家信用背书或者企业背书的第三方机构。商家和消费者为了证明自己合规，需要自己把自己部分的材料都汇聚到第三方机构，能想象一下这冗长的手续以及额外的费用，这也常常使得交易滞后。区块链技术则逐步实现去中心化、去中介，实现消费者和商家之间直接支付，减去了中间不必要的时间。</p><h4 id="区块链的技术原语"><a href="#区块链的技术原语" class="headerlink" title="区块链的技术原语"></a>区块链的技术原语</h4><p>主要运用了4个基础技术——哈希运算（SHA256）、数字签名、P2P网络、工作量证明（PoW）</p><h5 id="哈希加密算法（SHA256）"><a href="#哈希加密算法（SHA256）" class="headerlink" title="哈希加密算法（SHA256）"></a>哈希加密算法（SHA256）</h5><p>将任何一串数据输入到SHA256都能得到一个256位的<code>Hash值</code>（散列值），特点：相同的数据输入将得到相同的结果，输入数据只要稍有变化，则将得到一个千差万别的结果，且结果无法事先预知——我们不能通过找规律的方式找到这个Hash值。</p><h5 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h5><p>通常数字签名是基于椭圆曲线加密技术的公私钥来实现，有两个很重要的概念：</p><ol><li>公私钥是非对称加密技术，公钥和私钥不同，但是可以基于私钥生成公钥。</li><li>相关性，公钥加密的，对应的私钥才能解密。私钥加密的内容，对应的公钥才能解密。</li></ol><h5 id="P2P网络"><a href="#P2P网络" class="headerlink" title="P2P网络"></a>P2P网络</h5><p>P2P网络分为有结构和无结构，区别在于路由规则的制定方面。<br>有结构的P2P网络，例如Chord，利用<code>一致性哈希表（DHT）</code>构建每个节点的路由表。<br>无结构的P2P网络代表是Gnutella，节点之间的路由靠广播的方式。一个节点要想查找一个文件，首先问其邻居有没有这个文件，他的邻居再问各自的邻居有没有，这样迭代，容易形成<code>广播风暴</code>，因此一般设置一个网络TTL，来限制广播传播的范围。<br>区块链采用的是无结构P2P网络。</p><h5 id="工作量证明机制"><a href="#工作量证明机制" class="headerlink" title="工作量证明机制"></a>工作量证明机制</h5><p>相当于一份工作证明，确认你做过一定量的工作。工作量是信任产生的基础，在区块链中，我们通过解决一个数学难题来证明自己的工作量。<br>这个数据难题就是，对一个数字串进行两次SHA256运算，如果得到的数小于一个指定的值，就算成功。否则，要通过不断的尝试试错，来求解这个数。一般来说，指定的结果值，前面都是多个零开头。</p><h4 id="区块链的数据结构"><a href="#区块链的数据结构" class="headerlink" title="区块链的数据结构"></a>区块链的数据结构</h4><p>一个区块链依托于一个P2P网络。<br>节点可以有 4 种功能，即钱包、完整的区块链拷贝、挖矿和路由。<br><code>路由</code>功能是每个节点必需的，前3个功能，根据节点自己的需求来定。<br>对于一个区块链拷贝来说，它记录了从 2009 年，中本聪建立创世区块以来，系统运行时记录的所有交易记录。<br>区块链分为区块头和区块体。<br>区块头包含版本号、上一个区块的哈希值、Merkle根节点哈希值、时间戳、难度值、随机数和交易记录这些字段。<br>区块与区块之间彼此相连，构成的一个链式结构，叫做区块链。这跟以前编写C语言，用指针实现链表是一个道理。不过，这里的指针不是内存地址，而是将上一个区块的区块头，使用两次SHA256加密算法，得到的哈希值。</p><blockquote><p>区块头没有包含任何交易记录信息，怎么能保证交易记录不被篡改？</p></blockquote><p>答案是，为了提高区块链的校验效率，把一个区块里的所有交易记录，构建成Merkle树这样的二叉树结构。如下图（c）所示，如果交易记录是奇数，图中的 3 个记录，剩下的二叉树节点由自己填补：图中的交易 2 和自己构成了一个二叉树。以此类推，直到根节点。二叉树的两个交易记录哈希值直接串联，作为下一个二叉树的输入。通过这种方式，如果有人更改任何一个交易记录，按照前面 SHA256 加密哈希的特性，Merkle根节点就会变动很大，以致其他节点在验证区块链的哈希值时，能够很明显地发现问题。</p><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/blog/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%BB%93%E6%9E%84.png" alt="图 区块链的数据结构"></p><h4 id="区块链的运行机制"><a href="#区块链的运行机制" class="headerlink" title="区块链的运行机制"></a>区块链的运行机制</h4><p>用户A想把比特币支付给用户B，首先要知道用户 B 的钱包地址。B 可以通过钱包，产生一对公私钥，通过一些处理，得到新的私钥和钱包 B的地址。通过数字签名，B 将钱包地址发给 A。A 根据 B 的地址，发起一个交易，通过自己的数字签名授权，将这个交易发给 B，这时 B 已经收到了这些比特币，但是还不能用，因为没有得到系统的确认。之后，A向全网内所有人广播，告诉其他节点有关交易的信息。类似的交易重复发生，直到区块确权时间到，矿工们开始竞争记账权。首先，计算Merkle根节点的哈希值，然后不断调整区块头中的随机数，争取小于系统的设定值，此为工作量证明。第一个算出结果的矿工，得到系统给予的比特币奖励，也向全网广播这个消息。其他节点在收到该消息时，结束工作量证明，并对区块进行验证（随机数），如果验证合格，将区块接入到区块链的末尾。具体如下图：</p><p><img src="https://gitee.com/yojiaku/visualAlgorithm/raw/master/blog/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.png" alt="图 区块链的运行机制"></p><p>相关技术细节：</p><ul><li><p>地址生成机制<br>B通过钱包，生成256位的私钥，基于椭圆曲线加密算法，得到有前缀的512位公钥哈希字符串；经过SHA256算法，得到256位的哈希加密字符串；通过RIPEMD160算法，得到160位的公钥哈希字符串；使用Base58算法，将二进制字符串翻译成人眼可识别的字符串，也就是B钱包的地址。</p></li><li><p>消息交互机制</p></li><li>区块确认机制<br>上下文固定，只能通过随机数的不断尝试来进行暴力破解，争取小于系统要求的门限值。最后的胜出者将区块链入区块链的末尾（<strong>只是链接到末尾，而不是确认</strong>）。区块链为了防止<code>51%</code>攻击，延迟<code>6个区块</code>再对这个区块进行确认。</li></ul><h4 id="区块链的分叉和51-攻击"><a href="#区块链的分叉和51-攻击" class="headerlink" title="区块链的分叉和51%攻击"></a>区块链的分叉和51%攻击</h4><p>分叉：指同一时间段内全网不止一个节点能计算出随机数，即会有多个节点在网络中广播它们各自打包好的临时区块。<br>某一节点若收到多个针对同一个前续区块的后续临时区块，则该节点会在本地区块链上建立分支，多个临时区块对应多个分支。<br>需要等到下一个工作量证明被发现，而其中一个分支被证实为最长的一条，那么在另一条分支链条上工作的节点将转换阵营，开始在较长的区块链条上工作，而其他分支将会被网络彻底抛弃。<br>51%攻击则是由区块链的分叉衍生出来的。</p>]]></content>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Algorithm-二维数组中的查找-BinarySearch</title>
      <link href="/2018/03/28/BinarySearch/"/>
      <url>/2018/03/28/BinarySearch/</url>
      <content type="html"><![CDATA[<h1 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h1><blockquote><p>题目描述<br>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></blockquote><h2 id="最简单的思路"><a href="#最简单的思路" class="headerlink" title="最简单的思路"></a>最简单的思路</h2><p>对每行采用二分查找，时间复杂度是O(nlogn)</p><h2 id="JavaScript实现"><a href="#JavaScript实现" class="headerlink" title="JavaScript实现"></a>JavaScript实现</h2><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js-binary search-iterative</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearchIterative</span>(<span class="params">a, value</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> mid, lo = <span class="number">0</span>,</span><br><span class="line">      hi = a.length - <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">    mid = <span class="built_in">Math</span>.floor((lo + hi) / <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">      hi = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">      lo = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Find</span>(<span class="params">target, array</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> row = array.length;</span><br><span class="line">    <span class="keyword">let</span> colFirst = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;row; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> result = binarySearchIterative(array[i], target);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> BinarySearch Algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS逻辑或运算符</title>
      <link href="/2018/03/26/JS%E9%80%BB%E8%BE%91%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2018/03/26/JS%E9%80%BB%E8%BE%91%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript逻辑或运算符"><a href="#JavaScript逻辑或运算符" class="headerlink" title="JavaScript逻辑或运算符"></a>JavaScript逻辑或运算符</h1><p>JScript 使用下面的规则来把非 Boolean 值转换为 Boolean 值： </p><ul><li>所有对象都被认为是 true。 </li><li>字符串当且仅当为空时才被认为是 false。 </li><li>null 和 undefined 被认为是 false。 </li><li>数字当且仅当为 0 时才是 false。 </li></ul>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS逻辑与运算符</title>
      <link href="/2018/03/26/JS%E9%80%BB%E8%BE%91%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2018/03/26/JS%E9%80%BB%E8%BE%91%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript逻辑“与”运算符"><a href="#JavaScript逻辑“与”运算符" class="headerlink" title="JavaScript逻辑“与”运算符"></a>JavaScript逻辑“与”运算符</h1><p>当且仅当两个表达式的值都等于 True 时， result 才是 True。如果任一表达式的值等于 False， 则 result 为 False。 </p><p>JScript 使用下面的规则，来把非 Boolean 值转换为 Boolean 值： </p><ul><li>所有对象都被认为是 true。 </li><li>字符串当且仅当为空时被认为是 false。 </li><li>null 和 undefined 被认为是 false。 </li><li>数字当且仅当为零时是 false。 </li></ul>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS-Global</title>
      <link href="/2018/03/26/JS-Global/"/>
      <url>/2018/03/26/JS-Global/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript-Global方法"><a href="#JavaScript-Global方法" class="headerlink" title="JavaScript Global方法"></a>JavaScript Global方法</h1><h2 id="isNaN方法"><a href="#isNaN方法" class="headerlink" title="isNaN方法"></a>isNaN方法</h2><p>返回一个 Boolean 值，指明提供的值是否是保留值 NaN （不是数字）。 </p><p>isNaN(numValue)</p><p>必选项 numvalue 参数为要检查是否为 NAN 的值。 </p><p>说明<br>如果值是 NaN， 那么 isNaN 函数返回 true ，否则返回 false 。 使用这个函数的典型情况是检查 parseInt 和 parseFloat 方法的返回值。 </p><p>还有一种办法，变量可以与它自身进行比较。 如果比较的结果不等，那么它就是 NaN 。 这是因为 NaN 是唯一与自身不等的值。 </p><h2 id="isFinite-方法"><a href="#isFinite-方法" class="headerlink" title="isFinite 方法"></a>isFinite 方法</h2><p>返回一个 Boolean 值,指明所提供的数字是否是有限的。</p><p>isFinite(number)</p><p>必选项 number 参数为任意的数值。 </p><p>说明<br>如果 number 不是 NaN 、负无穷或正无穷，那么 isFinite 方法将返回 true 。 如果是这三种情况，函数返回 false 。 </p><h2 id="parseInt-方法"><a href="#parseInt-方法" class="headerlink" title="parseInt 方法"></a>parseInt 方法</h2><p>返回由字符串转换得到的整数。</p><p>parseInt(numString, [radix])</p><p>参数<br>numString</p><p>必选项。要转换为数字的字符串。</p><p>radix</p><p>可选项。在 2 和 36 之间的表示 numString 所保存数字的进制的值。如果没有提供，则前缀为 ‘0x’ 的字符串被当作十六进制，前缀为 ‘0’ 的字符串被当作八进制。所有其它字符串都被当作是十进制的。</p><p>说明<br>parseInt 方法返回与保存在 numString 中的数字值相等的整数。如果 numString 的前缀不能解释为整数，则返回 NaN（而不是数字）。 </p><p>parseInt(“abc”)     // 返回 NaN。<br>parseInt(“12abc”)   // 返回 12。<br>可以用 isNaN 方法检测 NaN。 </p><h2 id="parseFloat-方法"><a href="#parseFloat-方法" class="headerlink" title="parseFloat 方法"></a>parseFloat 方法</h2><p>返回由字符串转换得到的浮点数。 </p><p>parseFloat(numString)</p><p>必选项 numString 参数是包含浮点数的字符串。 </p><p>说明<br>parseFloat 方法返回与 numString 中保存的数相等的数字表示。如果 numString 的前缀不能解释为浮点数，则返回 NaN （而不是数字）。</p><p>parseFloat(“abc”)      // 返回 NaN。<br>parseFloat(“1.2abc”)   // 返回 1.2。<br>可以用 isNaN 方法检测 NaN。 </p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS函数创建</title>
      <link href="/2018/03/26/JS%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA/"/>
      <url>/2018/03/26/JS%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript函数创建"><a href="#JavaScript函数创建" class="headerlink" title="JavaScript函数创建"></a>JavaScript函数创建</h1><h2 id="caller属性"><a href="#caller属性" class="headerlink" title="caller属性"></a>caller属性</h2><p>返回一个对函数的引用，该函数调用了当前函数。</p><p>functionName.caller </p><p>functionName 对象是所执行函数的名称。</p><p>对于函数来说，caller 属性只有在函数执行时才有定义。 如果函数是由 JScript 程序的顶层调用的，那么 caller 包含的就是 null 。</p><p>如果在字符串上下文中使用 caller 属性，那么结果和 functionName.toString 一样，也就是说，显示的是函数的反编译文本。</p><h2 id="arguments属性"><a href="#arguments属性" class="headerlink" title="arguments属性"></a>arguments属性</h2><p>为当前执行的 function 对象返回一个arguments 对象。</p><p>function.arguments</p><p>function 参数是当前执行函数的名称，可以省略。 </p><p>通过 arguments 属性，函数可以处理可变数量的参数。 arguments 对象的 length 属性包含了传递给函数的参数的数目。对于arguments 对象所包含的单个参数，其访问方法与数组中所包含的参数的访问方法相同。</p><h2 id="length属性"><a href="#length属性" class="headerlink" title="length属性"></a>length属性</h2><p>返回函数定义的参数数目。 </p><p>functionName.length</p><p>所必须的functionName 参数是被讨论的函数的名称。 </p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS-throw语句</title>
      <link href="/2018/03/26/JS-throw%E8%AF%AD%E5%8F%A5/"/>
      <url>/2018/03/26/JS-throw%E8%AF%AD%E5%8F%A5/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript-throw语句"><a href="#JavaScript-throw语句" class="headerlink" title="JavaScript throw语句"></a>JavaScript throw语句</h1><p>产生一个能被 try…catch…finally 语句处理的错误情形。 </p><p>throw exception </p><p>必选的 exception 参数可以是任何表达式。 </p><p>说明<br>下面的例子根据传递进来的值扔出一个错误，然后举例说明那个错误是如何在 try…catch…finally语句的层次中被处理的： </p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TryCatchDemo</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (x == <span class="number">0</span>)   <span class="comment">// 估参数的值。</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="string">"x equals zero"</span>;   <span class="comment">// 扔出一个错误。</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="string">"x does not equal zero"</span>;   <span class="comment">// 扔出一个不同的错误。</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span>(e) &#123;   <span class="comment">// 在这儿处理 "x = 0" 的错误。</span></span><br><span class="line">         <span class="keyword">if</span> (e == <span class="string">"x equals zero"</span>)   <span class="comment">// 检查错误能否在这儿被处理。</span></span><br><span class="line">            <span class="keyword">return</span>(e + <span class="string">" handled locally."</span>);   <span class="comment">// 返回对象错误消息。</span></span><br><span class="line">         <span class="keyword">else</span>   <span class="comment">// 不能在这儿处理这个错误。</span></span><br><span class="line">            <span class="keyword">throw</span> e;   <span class="comment">// 重新扔出该错误给下一个</span></span><br><span class="line">      &#125;   <span class="comment">// 错误处理程序。</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span>(e) &#123;   <span class="comment">// 在此处理其他错误。</span></span><br><span class="line">      <span class="keyword">return</span>(e + <span class="string">" handled higher up."</span>);   <span class="comment">// 返回错误消息。</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.write(TryCatchDemo(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">document</span>.write(TryCatchDemo(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS日期时间</title>
      <link href="/2018/03/26/JS%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4/"/>
      <url>/2018/03/26/JS%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript日期和时间"><a href="#JavaScript日期和时间" class="headerlink" title="JavaScript日期和时间"></a>JavaScript日期和时间</h1><h2 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h2><p>启用基本存储器并取得日期和时间。</p><p>dateObj = new Date()<br>dateObj = new Date(dateVal)<br>dateObj = new Date(year, month, date[, hours[, minutes[, seconds[,ms]]]]) </p><p>dateVal</p><p>必选项。如果是数字值，dateVal 表示指定日期与 1970 年 1 月 1 日午夜间全球标准时间 的毫秒数。如果是字符串，则 dateVal 按照 parse 方法中的规则进行解析。dateVal 参数也可以是从某些 ActiveX(R) 对象返回的 VT_DATE 值</p><p>year</p><p>必选项。完整的年份，比如，1976（而不是 76）。</p><p>month</p><p>必选项。表示的月份，是从 0 到 11 之间的整数（ 1 月至 12 月）。</p><p>date</p><p>必选项。表示日期，是从 1 到 31 之间的整数。</p><p>hours</p><p>可选项。 如果提供了 minutes 则必须给出。表示小时，是从 0 到 23 的整数（午夜到 11pm）。</p><p>Date 对象保存以毫秒为单位表示特定时间段。如果某个参数的值大于其范围或为负数，则存储的其他值将做相应的调整。例如，如果指定 150 秒，JScript 将该数字重新定义为 2 分 30 秒。 </p><p>如果数字为 NaN，则表示该对象不代表特定的时间段。如果未向 Date 对象传递参数，它将被初始化为当前时间 (UTC)。在能够使用该对象前必须为其赋值。 </p><p>Date 对象能够表示的日期范围约等于 1970 年 1 月 1 日前后各 285,616 年。 </p><p>Date 对象具有两个不创建 Date 对象就可以调用的静态方法。它们是 parse 和 UTC。</p><h2 id="getDate方法"><a href="#getDate方法" class="headerlink" title="getDate方法"></a>getDate方法</h2><p>返回Date对象中庸本地时间表示的一个月的日期值</p><p>dateObj.getDate() </p><p>要获取用全球标准时间 (UTC)表示的日期值，请使用 getUTCDate 方法。 </p><p>返回值是一个处于 1 到 31 之间的整数，它代表了相应的 Date 对象中的日期值。</p><h2 id="getDay方法"><a href="#getDay方法" class="headerlink" title="getDay方法"></a>getDay方法</h2><p>返回 Date 对象中用本地时间表示的一周中的日期值。 </p><p>dateObj.getDay()</p><p>要获取用全球标准时间 (UTC)表示的一周中日期值，请使用 getUTCDay 方法。</p><p>getDay 方法所返回的值是一个处于 0 到 6 之间的整数，它代表了一周中的某一天，返回值与一周中日期的对应关系如下： </p><table><thead><tr><th>值</th><th>星期</th></tr></thead><tbody><tr><td>0</td><td>星期天</td></tr><tr><td>1</td><td>星期一</td></tr><tr><td>2</td><td>星期二</td></tr><tr><td>3</td><td>星期三</td></tr><tr><td>4</td><td>星期四</td></tr><tr><td>5</td><td>星期五</td></tr><tr><td>6</td><td>星期六</td></tr></tbody></table>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JSNull</title>
      <link href="/2018/03/26/JSNull/"/>
      <url>/2018/03/26/JSNull/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript-Null"><a href="#JavaScript-Null" class="headerlink" title="JavaScript Null"></a>JavaScript Null</h1><p>null 值指出一个变量中没有包含有效的数据。产生 null 的原因是： </p><ul><li>对一个变量显式地赋值为 null。 </li><li>包含 null 的表达式之间的任何操作。 </li></ul>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS数组处理</title>
      <link href="/2018/03/26/JS%E6%95%B0%E7%BB%84%E5%A4%84%E7%90%86/"/>
      <url>/2018/03/26/JS%E6%95%B0%E7%BB%84%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript数组处理"><a href="#JavaScript数组处理" class="headerlink" title="JavaScript数组处理"></a>JavaScript数组处理</h1><p>Array, concat, join, length, reverse, slice, sort</p><h2 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象"></a>Array对象</h2><p>提供对创建任何数据类型的数组的支持。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arrayObj = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line">arrayObj = <span class="keyword">new</span> <span class="built_in">Array</span>([size])</span><br><span class="line">arrayObj = <span class="keyword">new</span> <span class="built_in">Array</span>([element0[, element1[, ...[, elementN]]]])</span><br></pre></td></tr></table></figure><h2 id="concat方法（Array）"><a href="#concat方法（Array）" class="headerlink" title="concat方法（Array）"></a>concat方法（Array）</h2><p>返回一个新数组，这个新数组是由两个或更多数组组合而成。</p><p>array1.concat([item1[, item2[, . . . [, itemN]]]])</p><p>concat 方法返回一个 Array 对象，其中包含了 array1 和提供的任意其他项目的连接。</p><p>要加的项目（item1 … itemN）会按照从左到右的顺序添加到数组。如果某一项为数组，那么添加其内容到 array1 的末尾。如果该项目不是数组，就将其作为单个的数组元素添加到数组的末尾。</p><p>以下为从源数组复制元素到结果数组： </p><ul><li>对于从正被连接到新数组的数组中复制的对象参数，复制后仍然指向相同的对象。不论新数组和源数组中哪一个有改变，都将引起另一个的改变。 </li><li>对于连接到新数组的数值或字符串，只复制其值。一个数组中值有改变并不影响另一个数组中的值。 </li></ul><h2 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h2><p>返回字符串值，其中包括连接道一起的数组的所有元素，元素由指定分隔符分开。</p><p>arrayObj.join(separator)</p><p>如果数组中有元素没有定义或者为 null，将其作为空字符串处理。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JoinDemo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> a, b;</span><br><span class="line">   a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">   b = a.join(<span class="string">"-"</span>);</span><br><span class="line">   <span class="keyword">return</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reverse方法"><a href="#reverse方法" class="headerlink" title="reverse方法"></a>reverse方法</h2><p>返回一个元素顺序被反转的Array对象。</p><p>arrayObj.reverse( )</p><p>reverse 方法将一个 Array 对象中的元素位置进行反转。在执行过程中，这个方法并不会创建一个新的 Array 对象。 </p><p>如果数组是不连续的，reverse 方法将在数组中创建元素以便填充数组中的间隔。这样所创建的全部元素的值都是 undefined。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReverseDemo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> a, l;                  <span class="comment">// 声明变量。</span></span><br><span class="line">   a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);  <span class="comment">// 创建数组并赋值。</span></span><br><span class="line">   l = a.reverse();           <span class="comment">// 反转数组的内容。</span></span><br><span class="line">   <span class="keyword">return</span>(l);                 <span class="comment">// 返回结果数组。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="slice方法（Array）"><a href="#slice方法（Array）" class="headerlink" title="slice方法（Array）"></a>slice方法（Array）</h2><p>返回一个数组的一段。</p><p>arrayObj.slice(start, [end]) </p><p>slice 方法返回一个 Array 对象，其中包含了 arrayObj 的指定部分。 </p><p>slice 方法一直复制到 end 所指定的元素，但是不包括该元素。如果 start 为负，将它作为 length + start处理，此处 length 为数组的长度。如果 end 为负，就将它作为 length + end 处理，此处 length 为数组的长度。如果省略 end ，那么 slice 方法将一直复制到 arrayObj 的结尾。如果 end 出现在 start 之前，不复制任何元素到新数组中。</p><h2 id="sort方法"><a href="#sort方法" class="headerlink" title="sort方法"></a>sort方法</h2><p>返回一个元素已经排序的Array对象。</p><p>arrayobj.sort(sortfunction) </p><p>sortFunction</p><p>可选项。是用来确定元素顺序的函数的名称。如果这个参数被省略，那么元素将按照 ASCII 字符顺序进行升序排列。 </p><p>sort 方法将 Array 对象进行适当的排序；在执行过程中并不会创建新的 Array 对象。 </p><p>如果为 sortfunction 参数提供了一个函数，那么该函数必须返回下列值之一： </p><ul><li>负值，如果所传递的第一个参数比第二个参数小。 </li><li>零，如果两个参数相等。 </li><li>正值，如果第一个参数比第二个参数大。 </li></ul>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript创建高级对象</title>
      <link href="/2018/03/26/JavaScript%E5%88%9B%E5%BB%BA%E9%AB%98%E7%BA%A7%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/03/26/JavaScript%E5%88%9B%E5%BB%BA%E9%AB%98%E7%BA%A7%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript创建高级对象"><a href="#JavaScript创建高级对象" class="headerlink" title="JavaScript创建高级对象"></a>JavaScript创建高级对象</h1><h2 id="使用构造函数"><a href="#使用构造函数" class="headerlink" title="使用构造函数"></a>使用构造函数</h2><p>构造函数是一个函数，调用它来例示并初始化特殊类型的对象。可以使用 new 关键字来调用一个构造函数。下面给出了使用构造函数的新示例。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = <span class="keyword">new</span> <span class="built_in">Object</span>();             <span class="comment">// 创建没有属性的通用对象。</span></span><br><span class="line"><span class="keyword">var</span> myBirthday = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1961</span>, <span class="number">5</span>, <span class="number">10</span>);  <span class="comment">// 创建一个 Date 对象。</span></span><br><span class="line"><span class="keyword">var</span> myCar = <span class="keyword">new</span> Car();                   <span class="comment">// 创建一个用户定义的对象，并初始化其属性。</span></span><br></pre></td></tr></table></figure><p>通过构造函数将一个参数作为特定的 this 关键字的值传递给新创建的空对象。然后构造函数负责为新对象执行适应的初始化（创建属性并给出其初始值）。完成后，构造函数返回它所构造的对象的一个参数。</p><h2 id="使用原型"><a href="#使用原型" class="headerlink" title="使用原型"></a>使用原型</h2><p>在编写构造函数时，可以使用原型对象（它本身是所有构造函数的一个属性）的属性来创建继承属性和共享方法。原型属性和方法将按引用复制给类中的每个对象，因此它们都具有相同的值。可以在一个对象中更改原型属性的值，新的值将覆盖默认值，但仅在该实例中有效。属于这个类的其他对象不受此更改的影响。下面给出了使用自定义构造函数的示例，Circle（注意 this 关键字的使用）。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Circle.prototype.pi = <span class="built_in">Math</span>.PI;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ACirclesArea</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.pi * <span class="keyword">this</span>.r * <span class="keyword">this</span>.r; <span class="comment">// 计算圆面积的公式为 ?r2。</span></span><br><span class="line">&#125;</span><br><span class="line">Circle.prototype.area = ACirclesArea; <span class="comment">// 计算圆面积的函数现在是 Circle Prototype 对象的一个方法。</span></span><br><span class="line"><span class="keyword">var</span> a = ACircle.area();               <span class="comment">// 此为如何在 Circle 对象上调用面积函数。</span></span><br></pre></td></tr></table></figure><p>使用这个原则，可以给预定义的构造函数（都具有原型对象）定义附加属性。例如，如果想要能够删除字符串的前后空格（与 VBScript 的 Trim 函数类似），就可以给 String 原型对象创建自己的方法。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加一个名为 trim 的函数作为</span></span><br><span class="line"><span class="comment">// String 构造函数的原型对象的一个方法。</span></span><br><span class="line"><span class="built_in">String</span>.prototype.trim = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 用正则表达式将前后空格</span></span><br><span class="line">    <span class="comment">// 用空字符串替代。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/(^\s*)|(\s*$)/g</span>, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有空格的字符串</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">"    leading and trailing spaces    "</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示 "    leading and trailing spaces     (35)"</span></span><br><span class="line"><span class="built_in">window</span>.alert(s + <span class="string">" ("</span> + s.length + <span class="string">")"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除前后空格</span></span><br><span class="line">s = s.trim();</span><br><span class="line"><span class="comment">// 显示"leading and trailing spaces (27)"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript对象</title>
      <link href="/2018/03/26/JavaScript%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/03/26/JavaScript%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript对象"><a href="#JavaScript对象" class="headerlink" title="JavaScript对象"></a>JavaScript对象</h1><p>Jscript 对象是属性和方法的集合。一个方法就是一个函数，是对象的成员。属性是一个值或一组值（以数组或对象的形式），是对象的成员。Jscript 支持四种类型的对象：内部对象、生成的对象、宿主给出的对象（如 Internet 浏览器中的 window 和 document）以及 ActiveX 对象（外部组件）。</p><h2 id="作为数组的对象"><a href="#作为数组的对象" class="headerlink" title="作为数组的对象"></a>作为数组的对象</h2><p>在 Jscript 中，对象和数组几乎是以相同的方式处理的。对象和数组均可以被赋予任意值，实际上数组只是一种特殊的对象。数组和对象的区别在于数组有一个“奇妙的” length 属性，而对象没有。这意味着可以给数组的一个元素赋予比其他元素更大的值。例如，myArray[100] = “hello” — 然后 length 属性将自动地被更新为 101（新长度）。同样，如果修改数组的 length 属性，将删除不再是数组部分的元素。</p><p>Jscript 中所有的对象均支持“expando”属性或那些可以在运行时动态添加和删除的属性。这些属性可以有包含数字的任意名称。如果属性的名称是简单的标识符&lt;&lt;参考标识符规则&gt;&gt;，可以在对象名称的后面加句点，例如：</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加两个 expando 属性，'name' 和 'age'</span></span><br><span class="line">myObj.name = <span class="string">"Fred"</span>;</span><br><span class="line">myObj.age = <span class="number">42</span>;</span><br></pre></td></tr></table></figure><p>如果属性名称不是一个简单的标识符，或者在写脚本的时候不知道，可以在方括号中使用任意表达式来索引属性。在 Jscript 中所有 expando 属性的名称在被添加到对象之前被转换为字符串。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加两个无法写在 object.property 语</span></span><br><span class="line"><span class="comment">// 法中的 expando 属性。</span></span><br><span class="line"><span class="comment">// 第一个属性包含无效字符（空格），</span></span><br><span class="line"><span class="comment">// 所以必须写在方括号里。</span></span><br><span class="line">myObj[<span class="string">"not a valid identifier"</span>] = <span class="string">"This is the property value"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个 expando 名称是一个数字，</span></span><br><span class="line"><span class="comment">// 所以也必须写在方括号里。</span></span><br><span class="line">myObj[<span class="number">100</span>] = <span class="string">"100"</span>;</span><br></pre></td></tr></table></figure><p>传统的作法是赋给数组元素以 0 开始的数字索引。这些数组元素与 length 属性相交互。然而，由于所有的数组也是对象，也支持 expando 属性。请注意，虽然如此，expando 属性并不以任何方式与 length 属性相交互。例如：</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三个元素的数组</span></span><br><span class="line"><span class="keyword">var</span> myArray = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加数据</span></span><br><span class="line">myArray[<span class="number">0</span>] = <span class="string">"Hello"</span>;</span><br><span class="line">myArray[<span class="number">1</span>] = <span class="number">42</span>;</span><br><span class="line">myArray[<span class="number">2</span>] = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示数组的长度 3</span></span><br><span class="line"><span class="built_in">window</span>.alert(myArray.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加某些 expando 属性</span></span><br><span class="line">myArray.expando = <span class="string">"JScript!"</span>;</span><br><span class="line">myArray[<span class="string">"another Expando"</span>] = <span class="string">"Windows"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仍然显示 3，因为两个 expando 属性</span></span><br><span class="line"><span class="comment">// 并不影响长度。</span></span><br><span class="line"><span class="built_in">window</span>.alert(myArray.length);</span><br></pre></td></tr></table></figure><p>虽然 Jscript 并不直接支持多维数组，但是可以在数组元素中存储任意种类的数据 — 包含其他数组。所以通过在另一个数组的元素里存储其他数组可以得到多维数组的特性。例如，下面的代码为最大为 5 的数字建立了乘法表：</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若是更大的表请改变本数</span></span><br><span class="line"><span class="keyword">var</span> iMaxNum = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 循环计数</span></span><br><span class="line"><span class="keyword">var</span> i, j;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新数组。由于数组从 0 开始计数，</span></span><br><span class="line"><span class="comment">// 而不是 1，所以数组大小为 iMaxNum + 1。</span></span><br><span class="line"><span class="keyword">var</span> MultiplicationTable = <span class="keyword">new</span> <span class="built_in">Array</span>(iMaxNum + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为每个主要的数做循环（表中的每一行）</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= iMaxNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 生成表中的列</span></span><br><span class="line">    MultiplicationTable[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(iMaxNum + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将乘法的结果存在行中</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= iMaxNum; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        MultiplicationTable[i][j] = i * j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.alert(MultiplicationTable[<span class="number">3</span>][<span class="number">4</span>]); <span class="comment">// 显示 12</span></span><br><span class="line"><span class="built_in">window</span>.alert(MultiplicationTable[<span class="number">5</span>][<span class="number">2</span>]); <span class="comment">// 显示 10</span></span><br><span class="line"><span class="built_in">window</span>.alert(MultiplicationTable[<span class="number">1</span>][<span class="number">4</span>]); <span class="comment">// 显示 4</span></span><br></pre></td></tr></table></figure><h2 id="创建自己的对象"><a href="#创建自己的对象" class="headerlink" title="创建自己的对象"></a>创建自己的对象</h2><p>要创建自己的对象实例，必须首先为其定义一个构造函数。构造函数创建一个新对象，赋予对象属性，并在合适的时候赋予方法。例如，下面的示例为 pasta 对象定义了构造函数。注意 this 关键字的使用，它指向当前对象。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pasta 是有四个参数的构造器。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pasta</span>(<span class="params">grain, width, shape, hasEgg</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 是用什么粮食做的？</span></span><br><span class="line">    <span class="keyword">this</span>.grain = grain;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多宽？（数值）</span></span><br><span class="line">    <span class="keyword">this</span>.width = width;     </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 横截面形状？（字符串）</span></span><br><span class="line">    <span class="keyword">this</span>.shape = shape;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否加蛋黄？（boolean）</span></span><br><span class="line">    <span class="keyword">this</span>.hasEgg = hasEgg;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了对象构造器后，用 new 运算符创建对象实例。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> spaghetti = <span class="keyword">new</span> pasta(<span class="string">"wheat"</span>, <span class="number">0.2</span>, <span class="string">"circle"</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">var</span> linguine = <span class="keyword">new</span> pasta(<span class="string">"wheat"</span>, <span class="number">0.3</span>, <span class="string">"oval"</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>可以给对象实例添加属性以改变该实例，但是用相同的构造器生成的其他对象定义中并不包括这些属性，而且除非你特意添加这些属性那么在其他实例中并不显示出来。如果要将对象所有实例的附加属性显示出来，必须将它们添加到构造函数或构造器原型对象（原型在高级文档中讨论）中。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// spaghetti 的附加属性。</span></span><br><span class="line">spaghetti.color = <span class="string">"pale straw"</span>;</span><br><span class="line">spaghetti.drycook = <span class="number">7</span>;</span><br><span class="line">spaghetti.freshcook = <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> chowFun = <span class="keyword">new</span> pasta(<span class="string">"rice"</span>, <span class="number">3</span>, <span class="string">"flat"</span>, <span class="literal">false</span>); </span><br><span class="line"><span class="comment">// chowFun 对象或其他现有的 pasta 对象</span></span><br><span class="line"><span class="comment">// 都没有添加到 spaghetti 对象</span></span><br><span class="line"><span class="comment">// 的三个新属性。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将属性‘foodgroup’加到 pasta 原型对象</span></span><br><span class="line"><span class="comment">// 中，这样 pasta 对象的所有实例都可以有该属性，</span></span><br><span class="line"><span class="comment">// 包括那些已经生成的实例。</span></span><br><span class="line">pasta.prototype.foodgroup = <span class="string">"carbohydrates"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 spaghetti.foodgroup、chowFun.foodgroup，等等</span></span><br><span class="line"><span class="comment">// 均包含值“carbohydrates”。</span></span><br></pre></td></tr></table></figure><h2 id="在定义中包含方法"><a href="#在定义中包含方法" class="headerlink" title="在定义中包含方法"></a>在定义中包含方法</h2><p>可以在对象的定义中包含方法（函数）。一种方法是在引用别处定义的函数的构造函数中添加一个属性。例如，下面的示例扩充上面定义的 pasta 构造函数以包含 toString 方法，该方法将在显示对象的值时被调用。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pasta 是有四个参数的构造器。</span></span><br><span class="line"><span class="comment">// 第一部分与上面相同。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pasta</span>(<span class="params">grain, width, shape, hasEgg</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 用什么粮食做的？</span></span><br><span class="line">    <span class="keyword">this</span>.grain = grain;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多宽？（数值）</span></span><br><span class="line">    <span class="keyword">this</span>.width = width;     </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 横截面形状？（字符串）</span></span><br><span class="line">    <span class="keyword">this</span>.shape = shape;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否加蛋黄？（boolean）</span></span><br><span class="line">    <span class="keyword">this</span>.hasEgg = hasEgg;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里添加 toString 方法（如下定义）。</span></span><br><span class="line">    <span class="comment">// 注意在函数的名称后没有加圆括号；</span></span><br><span class="line">    <span class="comment">// 这不是一个函数调用，而是</span></span><br><span class="line">    <span class="comment">// 对函数自身的引用。</span></span><br><span class="line">    <span class="keyword">this</span>.toString = pastaToString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际的用来显示 past 对象内容的函数。 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pastaToString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 返回对象的属性。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Grain: "</span> + <span class="keyword">this</span>.grain + <span class="string">"\n"</span> +</span><br><span class="line">        <span class="string">"Width: "</span> + <span class="keyword">this</span>.width + <span class="string">"\n"</span> +</span><br><span class="line">        <span class="string">"Shape: "</span> + <span class="keyword">this</span>.shape + <span class="string">"\n"</span> +</span><br><span class="line">        <span class="string">"Egg?: "</span> + <span class="built_in">Boolean</span>(<span class="keyword">this</span>.hasEgg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> spaghetti = <span class="keyword">new</span> pasta(<span class="string">"wheat"</span>, <span class="number">0.2</span>, <span class="string">"circle"</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 将调用 toString() 并显示 spaghetti 对象</span></span><br><span class="line"><span class="comment">// 的属性。</span></span><br><span class="line"><span class="built_in">window</span>.alert(spaghetti);</span><br></pre></td></tr></table></figure><h2 id="内部对象"><a href="#内部对象" class="headerlink" title="内部对象"></a>内部对象</h2><p>Microsoft Jscript 提供了 11 个内部（或“内置”）对象。它们是Array、Boolean、Date、Function、Global、Math、Number、Object、RegExp、Error 以及 String 对象。</p><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>用关键字 Array 生成数组时，Jscript 包含了 length 属性，该属性记录了数组入口数。如果没有给该属性指定值，则设置长度为 0 且数组没有入口点。如果指定一个数值，则将长度设置为该数。如果指定了不止一个参数，则这些参数被用作数组的入口。另外，参数的数目被赋给 length 属性。如下面的示例与前一个示例是等价的。</p><p>当向用关键字 Array 生成的数组中添加元素时，Jscript 自动改变属性 length 的值。Jscript 中的数组索引总是以 0 开始，而不是 1，所以属性 length 通常比数组的最大索引大 1。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>在 Jscript 中，可以将字符串（和数）当作对象来处理。string 对象 有一些内置方法，可以和自己的字符串一起使用。其中一个是substring 方法，它返回字符串的一部分。该方法以两个数字作为参数。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aString = <span class="string">"0123456789"</span>;</span><br><span class="line"><span class="keyword">var</span> aChunk = aString.substring(<span class="number">4</span>, <span class="number">7</span>);  <span class="comment">// 将 aChunk 设为 "456"。</span></span><br><span class="line"><span class="keyword">var</span> aNotherChunk = aString.substring(<span class="number">7</span>, <span class="number">4</span>);  <span class="comment">// 将 aNotherChunk 设为 "456"。</span></span><br><span class="line"><span class="comment">// 使用上面生成数组的示例：</span></span><br><span class="line">firstLetter = theMonths[<span class="number">5</span>].substring(<span class="number">0</span>,<span class="number">1</span>);  <span class="comment">// 将变量 firstLetter 设为“J”。</span></span><br></pre></td></tr></table></figure><p>String 对象的另一个属性是 length 属性。本属性包含了字符串中的字符数（空字符串为 0）。它是一个数值，可以直接在计算中使用。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> howLong = <span class="string">"Hello World"</span>.length  <span class="comment">// 设置变量 howLong 为 11。</span></span><br></pre></td></tr></table></figure><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>MAX_VALUE</td><td>可能的最大数大约为 1.79E+308；可以是正数或负数。（具体数值随系统不同而有微小差别。）</td></tr><tr><td>MIN_VALUE</td><td>可能的最小数大约为 2.22E-308；可以是正数或负数。（具体数值随系统不同而有微小差别。）</td></tr><tr><td>NaN</td><td>特殊非数量值，“不是数值”。</td></tr><tr><td>POSITIVE_INFINITY</td><td>比最大正数（Number.MAX_VALUE）还要大的任意正值自动被转换为此值，代表正无穷大。</td></tr><tr><td>NEGATIVE_INFINITY</td><td>比最小的负数（负的 Number.MAX_VALUE）还小的任意值被自动转换为此值，代表负无穷。</td></tr></tbody></table><p>Number.NaN 是一个特殊的属性，被定义为“不是数值”。例如被 0 除返回 NaN。试图解析一个无法被解析为数字的字符串同样返回 Number.NaN。把 NaN 与任何数值或本身作比较的结果都是不相等。不能通过与 Number.NaN 比较来测试 NaN 结果，而应该使用 isNaN() 函数。</p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript控制语句</title>
      <link href="/2018/03/26/JavaScript%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
      <url>/2018/03/26/JavaScript%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript控制语句"><a href="#JavaScript控制语句" class="headerlink" title="JavaScript控制语句"></a>JavaScript控制语句</h1><h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><p>如果要一起测试多个条件，并且知道某个条件比其他条件更可能满足或不满足测试，可以使用称为“短路计算”的特性来加速脚本的运行速度。当 JScript 计算逻辑表达式时，只计算要得到结果所需的子表达式。</p><p>例如，如果有一个“与”表达式，如 ((x == 123) &amp;&amp; (y == 42))，Jscript 首先检查 x 是否为 123。如果不是，即使 y 等于 42，整个表达式的值也不可能为 true。因此，并不对 y 作测试，Jscript 返回 false 值。</p><p>类似地，如果多个条件中只要有一个为真（使用 || 运算符），则当任何一个条件满足该测试时测试则停止。如果要测试的条件包括函数调用或其他复合表达式，这种处理方式就有效。出于此种想法，写 OR 表达式时，先写最有可能为 true 的条件。写 AND 表达式时，先写最有可能为 false 的条件。</p><p>以这种方式设计脚本的好处的一个示例是：在下例中如果 runfirst() 返回 0 或 false， 则不会运行 runsecond()。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((runfirst() == <span class="number">0</span>) || (runsecond() == <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">// 若干代码。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用循环"><a href="#使用循环" class="headerlink" title="使用循环"></a>使用循环</h2><p>JScript 支持四种循环： for 循环、 for…in 循环、 while 循环、 do…while 循环。</p><h3 id="使用-for…in-循环"><a href="#使用-for…in-循环" class="headerlink" title="使用 for…in 循环"></a>使用 for…in 循环</h3><p>JScript 提供了一种特别的循环方式来遍历一个对象的所有用户定义的属性或者一个数组的所有元素。for…in 循环中的循环计数器是一个字符串，而不是数字。它包含当前属性的名称或者当前数组元素的下标。</p><p>下面的代码范例应在 Internet 浏览器中运行，因为它使用 alert 方法，该方法不属于 Jscript。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建具有某些属性的对象</span></span><br><span class="line"><span class="keyword">var</span> myObject = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">myObject.name = <span class="string">"James"</span>;</span><br><span class="line">myObject.age = <span class="string">"22"</span>;</span><br><span class="line">myObject.phone = <span class="string">"555 1234"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举（循环）对象的所有属性</span></span><br><span class="line"><span class="keyword">for</span> (prop <span class="keyword">in</span> myObject)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 显示 "The property 'name' is James"，等等。</span></span><br><span class="line">    <span class="built_in">window</span>.alert(<span class="string">"The property '"</span> + prop + <span class="string">"' is "</span> + myObject[prop]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管 for…in 循环看起来像 VBScript 的 For Each…Next 循环，其实并不一样。JScript 的 for…in 循环重复Jscript 对象所有的属性。VBScript 的 For Each…Next 循环重复集合中的所有项目。要循环 JScript 中的所有集合，需要用 Enumerator 对象。尽管某些对象（像 Internet 浏览器中的那些）支持 VBScript 的 For Each…Next 和 Jscript 的 for…in 循环，但多数对象并不都支持。</p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript运算符</title>
      <link href="/2018/03/26/JavaScript%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2018/03/26/JavaScript%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript运算符"><a href="#JavaScript运算符" class="headerlink" title="JavaScript运算符"></a>JavaScript运算符</h1><p>== （相等）与 === （严格相等）的区别在于恒等运算符在比较前强制转换不同类型的值。例如，恒等对字符串 “1” 与数值 1 的比较结果将为 true。而严格相等不强制转换不同类型的值，因此它认为字符串 “1” 与数值 1 不相同。</p><p>基本的字符串、数值和布尔值是按值比较的。如果它们的值相同，比较结果为相等。对象（包括Array、Function、String、Number、Boolean、Error、Date以及 RegExp 对象）按引用比较。即使这些类型的两个变量具有相同的值，只有在它们正好为同一对象时比较结果才为 true。</p><p>例如：</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具有相同值的两个基本字符串。</span></span><br><span class="line"><span class="keyword">var</span> string1 = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">var</span> string2 = <span class="string">"Hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具有相同值的两个 String 对象。</span></span><br><span class="line"><span class="keyword">var</span> StringObject1 = <span class="keyword">new</span> <span class="built_in">String</span>(string1);</span><br><span class="line"><span class="keyword">var</span> StringObject2 = <span class="keyword">new</span> <span class="built_in">String</span>(string2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较结果为 true。</span></span><br><span class="line"><span class="keyword">if</span> (string1 == string2)</span><br><span class="line">     <span class="comment">// 执行某些命令（将要运行的）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较结果为 false。</span></span><br><span class="line"><span class="keyword">if</span> (StringObject1 == StringObject2)</span><br><span class="line">    <span class="comment">//执行某些命令（不会运行）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要比较 String 对象的值， </span></span><br><span class="line"><span class="comment">// 用 toString() 或者 valueOf() 方法。</span></span><br><span class="line"><span class="keyword">if</span> (StringObject1.valueOf() == StringObject2)</span><br><span class="line">     <span class="comment">//执行某些命令（将要运行的）。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript数据类型</title>
      <link href="/2018/03/26/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/03/26/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript数据类型"><a href="#JavaScript数据类型" class="headerlink" title="JavaScript数据类型"></a>JavaScript数据类型</h1><p>三种主要数据类型、两种复合数据类型、两种特殊数据类型</p><ul><li><p>主要（基本）数据类型：<br>字符串<br>数值<br>布尔</p></li><li><p>复合（引用）数据类型：<br>对象<br>数组</p></li><li><p>特殊数据类型：<br>Null<br>undefined</p></li></ul><h2 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h2><p>在 Jscript 中数据类型 null 只有一个值：null。关键字 null 不能用作函数或变量的名称。</p><p>包含 null 的变量包含“无值”或“无对象”。换句话说，该变量没有保存有效的数、字符串、boolean、数组或对象。可以通过给一个变量赋 null 值来清除变量的内容。</p><p>请注意，在 Jscript 中，null 与 0 不相等（与在 C 和 C++ 中不同）。同时应该指出的是，Jscript中 typeof 运算符将报告 null 值为 Object 类型，而非类型 null。这点潜在的混淆是为了向下兼容。</p><h2 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h2><p>如下情况使返回 undefined 值： </p><ul><li>对象属性不存在， </li><li>声明了变量但从未赋值。 </li></ul><p>注意不能通过与 undefined 做比较来测试一个变量是否存在，虽然可以检查它的类型是否为“undefined”。在以下的代码范例中，假设程序员想测试是否已经声明变量 x ：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种方法不起作用</span></span><br><span class="line"><span class="keyword">if</span> (x == <span class="literal">undefined</span>)</span><br><span class="line">    <span class="comment">// 作某些操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法同样不起作用- 必须检查</span></span><br><span class="line"><span class="comment">// 字符串 "undefined"</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span>(x) == <span class="literal">undefined</span>)</span><br><span class="line">    <span class="comment">// 作某些操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法有效</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span>(x) == <span class="string">"undefined"</span>)</span><br><span class="line">    <span class="comment">// 作某些操作</span></span><br></pre></td></tr></table></figure></p><h2 id="null-和-undefined-比较"><a href="#null-和-undefined-比较" class="headerlink" title="null 和 undefined 比较"></a>null 和 undefined 比较</h2><p>考虑将 undefined 值与null做比较。</p><p>someObject.prop == null;<br>如下情况时，比较的结果为 true， </p><ul><li>如果属性 someObject.prop 包含 null 值， </li><li>如果属性 someObject.prop 不存在。 </li></ul><p>要检查一个对象属性是否存在，可以使用新的 in 运算符： (？)<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (&quot;prop&quot; in someObject)</span><br><span class="line">// someObject 有属性 &apos;prop&apos;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript变量</title>
      <link href="/2018/03/26/JavaScript/"/>
      <url>/2018/03/26/JavaScript/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript变量"><a href="#JavaScript变量" class="headerlink" title="JavaScript变量"></a>JavaScript变量</h1><h2 id="名称规则"><a href="#名称规则" class="headerlink" title="名称规则"></a>名称规则</h2><ul><li>第一个字符必须是一个 ASCII 字母（大小写均可），或一个下划线( _ )。注意第一个字符不能是数字。 </li><li>后续的字符必须是字母、数字或下划线。 </li><li>变量名称一定不能是 保留字。</li></ul><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><ol><li>当药声明一个变量并进行初始化，但又不想指定任何特殊值，可以赋为NULL。</li><li>如果声明了一个变量却没有对其赋值，该变量存在，其值为 <code>undefined</code>。</li></ol><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> currentCount;</span><br><span class="line"><span class="keyword">var</span> finalCount = <span class="number">1</span> * currentCount; <span class="comment">// finalCount 的值为 NaN，因为 currentCount 为 undefined。</span></span><br></pre></td></tr></table></figure><p>注意：任何在undefined上的运算结果都为NaN。</p><ol start="3"><li>可以不用 <code>var</code> 关键字声明变量，并赋值–（隐式声明）。</li><li>不能使用未经过声明的变量。</li></ol><h2 id="NULL和undefined的区别"><a href="#NULL和undefined的区别" class="headerlink" title="NULL和undefined的区别"></a>NULL和undefined的区别</h2><p>注意在 JScript 中 null 和 undefined 的主要区别是 null 的操作象数字 0，而 undefined 的操作象特殊值NaN （不是一个数字）。对 null 值和 undefined 值作比较总是相等的。<br>例如：<br>var bestAge = null;var muchTooOld = 3 * bestAge; // muchTooOld 的值为 0。</p><h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><p>JScript 是一种自由类型的语言。它的变量没有预定类型（相对于强类型语言，如 C++）。相反，JScript 变量的类型相应于他们包含的值的类型。这种操作的好处是能将值作为另一类型处理。</p><p>要想显式地将字符串转换为整数，使用 parseInt 方法。要想显式地将字符串转换为数字，使用 parseFloat 方法。请注意，比较大小时字符串自动转换为相等的数字，但加法（连接）运算时保留为字符串。</p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>对CustomEvents.js文件的解读</title>
      <link href="/2018/02/11/CustomEvents-js/"/>
      <url>/2018/02/11/CustomEvents-js/</url>
      <content type="html"><![CDATA[<h1 id="建立Visualization需要的步骤"><a href="#建立Visualization需要的步骤" class="headerlink" title="建立Visualization需要的步骤"></a>建立Visualization需要的步骤</h1><ol><li>建立恰当的控件控制Visualization（例如插入元素，删除元素等）；</li><li>为上述建立的控件建立callBack（回调函数）<br>Creates callbacks for these controls that implement the visualizations. The visualizations are implemented by sending an array of strings to the animation manager – the animation manager will then implement the animation, and handle all of the animation controls for you<br>为这些实现可视化的控件创建回调。 通过向动画管理器发送字符串数组来实现可视化 - 动画管理器将实现动画，并为您处理所有动画控件</li><li>Listen for an undo event from the animation manager. When an undo event is detected, roll back the last operation<br>从动画管理器中听取撤消事件。 当检测到撤消事件时，回退上次的操作（“上一步骤”按钮功能响应？）</li></ol><h1 id="使用Algorithm方法-函数"><a href="#使用Algorithm方法-函数" class="headerlink" title="使用Algorithm方法/函数"></a>使用Algorithm方法/函数</h1><p>所在文件：Algorithm.js<br>注意：Algorithm是个人造类（原本的js中没有的，是新的object）</p><h2 id="1-函数定义"><a href="#1-函数定义" class="headerlink" title="1. 函数定义"></a>1. 函数定义</h2><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyAlgorithm</span>(<span class="params">am, w, h</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.init(am, w, h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyAlgorithm.prototype = <span class="keyword">new</span> Algorithm(); <span class="comment">// 创建一个新的Algorithm对象</span></span><br><span class="line">MyAlgorithm.prototype.constructor = MyAlgorithm;<span class="comment">// 新对象的构造函数</span></span><br><span class="line">MyAlgorithm.superclass = Algorithm.prototype;<span class="comment">// 新对象继承的超类（新对象继承父类ALgorithm的属性）</span></span><br></pre></td></tr></table></figure><h1 id="对于AnimationMain-js-文件中的-reorderSibling-node1-node2-函数的实现"><a href="#对于AnimationMain-js-文件中的-reorderSibling-node1-node2-函数的实现" class="headerlink" title="对于AnimationMain.js 文件中的 reorderSibling(node1, node2) 函数的实现"></a>对于AnimationMain.js 文件中的 reorderSibling(node1, node2) 函数的实现</h1><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">&lt;title&gt;菜鸟教程(runoob.com)&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=<span class="string">"Water"</span> style=<span class="string">"width:100px;height:20px;background-color:red;"</span>&gt;node1&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div id="myList" style="width:100px;height:20px;background-color:yellow;"&gt;node2&lt;/</span>div&gt;</span><br><span class="line">&lt;p id=<span class="string">"demo"</span>&gt;单击按钮替换列表中的第一项。&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;button onclick="reorderSibling()"&gt;点我&lt;/</span>button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reorderSibling</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> node1=<span class="built_in">document</span>.getElementById(<span class="string">"Water"</span>);</span><br><span class="line"><span class="keyword">var</span> node2=<span class="built_in">document</span>.getElementById(<span class="string">"myList"</span>);</span><br><span class="line"></span><br><span class="line">node1.parentNode.replaceChild(node1,node2);</span><br><span class="line">node1.parentNode.insertBefore(node2, node1);</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;首先创建一个文本节点。&lt;br&gt;然后替换第一个列表中的第一个子节点。&lt;/</span>p&gt;</span><br><span class="line">&lt;p&gt;<span class="xml"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>注意:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span>这个例子只将文本节点的文本节点“Coffee”替换为“Water”,而不是整个LI元素,这也是替换节点的一种备选。&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p> <img src="https://raw.githubusercontent.com/Yojiaku/hexoBlogPic/875a87600027685f3d0b3e29c573f7f6976aefcf/functionGif/reorderSibling-node1-node2.gif" alt="reorderSibling-node1-node2-function"></p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Visualization </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>由Blocking Search动画引出的CSS样式的知识</title>
      <link href="/2018/02/07/Blocking-Search-Style/"/>
      <url>/2018/02/07/Blocking-Search-Style/</url>
      <content type="html"><![CDATA[<h1 id="前后对比图"><a href="#前后对比图" class="headerlink" title="前后对比图"></a>前后对比图</h1><p><img src="https://raw.githubusercontent.com/Yojiaku/hexoBlogPic/8906194b095bc9b644f5697ea9f7091b5853eed5/blockingSearch02.gif" alt="BlockingSearch.GIF before"><br><img src="https://raw.githubusercontent.com/Yojiaku/hexoBlogPic/259f6e2b6e095e56ccdf6babad9a7e7674623826/blockingSearch04.gif" alt="BlockingSearch.GIF after"></p><h1 id="CSS清除浮动的8种方法"><a href="#CSS清除浮动的8种方法" class="headerlink" title="CSS清除浮动的8种方法"></a>CSS清除浮动的8种方法</h1><p>浮动会使当前标签产生向上浮的效果，同时会影响到前后标签、父级标签的位置及 width height 属性。而且同样的代码，在各种浏览器中显示效果也有可能不相同，这样让清除浮动更难了。解决浮动引起的问题有多种方法，但有些方法在浏览器兼容性方面还有问题。</p><h2 id="父级div定义-height"><a href="#父级div定义-height" class="headerlink" title="父级div定义 height"></a>父级div定义 height</h2><p>代码如下：<br><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt; </span><br><span class="line"><span class="selector-class">.div1</span>&#123;<span class="attribute">background</span>:<span class="number">#000080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="comment">/*解决代码*/</span><span class="attribute">height</span>:<span class="number">200px</span>;&#125; </span><br><span class="line"><span class="selector-class">.div2</span>&#123;<span class="attribute">background</span>:<span class="number">#800080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="attribute">height</span>:<span class="number">100px</span>;<span class="attribute">margin-top</span>:<span class="number">10px</span>&#125; </span><br><span class="line"><span class="selector-class">.left</span>&#123;<span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">20%</span>;<span class="attribute">height</span>:<span class="number">200px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line"><span class="selector-class">.right</span>&#123;<span class="attribute">float</span>:right;<span class="attribute">width</span>:<span class="number">30%</span>;<span class="attribute">height</span>:<span class="number">80px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line">&lt;/style&gt; </span><br><span class="line">&lt;div class="div1"&gt; </span><br><span class="line">&lt;div class="left"&gt;Left&lt;/div&gt; </span><br><span class="line">&lt;div class="right"&gt;Right&lt;/div&gt; </span><br><span class="line">&lt;/div&gt; </span><br><span class="line">&lt;div class="div2"&gt; </span><br><span class="line"><span class="selector-tag">div2</span> </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题。 </p><p>优点：简单、代码少、容易掌握 </p><p>缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题 </p><p>建议：不推荐使用，只建议高度固定的布局时使用 </p><h2 id="结尾处加空div标签-clear-both"><a href="#结尾处加空div标签-clear-both" class="headerlink" title="结尾处加空div标签 clear:both"></a>结尾处加空div标签 clear:both</h2><p>代码如下:<br><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt; </span><br><span class="line"><span class="selector-class">.div1</span>&#123;<span class="attribute">background</span>:<span class="number">#000080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red&#125; </span><br><span class="line"><span class="selector-class">.div2</span>&#123;<span class="attribute">background</span>:<span class="number">#800080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="attribute">height</span>:<span class="number">100px</span>;<span class="attribute">margin-top</span>:<span class="number">10px</span>&#125; </span><br><span class="line"><span class="selector-class">.left</span>&#123;<span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">20%</span>;<span class="attribute">height</span>:<span class="number">200px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line"><span class="selector-class">.right</span>&#123;<span class="attribute">float</span>:right;<span class="attribute">width</span>:<span class="number">30%</span>;<span class="attribute">height</span>:<span class="number">80px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line"><span class="comment">/*清除浮动代码*/</span> </span><br><span class="line"><span class="selector-class">.clearfloat</span>&#123;<span class="attribute">clear</span>:both&#125; </span><br><span class="line">&lt;/style&gt; </span><br><span class="line">&lt;div class="div1"&gt; </span><br><span class="line">&lt;div class="left"&gt;Left&lt;/div&gt; </span><br><span class="line">&lt;div class="right"&gt;Right&lt;/div&gt; </span><br><span class="line">&lt;div class="clearfloat"&gt;&lt;/div&gt; </span><br><span class="line">&lt;/div&gt; </span><br><span class="line">&lt;div class="div2"&gt; </span><br><span class="line"><span class="selector-tag">div2</span> </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度 </p><p>优点：简单、代码少、浏览器支持好、不容易出现怪问题 </p><p>缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不好 </p><p>建议：不推荐使用，但此方法是以前主要使用的一种清除浮动方法 </p><h2 id="父级div定义-伪类-after-和-zoom-采用的"><a href="#父级div定义-伪类-after-和-zoom-采用的" class="headerlink" title="父级div定义 伪类:after 和 zoom (采用的)"></a>父级div定义 伪类:after 和 zoom (采用的)</h2><p>代码如下:<br><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt; </span><br><span class="line"><span class="selector-class">.div1</span>&#123;<span class="attribute">background</span>:<span class="number">#000080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;&#125; </span><br><span class="line"><span class="selector-class">.div2</span>&#123;<span class="attribute">background</span>:<span class="number">#800080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="attribute">height</span>:<span class="number">100px</span>;<span class="attribute">margin-top</span>:<span class="number">10px</span>&#125; </span><br><span class="line"><span class="selector-class">.left</span>&#123;<span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">20%</span>;<span class="attribute">height</span>:<span class="number">200px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line"><span class="selector-class">.right</span>&#123;<span class="attribute">float</span>:right;<span class="attribute">width</span>:<span class="number">30%</span>;<span class="attribute">height</span>:<span class="number">80px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line"><span class="comment">/*清除浮动代码*/</span> </span><br><span class="line"><span class="selector-class">.clearfloat</span><span class="selector-pseudo">:after</span>&#123;<span class="attribute">display</span>:block;<span class="attribute">clear</span>:both;<span class="attribute">content</span>:<span class="string">""</span>;<span class="attribute">visibility</span>:hidden;<span class="attribute">height</span>:<span class="number">0</span>&#125; </span><br><span class="line"><span class="selector-class">.clearfloat</span>&#123;<span class="attribute">zoom</span>:<span class="number">1</span>&#125; </span><br><span class="line">&lt;/style&gt; </span><br><span class="line">&lt;div class="div1 clearfloat"&gt; </span><br><span class="line">&lt;div class="left"&gt;Left&lt;/div&gt; </span><br><span class="line">&lt;div class="right"&gt;Right&lt;/div&gt; </span><br><span class="line">&lt;/div&gt; </span><br><span class="line">&lt;div class="div2"&gt; </span><br><span class="line"><span class="selector-tag">div2</span> </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题 </p><p>优点：浏览器支持好、不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等） </p><p>缺点：代码多、不少初学者不理解原理，要两句代码结合使用才能让主流浏览器都支持。 </p><p>建议：推荐使用，建议定义公共类，以减少CSS代码。</p><h2 id="父级div定义-overflow-hidden"><a href="#父级div定义-overflow-hidden" class="headerlink" title="父级div定义 overflow:hidden"></a>父级div定义 overflow:hidden</h2><p>代码如下:<br><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt; </span><br><span class="line"><span class="selector-class">.div1</span>&#123;<span class="attribute">background</span>:<span class="number">#000080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="comment">/*解决代码*/</span><span class="attribute">width</span>:<span class="number">98%</span>;<span class="attribute">overflow</span>:hidden&#125; </span><br><span class="line"><span class="selector-class">.div2</span>&#123;<span class="attribute">background</span>:<span class="number">#800080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="attribute">height</span>:<span class="number">100px</span>;<span class="attribute">margin-top</span>:<span class="number">10px</span>;<span class="attribute">width</span>:<span class="number">98%</span>&#125; </span><br><span class="line"><span class="selector-class">.left</span>&#123;<span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">20%</span>;<span class="attribute">height</span>:<span class="number">200px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line"><span class="selector-class">.right</span>&#123;<span class="attribute">float</span>:right;<span class="attribute">width</span>:<span class="number">30%</span>;<span class="attribute">height</span>:<span class="number">80px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line">&lt;/style&gt; </span><br><span class="line">&lt;div class="div1"&gt; </span><br><span class="line">&lt;div class="left"&gt;Left&lt;/div&gt; </span><br><span class="line">&lt;div class="right"&gt;Right&lt;/div&gt; </span><br><span class="line">&lt;/div&gt; </span><br><span class="line">&lt;div class="div2"&gt; </span><br><span class="line"><span class="selector-tag">div2</span> </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度 </p><p>优点：简单、代码少、浏览器支持好 </p><p>缺点：不能和position配合使用，因为超出的尺寸的会被隐藏。 </p><p>建议：只推荐没有使用position或对overflow:hidden理解比较深的朋友使用。</p><h2 id="父级div定义-overflow-auto"><a href="#父级div定义-overflow-auto" class="headerlink" title="父级div定义 overflow:auto"></a>父级div定义 overflow:auto</h2><p>代码如下:<br><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt; </span><br><span class="line"><span class="selector-class">.div1</span>&#123;<span class="attribute">background</span>:<span class="number">#000080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="comment">/*解决代码*/</span><span class="attribute">width</span>:<span class="number">98%</span>;<span class="attribute">overflow</span>:auto&#125; </span><br><span class="line"><span class="selector-class">.div2</span>&#123;<span class="attribute">background</span>:<span class="number">#800080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="attribute">height</span>:<span class="number">100px</span>;<span class="attribute">margin-top</span>:<span class="number">10px</span>;<span class="attribute">width</span>:<span class="number">98%</span>&#125; </span><br><span class="line"><span class="selector-class">.left</span>&#123;<span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">20%</span>;<span class="attribute">height</span>:<span class="number">200px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line"><span class="selector-class">.right</span>&#123;<span class="attribute">float</span>:right;<span class="attribute">width</span>:<span class="number">30%</span>;<span class="attribute">height</span>:<span class="number">80px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line">&lt;/style&gt; </span><br><span class="line">&lt;div class="div1"&gt; </span><br><span class="line">&lt;div class="left"&gt;Left&lt;/div&gt; </span><br><span class="line">&lt;div class="right"&gt;Right&lt;/div&gt; </span><br><span class="line">&lt;/div&gt; </span><br><span class="line">&lt;div class="div2"&gt; </span><br><span class="line"><span class="selector-tag">div2</span> </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>原理：必须定义width或zoom:1，同时不能定义height，使用overflow:auto时，浏览器会自动检查浮动区域的高度 </p><p>优点：简单、代码少、浏览器支持好 </p><p>缺点：内部宽高超过父级div时，会出现滚动条。 </p><p>建议：不推荐使用，如果你需要出现滚动条或者确保你的代码不会出现滚动条就使用吧。 </p><h2 id="父级div-也一起浮动"><a href="#父级div-也一起浮动" class="headerlink" title="父级div 也一起浮动"></a>父级div 也一起浮动</h2><p>代码如下:<br><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt; </span><br><span class="line"><span class="selector-class">.div1</span>&#123;<span class="attribute">background</span>:<span class="number">#000080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="comment">/*解决代码*/</span><span class="attribute">width</span>:<span class="number">98%</span>;<span class="attribute">margin-bottom</span>:<span class="number">10px</span>;<span class="attribute">float</span>:left&#125; </span><br><span class="line"><span class="selector-class">.div2</span>&#123;<span class="attribute">background</span>:<span class="number">#800080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="attribute">height</span>:<span class="number">100px</span>;<span class="attribute">width</span>:<span class="number">98%</span>;<span class="comment">/*解决代码*/</span><span class="attribute">clear</span>:both&#125; </span><br><span class="line"><span class="selector-class">.left</span>&#123;<span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">20%</span>;<span class="attribute">height</span>:<span class="number">200px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line"><span class="selector-class">.right</span>&#123;<span class="attribute">float</span>:right;<span class="attribute">width</span>:<span class="number">30%</span>;<span class="attribute">height</span>:<span class="number">80px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line">&lt;/style&gt; </span><br><span class="line">&lt;div class="div1"&gt; </span><br><span class="line">&lt;div class="left"&gt;Left&lt;/div&gt; </span><br><span class="line">&lt;div class="right"&gt;Right&lt;/div&gt; </span><br><span class="line">&lt;/div&gt; </span><br><span class="line">&lt;div class="div2"&gt; </span><br><span class="line"><span class="selector-tag">div2</span> </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>原理：所有代码一起浮动，就变成了一个整体 </p><p>优点：没有优点 </p><p>缺点：会产生新的浮动问题。 </p><p>建议：不推荐使用，只作了解。 </p><h2 id="父级div定义-display-table"><a href="#父级div定义-display-table" class="headerlink" title="父级div定义 display:table"></a>父级div定义 display:table</h2><p>代码如下:<br><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt; </span><br><span class="line"><span class="selector-class">.div1</span>&#123;<span class="attribute">background</span>:<span class="number">#000080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="comment">/*解决代码*/</span><span class="attribute">width</span>:<span class="number">98%</span>;<span class="attribute">display</span>:table;<span class="attribute">margin-bottom</span>:<span class="number">10px</span>;&#125; </span><br><span class="line"><span class="selector-class">.div2</span>&#123;<span class="attribute">background</span>:<span class="number">#800080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="attribute">height</span>:<span class="number">100px</span>;<span class="attribute">width</span>:<span class="number">98%</span>;&#125; </span><br><span class="line"><span class="selector-class">.left</span>&#123;<span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">20%</span>;<span class="attribute">height</span>:<span class="number">200px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line"><span class="selector-class">.right</span>&#123;<span class="attribute">float</span>:right;<span class="attribute">width</span>:<span class="number">30%</span>;<span class="attribute">height</span>:<span class="number">80px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line">&lt;/style&gt; </span><br><span class="line">&lt;div class="div1"&gt; </span><br><span class="line">&lt;div class="left"&gt;Left&lt;/div&gt; </span><br><span class="line">&lt;div class="right"&gt;Right&lt;/div&gt; </span><br><span class="line">&lt;/div&gt; </span><br><span class="line">&lt;div class="div2"&gt; </span><br><span class="line"><span class="selector-tag">div2</span> </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>原理：将div属性变成表格 </p><p>优点：没有优点 </p><p>缺点：会产生新的未知问题。 </p><p>建议：不推荐使用，只作了解。 </p><h2 id="结尾处加-br标签-clear-both"><a href="#结尾处加-br标签-clear-both" class="headerlink" title="结尾处加 br标签 clear:both"></a>结尾处加 br标签 clear:both</h2><p>代码如下:<br><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt; </span><br><span class="line"><span class="selector-class">.div1</span>&#123;<span class="attribute">background</span>:<span class="number">#000080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="attribute">margin-bottom</span>:<span class="number">10px</span>;<span class="attribute">zoom</span>:<span class="number">1</span>&#125; </span><br><span class="line"><span class="selector-class">.div2</span>&#123;<span class="attribute">background</span>:<span class="number">#800080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="attribute">height</span>:<span class="number">100px</span>&#125; </span><br><span class="line"><span class="selector-class">.left</span>&#123;<span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">20%</span>;<span class="attribute">height</span>:<span class="number">200px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line"><span class="selector-class">.right</span>&#123;<span class="attribute">float</span>:right;<span class="attribute">width</span>:<span class="number">30%</span>;<span class="attribute">height</span>:<span class="number">80px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125; </span><br><span class="line"><span class="selector-class">.clearfloat</span>&#123;<span class="attribute">clear</span>:both&#125; </span><br><span class="line">&lt;/style&gt; </span><br><span class="line">&lt;div class="div1"&gt; </span><br><span class="line">&lt;div class="left"&gt;Left&lt;/div&gt; </span><br><span class="line">&lt;div class="right"&gt;Right&lt;/div&gt; </span><br><span class="line">&lt;br class="clearfloat" /&gt; </span><br><span class="line">&lt;/div&gt; </span><br><span class="line">&lt;div class="div2"&gt; </span><br><span class="line"><span class="selector-tag">div2</span> </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>原理：父级div定义zoom:1来解决IE浮动问题，结尾处加 br标签 clear:both </p><p>建议：不推荐使用，只作了解。</p><h1 id="原生JS给元素添加class属性"><a href="#原生JS给元素添加class属性" class="headerlink" title="原生JS给元素添加class属性"></a>原生JS给元素添加class属性</h1><p>有下面三种语句：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>].className = <span class="string">'snow-container'</span>; <span class="comment">//设置为新的</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>].className += <span class="string">'snow-container'</span>; <span class="comment">//在原来的后面加这个</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>].classList.add(<span class="string">"snow-container"</span>); <span class="comment">//与第一个等价</span></span><br></pre></td></tr></table></figure></p><p>用第三种<br>因为第一种是直接将旧的class改为新的<br>第二种实在旧的class基础上像字符串拼接一样<br>只有第三种实现了目的</p><h1 id="Flex-布局"><a href="#Flex-布局" class="headerlink" title="Flex 布局"></a>Flex 布局</h1><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">点击这里</a></p><h1 id="ul内容自适应居中"><a href="#ul内容自适应居中" class="headerlink" title="ul内容自适应居中"></a>ul内容自适应居中</h1><p>在开发过程中，想到一个问题，平时对块级元素居中的时候都是定义一个宽度然后简单的通过margin:0 auto;实现，但是如果内容增加，是不是每次都需要修改宽度呢。我觉得需要思考一个自适应内容，并居中的方案。<br><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'container'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"clearfix"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:void(0);"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:void(0);"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:void(0);"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">''</span>;</span><br><span class="line">    <span class="attribute">visibility</span>:hidden;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">text-align</span>:center;          </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">ul</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">li</span>&#123;</span><br><span class="line">     <span class="attribute">float</span>:left;</span><br><span class="line">     <span class="attribute">width</span>:<span class="number">20px</span>;</span><br><span class="line">     <span class="attribute">height</span>:<span class="number">20px</span>;</span><br><span class="line">     <span class="attribute">margin</span>:<span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">     <span class="attribute">-webkit-border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">     <span class="attribute">-moz-border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">     <span class="attribute">-o-border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">     <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">     <span class="attribute">cursor</span>:pointer;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这实现思想是，先让ul定义 display:inline-block 属性，让其变成行内块级元素。</p><p>当ul成为行内块级元素后，它便有了行级元素的特性。</p><p>那么，重点来了。</p><p>只需要对ul的父级元素 .container 定义一个text-align:center;</p><p>效果便可以很明显的看到了。</p><p>更重点是，ul内的li的增减并不会对其位置造成偏移。</p><h1 id="css-行高-line-height"><a href="#css-行高-line-height" class="headerlink" title="css 行高 line-height"></a>css 行高 line-height</h1><p><a href="http://www.zhangxinxu.com/wordpress/2009/11/css%E8%A1%8C%E9%AB%98line-height%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">点击这里</a></p>]]></content>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>由Blocking Search动画引出的知识点2</title>
      <link href="/2018/02/06/BlockingSearch-JS2/"/>
      <url>/2018/02/06/BlockingSearch-JS2/</url>
      <content type="html"><![CDATA[<h1 id="调用含有-setInterval-的函数时异步问题的解决"><a href="#调用含有-setInterval-的函数时异步问题的解决" class="headerlink" title="调用含有 setInterval 的函数时异步问题的解决"></a>调用含有 setInterval 的函数时异步问题的解决</h1><p>重点：使用 async/await 与 Promise 对象</p><h2 id="在代码中引用"><a href="#在代码中引用" class="headerlink" title="在代码中引用"></a>在代码中引用</h2><ul><li>引用前（有问题的代码）<figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> linearSearch = <span class="function"><span class="keyword">function</span> (<span class="params">desired_letter, array, flag</span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line">linear_interval = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (current_index &gt;= array.length) &#123;</span><br><span class="line">clearInterval(linear_interval);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (current_value &gt;= desired_letter) &#123;</span><br><span class="line">clearInterval(linear_interval);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> current_index;</span><br><span class="line">&#125;</span><br><span class="line">current_index += <span class="number">1</span>;</span><br><span class="line">&#125;, SEARCH_INTERVAL_TIME/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ## Blocking Search</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">startBlockingSearch</span>(<span class="params">desired_letter, array</span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> which_block = linearSearch(desired_letter, block_arr, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"which_block = "</span>, which_block);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这里遇到了 which_block 打印出来始终为 undefined 的问题。</p><ul><li><p>问题解决后的代码</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> linearSearch = <span class="function"><span class="keyword">function</span> (<span class="params">desired_letter, array, flag</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">...</span><br><span class="line">linear_interval = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (current_index &gt;= array.length) &#123;</span><br><span class="line">clearInterval(linear_interval);</span><br><span class="line">resolve(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (current_value &gt;= desired_letter) &#123;</span><br><span class="line">clearInterval(linear_interval);</span><br><span class="line">...</span><br><span class="line">resolve(current_index);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;, SEARCH_INTERVAL_TIME/<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ## Blocking Search</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">startBlockingSearch</span>(<span class="params">desired_letter, array</span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> which_block = <span class="keyword">await</span> linearSearch(desired_letter, block_arr, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"which_block = "</span>, which_block);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>需要注意的地方</p><ul><li>在 async 的函数（这里是 startBlockingSearch 函数）里面引用的函数（这里是 linearSearch 函数）的真正返回值需要用 <strong><code>resolve</code></strong> 包裹起来</li><li>且引用的函数必须再用 <strong>return new Promise(function(resolve, reject){…}</strong> 嵌套一次</li></ul></li></ul><h2 id="关于Promise对象"><a href="#关于Promise对象" class="headerlink" title="关于Promise对象"></a>关于Promise对象</h2><h3 id="一些参考链接"><a href="#一些参考链接" class="headerlink" title="一些参考链接"></a>一些参考链接</h3><ul><li><p><a href="https://www.cnblogs.com/blog-index/p/6637543.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">JS Promise API</a></p><ul><li><p>主要内容：<br><strong>Promise 三状态</strong></p><ul><li>pending：初始状态，未完成或拒绝</li><li>fulfilled：操作成功完成[Resolved（已完成，又称 Fulfilled）]</li><li><p>rejected：操作失败</p><p>pending状态的Promise对象可能被填充了（fulfilled）值，也可能被某种理由（异常信息）拒绝（reject）了。当其中任一种情况出现时，Promise对象的then方法绑定的处理方法（handlers ）就会被调用(then方法包含两个参数：onfulfilled和onrejected，它们都是Function类型。当值被填充时，调用then的onfulfilled方法，当Promise被拒绝时，调用then的onrejected方法， 所以在异步操作的完成和绑定处理方法之间不存在竞争)</p><p>因为Promise.prototype.then和 Promise.prototype.catch方法返回 promises对象自身， 所以它们可以被链式调用.</p><p><img src="https://raw.githubusercontent.com/Yojiaku/hexoBlogPic/566b52408c23a0153c65326a68039833de085a39/promise.png" alt="promise"></p></li></ul><p><strong>Promise API</strong></p><ul><li>Promise.resolve() 执行成功</li><li>Promise.reject() 执行失败</li><li>Promise.prototype.then() 递延处理</li><li>Promise.prototype.catch() 异常</li></ul></li></ul></li><li><p><a href="https://www.cnblogs.com/dojo-lzz/p/4340897.html" target="_blank" rel="noopener">闲话Promise机制</a></p></li><li><p><a href="https://www.jianshu.com/p/063f7e490e9a" target="_blank" rel="noopener">Javascript 中的神器——Promise</a></p><ul><li><p>主要内容：<br><strong>封装代码与异步代码</strong></p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">resolve(someValue);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">写成</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve(someValue);</span><br></pre></td></tr></table></figure><p><strong>捕获同步异常</strong></p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'悲剧了，又出 bug 了'</span>);</span><br><span class="line"> &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><a href="http://www.zhangxinxu.com/wordpress/2014/02/es6-javascript-promise-%E6%84%9F%E6%80%A7%E8%AE%A4%E7%9F%A5/" target="_blank" rel="noopener">ES6 JavaScript Promise的感性认知</a></li><li><a href="https://www.cnblogs.com/yunfeifei/p/4453690.html" target="_blank" rel="noopener">JavaScript进阶之路——认识和使用Promise，重构你的Js代码</a></li><li><a href="http://blog.csdn.net/jasonzds/article/details/53717501" target="_blank" rel="noopener">JavaScript再述promise的用法和常用方法</a></li></ul><h2 id="关于async-与-await"><a href="#关于async-与-await" class="headerlink" title="关于async 与 await"></a>关于async 与 await</h2><h3 id="一些参考链接-1"><a href="#一些参考链接-1" class="headerlink" title="一些参考链接"></a>一些参考链接</h3><ul><li><p><a href="https://www.cnblogs.com/cpselvis/p/6344122.html" target="_blank" rel="noopener">Javascript中的async await</a></p><ul><li><p>注意点：</p><ul><li>async用来申明里面包裹的内容可以进行同步的方式执行，await则是进行执行顺序控制，每次执行一个await，程序都会暂停等待await返回值，然后再执行之后的await。</li><li>await后面调用的函数需要返回一个promise，另外这个函数是一个普通的函数即可，而不是generator。</li><li><p>await只能用在async函数之中，用在普通函数中会报错。</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  docs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</span><br><span class="line"><span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上面代码会报错，因为 await 用在普通函数之中了。但是，如果将 forEach 方法的参数改成 async 函数，也有问题。</p>  <figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可能得到错误结果</span></span><br><span class="line">  docs.forEach(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</span><br><span class="line"><span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上面代码可能不会正常工作，原因是这时三个 db.post 操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用 for 循环。</p>  <figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> doc <span class="keyword">of</span> docs) &#123;</span><br><span class="line"><span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  如果确实希望多个请求并发执行，可以使用 Promise.all 方法。</p>  <figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.map(<span class="function">(<span class="params">doc</span>) =&gt;</span> db.post(doc));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(promises);</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用下面的写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.map(<span class="function">(<span class="params">doc</span>) =&gt;</span> db.post(doc));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> results = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">results.push(<span class="keyword">await</span> promise);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><pre><code>+ await命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try...catch 代码块中。<figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">await</span> somethingThatReturnsAPromise();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> somethingThatReturnsAPromise().catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p><a href="http://www.ruanyifeng.com/blog/2015/05/async.html" target="_blank" rel="noopener">async 函数的含义和用法</a></p><ul><li>示例：指定多少毫秒后输出一个值。(指定50毫秒以后，输出”hello world”。)<figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> timeout(ms);</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncPrint(<span class="string">'hello world'</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><a href="https://segmentfault.com/a/1190000007535316" target="_blank" rel="noopener">理解JavaScript的async/await</a><br><strong> 这篇很重要 </strong></p></li><li><p><a href="http://cnodejs.org/topic/5976b6d668aa87c774e5eb85" target="_blank" rel="noopener">用async/await多个返回值的方法，可以直接接收吗？比如 var value = request(url);</a></p></li></ul><h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p><img src="https://raw.githubusercontent.com/Yojiaku/hexoBlogPic/8906194b095bc9b644f5697ea9f7091b5853eed5/blockingSearch02.gif" alt="blockingSearch02.GIF"></p><h1 id="动态添加li的方法"><a href="#动态添加li的方法" class="headerlink" title="动态添加li的方法"></a>动态添加li的方法</h1><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line"><span class="keyword">var</span> node = <span class="built_in">document</span>.createElement(<span class="string">"LI"</span>);</span><br><span class="line"><span class="keyword">var</span> text = index_table_key[i].innerHTML;</span><br><span class="line"><span class="keyword">var</span> textnode = <span class="built_in">document</span>.createTextNode(text);</span><br><span class="line">block_arr.push(text);</span><br><span class="line">node.setAttribute(<span class="string">'id'</span>, text+<span class="string">'-linear'</span>);</span><br><span class="line">node.appendChild(textnode);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'block-linear-search'</span>).appendChild(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>由编写Blocking Search动画引出的知识点</title>
      <link href="/2018/02/06/BlockingSearch-JS/"/>
      <url>/2018/02/06/BlockingSearch-JS/</url>
      <content type="html"><![CDATA[<h1 id="动画控制-定时器"><a href="#动画控制-定时器" class="headerlink" title="动画控制-定时器"></a>动画控制-定时器</h1><p>引用自：<a href="https://www.zhihu.com/question/31636244" target="_blank" rel="noopener">异步控制完成sleep功能</a><br>具体如下：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>)</span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">1000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'world!'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, ms))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure></p><p>关键点：</p><ul><li>async</li><li>await</li><li>Promise对象</li><li>setTimeout</li><li>“=&gt;”箭头函数<br>在Blocking Search动画中的应用：<figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, ms));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">startBlockingSearch</span>(<span class="params">desired_letter, array</span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=BLOCK_NUM; i++) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">await</span> sleep(SEARCH_INTERVAL_TIME/<span class="number">2</span>);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>实现效果：<br><img src="https://raw.githubusercontent.com/Yojiaku/hexoBlogPic/8a643fbd83faf6fc6a39c34a2969631406021177/blockingSearch01.gif" alt="blocking search"></p><h1 id="JS动态命名变量名"><a href="#JS动态命名变量名" class="headerlink" title="JS动态命名变量名"></a>JS动态命名变量名</h1><h2 id="法一：用eval"><a href="#法一：用eval" class="headerlink" title="法一：用eval"></a>法一：用eval</h2><p>例子如下：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Thread_num=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=Thread_num;i++)&#123;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"var set_"</span> + i + <span class="string">"="</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">alert(set_5);</span><br></pre></td></tr></table></figure></p><p>但是此方法有一个缺点：eval函数占用内存，建议用法二</p><h2 id="法二：用数组"><a href="#法二：用数组" class="headerlink" title="法二：用数组"></a>法二：用数组</h2><p>例子如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Thread_num=5;</span><br><span class="line">var arr=[];</span><br><span class="line">for(var i=1;i&lt;=Thread_num;i++)&#123;</span><br><span class="line">arr[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="在Blocking-Search动画中的应用："><a href="#在Blocking-Search动画中的应用：" class="headerlink" title="在Blocking Search动画中的应用："></a>在Blocking Search动画中的应用：</h2><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ID_index=[];</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=BLOCK_NUM; i++) &#123;</span><br><span class="line">...</span><br><span class="line">ID_index[i] = <span class="keyword">new</span> ID(key, start, end);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"ID_index"</span>+i+<span class="string">": key = "</span>+key+<span class="string">" start = "</span>+start+<span class="string">" end = "</span>+end);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JS中构建结构体数组"><a href="#JS中构建结构体数组" class="headerlink" title="JS中构建结构体数组"></a>JS中构建结构体数组</h1><h2 id="在Blocking-Search动画中的应用：-1"><a href="#在Blocking-Search动画中的应用：-1" class="headerlink" title="在Blocking Search动画中的应用："></a>在Blocking Search动画中的应用：</h2><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 块结构</span></span><br><span class="line"><span class="keyword">var</span> ID = <span class="function"><span class="keyword">function</span>(<span class="params">key, start, end</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">self.key = key;</span><br><span class="line">self.start = start;</span><br><span class="line">self.end = end;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">startBlockingSearch</span>(<span class="params">desired_letter, array</span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> key, start, end;</span><br><span class="line"><span class="keyword">var</span> ID_index=[];</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=BLOCK_NUM; i++) &#123;</span><br><span class="line">start = j+<span class="number">1</span>;</span><br><span class="line">j = j+<span class="number">1</span>;</span><br><span class="line">end = j+<span class="number">4</span>;</span><br><span class="line">j = j+<span class="number">4</span>;</span><br><span class="line">key = array[j];</span><br><span class="line">ID_index[i] = <span class="keyword">new</span> ID(key, start, end);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"ID_index"</span>+i+<span class="string">": key = "</span>+key+<span class="string">" start = "</span>+start+<span class="string">" end = "</span>+end);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>ID_index = []</code> 就是构建的结构体数组。</p><h1 id="原生JS如何删除Ul下class为active的li-（没有用到，偶然搜到）"><a href="#原生JS如何删除Ul下class为active的li-（没有用到，偶然搜到）" class="headerlink" title="原生JS如何删除Ul下class为active的li （没有用到，偶然搜到）"></a>原生JS如何删除Ul下class为active的li （没有用到，偶然搜到）</h1><p>比如说，ul下有5个li，其中3个class是active的，我要把这3个元素节点删除，我写了这样的代码<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">oBtn2.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> aActive=oUl.getElementsByClassName(<span class="string">'active'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;aActive.length;i++)&#123;</span><br><span class="line">        oUl.removeChild(aActive[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当点击btn2时，首先获取oUl下所有class为active的li，然后遍历删除，我后来大概知道是哪里出的问题，就是每次删除一个后，aActive的个数变了，因为aActive是动态的。<br>我才学js不久，只知道removeChild删除单个节点的方法，还有什么简单的办法可以实现删除一堆节点么？</p><p>回答一：<br>将aActive长度保存即可，for(var i=0,len=aActive.length; i&lt;len; i++){oUl.removeChild(aActive[0])}，要注意的是低版本ie不支持getElementsByClassName方法，如果要兼容，要遍历所有节点查找。getElementsByTagName,getElementsByName这些方法都是动态，实时的，即是会根据节点的增删变化而变化的</p><p>回答二：<br>数组的splice()方法,aActive.splice(0,3)</p><p>回答三：<br><code>html</code><br><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Bin<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">'a'</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">'a'</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">'a'</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><code>javascript</code><br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn=<span class="built_in">document</span>.querySelector(<span class="string">'button'</span>);</span><br><span class="line"><span class="keyword">var</span> activeIlists=<span class="built_in">document</span>.getElementsByClassName(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">var</span> ul=<span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>);</span><br><span class="line">btn.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(activeIlists.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;=<span class="number">4</span>;i++)&#123;     </span><br><span class="line">     ul.removeChild(activeIlists[i]);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>实现效果：<a href="http://jsbin.com/coxejo/1/edit?html,js,output" target="_blank" rel="noopener">点击这里查看</a></p><p>回答四：从后往前删除，这样即使删除了li，也不会影响前面节点的位置。<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;<span class="xml"><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">&lt;ul&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li class="active"&gt;1&lt;/</span>li&gt;</span><br><span class="line">    &lt;li &gt;<span class="number">2</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li class="active"&gt;3&lt;/</span>li&gt;</span><br><span class="line">    &lt;li &gt;<span class="number">4</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li class="active"&gt;5&lt;/</span>li&gt;</span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">function removeByClass()</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        var ul = document.getElementsByTagName('ul')[0];</span></span><br><span class="line"><span class="string">        var _li = ul.getElementsByTagName('li');</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        for(var i = _li.length -1; i &gt;= 0; i--)&#123;</span></span><br><span class="line"><span class="string">            if(_li[i].className =='active')&#123;</span></span><br><span class="line"><span class="string">                ul.removeChild(_li[i]);</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">window.onload = removeByClass();</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>主要重点是removeChild 函数对DOM的即时影响。</strong></p><h1 id="JS在数组前添加元素"><a href="#JS在数组前添加元素" class="headerlink" title="JS在数组前添加元素"></a>JS在数组前添加元素</h1><p>用unshift方法：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]; </span><br><span class="line"><span class="keyword">var</span> b = a.unshift(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>则 a = [0,1,2,3,4,5];<br>b=6,即添加后数组长度</p><h1 id="JavaScript-String-slice-函数详解"><a href="#JavaScript-String-slice-函数详解" class="headerlink" title="JavaScript String.slice() 函数详解"></a>JavaScript String.slice() 函数详解</h1><p><a href="http://www.365mini.com/page/javascript-string-slice.htm" target="_blank" rel="noopener">点击这里</a></p><h1 id="getElementsByClassName-方法"><a href="#getElementsByClassName-方法" class="headerlink" title="getElementsByClassName() 方法"></a>getElementsByClassName() 方法</h1><p><a href="http://www.runoob.com/jsref/met-document-getelementsbyclassname.html" target="_blank" rel="noopener">点击这里</a></p><h1 id="CSS-变量"><a href="#CSS-变量" class="headerlink" title="CSS 变量"></a>CSS 变量</h1><p><a href="http://blog.csdn.net/u011043843/article/details/46480677" target="_blank" rel="noopener">点击这里</a></p><h2 id="在Blocking-Search动画中的应用：-2"><a href="#在Blocking-Search动画中的应用：-2" class="headerlink" title="在Blocking Search动画中的应用："></a>在Blocking Search动画中的应用：</h2><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义一些颜色变量 */</span></span><br><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line"><span class="comment">/* 分块区 */</span></span><br><span class="line">--block_1-color: FireBrick;</span><br><span class="line"><span class="selector-tag">--block_2-color</span>: <span class="selector-tag">DarkSeaGreen</span>;</span><br><span class="line"><span class="selector-tag">--block_3-color</span>: <span class="selector-tag">Bisque</span>;</span><br><span class="line"><span class="selector-tag">--block_4-color</span>: <span class="selector-tag">Aquamarine</span>;</span><br><span class="line"><span class="selector-tag">--block_5-color</span>: <span class="selector-tag">CornflowerBlue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.data</span> <span class="selector-tag">li</span><span class="selector-class">.block_1</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="built_in">var</span>(--block_1-color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.data</span> <span class="selector-tag">li</span><span class="selector-class">.block_2</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="built_in">var</span>(--block_2-color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.data</span> <span class="selector-tag">li</span><span class="selector-class">.block_3</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="built_in">var</span>(--block_3-color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.data</span> <span class="selector-tag">li</span><span class="selector-class">.block_4</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="built_in">var</span>(--block_4-color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.data</span> <span class="selector-tag">li</span><span class="selector-class">.block_5</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="built_in">var</span>(--block_5-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>删除元素所有子节点</title>
      <link href="/2018/02/05/remove-node-in-js/"/>
      <url>/2018/02/05/remove-node-in-js/</url>
      <content type="html"><![CDATA[<h1 id="删除元素所有子节点"><a href="#删除元素所有子节点" class="headerlink" title="删除元素所有子节点"></a>删除元素所有子节点</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elem = getElementById(<span class="string">"elem_id"</span>);  </span><br><span class="line">elem.innerHTML = <span class="string">""</span>;</span><br></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnDelete</span>(<span class="params"></span>)</span>&#123;   </span><br><span class="line">    <span class="keyword">var</span> elem = getElementById(<span class="string">"elem_id"</span>);  </span><br><span class="line">    <span class="keyword">while</span>(elem.hasChildNodes()) <span class="comment">//当elem下还存在子节点时 循环继续  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        elem.removeChild(elem.firstChild);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnDelete</span>(<span class="params"></span>)</span>&#123;   </span><br><span class="line">    <span class="keyword">var</span> elem = getElementById(<span class="string">"elem_id"</span>);  </span><br><span class="line">    <span class="keyword">while</span>(elem.lastChild) <span class="comment">//当div下还存在最后的子节点时 循环继续&lt;/span&gt;&lt;span style="font-size:14px;"&gt;  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        elem.removeChild(elem.lastChild);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h2><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnDelete</span>(<span class="params"></span>)</span>&#123;   </span><br><span class="line">    <span class="keyword">var</span> elem = getElementById(<span class="string">"elem_id"</span>);  </span><br><span class="line">    <span class="keyword">var</span> childs = elem.childNodes;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=childs.length<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;      </span><br><span class="line">        elem.removeChild(childs.item(i));      </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法五"><a href="#方法五" class="headerlink" title="方法五"></a>方法五</h2><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#elem_id"</span>).empty();</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C语言概览（基础）</title>
      <link href="/2018/02/02/C-Introduction/"/>
      <url>/2018/02/02/C-Introduction/</url>
      <content type="html"><![CDATA[<h2 id="入门知识（hello-world级别）"><a href="#入门知识（hello-world级别）" class="headerlink" title="入门知识（hello world级别）"></a>入门知识（hello world级别）</h2><h2 id="printf"><a href="#printf" class="headerlink" title="printf()"></a>printf()</h2><p>printf函数永远不会自动换行。<br>“\n”只代表一个字符。类似于 <code>\n</code> 的转义字符序列为表示无法输入的字符或不可见的字符提供了一种通用的可扩充机制。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>变量类型：<ul><li>int         整型（16位）</li><li>float        浮点型（32位）-至少6位有效数字</li><li>char         字符-一个字节</li><li>short     短整型</li><li>long         长整型</li><li>double     双精度浮点型</li></ul></li><li>符号常量：<br>  “幻数”：指200、30这种数字，不能向以后阅读该程序的人提供什么信息，而且程序修改困难。<br>  “常量”：给幻数赋予有意义的名字<pre><code>工具：#define 名字 替换文本</code></pre></li><li><p>字符输入/输出<br>  无论文本从何处输入，输出到何处，其输入/输出都是按照字符流的方式处理。文本流是由多行字符构成的字符序列，而每行字符则有0个或多个字符组成，行末是一个换行符。<br>  getchar()与putchar()</p><pre><code>+ 每次调用时，getchar从文本流中读入下一个输入字符，并将其作为结果值返回。即：在执行语句<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = getchar();</span><br></pre></td></tr></table></figure>之后，变量 c 将包含输入流中的下一个字符。这种字符通常是通过**键盘**输入的。+ 每次调用 putchar 时将打印出一个字符，例如：<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">putchar</span>();</span><br></pre></td></tr></table></figure>将把整型变量 c 的内容以**字符**的形式打印出来，通常是显示在屏幕上。+ putchar 与 getchar 可以交替调用，输出的次序与调用次序一致。+ 文件复制<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="comment">/* copy input to output; 1st version */</span></span><br><span class="line"> main()</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">int</span> c;</span><br><span class="line"> c = getchar();</span><br><span class="line"> <span class="keyword">while</span> (c != EOF) &#123;</span><br><span class="line"><span class="built_in">putchar</span>(c);</span><br><span class="line">c = getchar();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>&gt; 字符在键盘、屏幕或者其他任何地方无论以什么形式表现，它在机器内部都是以位模式存储的。char类型专门用于存储这种字符型数据，当然 int 也可以用于存储字符型数据，因为某种原因，这里使用 int。</code></pre></li></ul><h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><p>例子：读入一组文本行，并把最长的文本行打印出来<br><figure class="hljs highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (还有未处理的行)</span><br><span class="line"><span class="keyword">if</span> (该行比已处理的最长行还要长)</span><br><span class="line">保存该行为最长行</span><br><span class="line">保存该行的长度</span><br><span class="line">打印最长的行</span><br></pre></td></tr></table></figure></p><p>编写 getline 函数：读取输入的下一行，在督导文件末尾时返回一个信号（更好的是能够在读入文本行时返回该行的长度，而在遇到文件结束符时返回 0 ）。且只包含换行符的行，其长度为1.<br>编写 copy 函数：发现某个新读入的行比以前读入的最长行还要长时，就需要把该行保存起来，即 copy 到另一个安全的位置。<br>程序如下：<br><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/* maximum input line length */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 1000 </span></span><br><span class="line"><span class="keyword">int</span> _getline(<span class="keyword">char</span> line[], <span class="keyword">int</span> maxline);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(<span class="keyword">char</span> to[], <span class="keyword">char</span> from[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* print the longest input line */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len;<span class="comment">/* current line length */</span></span><br><span class="line"><span class="keyword">int</span> max; <span class="comment">/* maximum length seen so far */</span></span><br><span class="line"><span class="keyword">char</span> line[MAXLINE];<span class="comment">/* current input line */</span></span><br><span class="line"><span class="keyword">char</span> longest[MAXLINE]; <span class="comment">/* longest line saved here */</span></span><br><span class="line"></span><br><span class="line">max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((len = _getline(line, MAXLINE)) &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (len &gt; max) &#123;</span><br><span class="line">max = len;</span><br><span class="line">copy(longest, line);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (max &gt; <span class="number">0</span>) <span class="comment">/* there was a line */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, longest);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* getline: read a line into line, return maxline */</span></span><br><span class="line"><span class="keyword">int</span> _getline(<span class="keyword">char</span> line[], <span class="keyword">int</span> maxline) &#123;</span><br><span class="line"><span class="keyword">int</span> c, i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;maxline<span class="number">-1</span> &amp;&amp; (c=getchar())!=EOF &amp;&amp; c!=<span class="string">'\n'</span>; ++i)</span><br><span class="line">line[i] = c;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'\n'</span>) &#123;</span><br><span class="line">line[i] = c;</span><br><span class="line">++i;</span><br><span class="line">&#125;</span><br><span class="line">line[i] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* copy: copy 'from' into 'to'; assume to is big enough */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(<span class="keyword">char</span> to[], <span class="keyword">char</span> from[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((to[i] = from[i]) != <span class="string">'\0'</span>)</span><br><span class="line">++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> C-languge </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS实现linearSearch动画时遇到的知识点</title>
      <link href="/2018/02/01/linearSearch-questions/"/>
      <url>/2018/02/01/linearSearch-questions/</url>
      <content type="html"><![CDATA[<h1 id="JS实现linearSearch动画时遇到的知识点"><a href="#JS实现linearSearch动画时遇到的知识点" class="headerlink" title="JS实现linearSearch动画时遇到的知识点"></a>JS实现linearSearch动画时遇到的知识点</h1><p>标签（空格分隔）： JavaScript </p><hr><h2 id="arguments-对象"><a href="#arguments-对象" class="headerlink" title="arguments 对象"></a>arguments 对象</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><code>arguments</code>是一个对应于传递给函数的参数的类数组对象。<br>    <strong>重点：</strong>类数组对象</p><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><code>arguments</code>对象是所有（非箭头）函数中都可用的局部变量。可以使用<code>arguments</code>对象在函数中引用函数的参数。此对象包含传递给函数的每个参数的条目，第一个条目索引从0开始。<br>例如：若一个函数传递了三个参数，可以用下列方式引用：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// expected output: 1</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  <span class="comment">// expected output: 2</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">2</span>]);</span><br><span class="line">  <span class="comment">// expected output: 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></p><p>输出结果：即arguments[0] 对应 参数a；arguments[1] 对应 参数b；arguments[2] 对应 参数c<br><figure class="hljs highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1</span></span><br><span class="line">&gt; <span class="number">2</span></span><br><span class="line">&gt; <span class="number">3</span></span><br></pre></td></tr></table></figure></p><p><code>arguments</code>对象不是一个<code>Array</code>，但它类似于<code>Array</code>，其除了length属性和索引元素之外没有任何<code>Array</code>属性。例如，它没有<code>pop</code>方法，但是它可以被转换为一个真正的<code>Array</code>：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES2015</span></span><br><span class="line"><span class="keyword">const</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：对参数使用slice会阻止某些js引擎中的优化，另一种方式是：<br>    <figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = (<span class="built_in">arguments</span>.length === <span class="number">1</span> ? [<span class="built_in">arguments</span>[<span class="number">0</span>]] : <span class="built_in">Array</span>.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>));</span><br></pre></td></tr></table></figure></p></blockquote><p>如果调用的参数多于正式声明接受的参数，则可以使用<code>arguments</code>对象。（<strong>对可以传递可变数量的参数的函数很有用</strong>)。使用<code>arguments.length</code>来确定传递给函数参数的个数，然后使用<code>arguments</code>对象来处理每个参数。要确定函数<strong>签名</strong>中参数的数量，使用<code>Function.length</code>属性。</p><h3 id="对参数使用-typeof"><a href="#对参数使用-typeof" class="headerlink" title="对参数使用 typeof"></a>对参数使用 typeof</h3><p>typeof参数返回“object”。<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">arguments</span>); <span class="comment">// 'object'</span></span><br></pre></td></tr></table></figure></p><p>可以使用索引确定单个参数的类型。<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">//this will return the typeof individual arguments.</span></span><br></pre></td></tr></table></figure></p><h3 id="对参数使用扩展语法"><a href="#对参数使用扩展语法" class="headerlink" title="对参数使用扩展语法"></a>对参数使用扩展语法</h3><p>还可以使用<code>Array.from()</code>方法或<strong>扩展运算符</strong>将参数转换为真实数组：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="keyword">var</span> args = [...arguments];</span><br></pre></td></tr></table></figure></p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>arguments.callee 指向当前执行的函数</li><li>arguments.caller 指向调用当前函数的函数</li><li>arguments.length 指向传递给当前函数的参数数量</li><li>arguments[@@iterator] 返回一个新的Array迭代器对象，改对象包含参数中每个索引的值。</li></ul><blockquote><p>注意：在严格模式下，<code>arguments</code>对象与之前不同。<code>arguments[@@iterator]</code>不再与函数的实际形参之间共享，同时caller属性也被移除。</p></blockquote><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="定义链接字符串的函数"><a href="#定义链接字符串的函数" class="headerlink" title="定义链接字符串的函数"></a>定义链接字符串的函数</h4><p>这个例子定义了一个函数来连接字符串。这个函数唯一正式声明了的参数是一个字符串，该参数指定一个字符作为衔接点来连接字符串。该函数定义如下：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myConcat</span>(<span class="params">separator</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> args.join(separator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你可以传递任意数量的参数到该函数，并使用每个参数作为列表中的项创建列表。<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// returns "red, orange, blue"</span></span><br><span class="line">myConcat(<span class="string">", "</span>, <span class="string">"red"</span>, <span class="string">"orange"</span>, <span class="string">"blue"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// returns "elephant; giraffe; lion; cheetah"</span></span><br><span class="line">myConcat(<span class="string">"; "</span>, <span class="string">"elephant"</span>, <span class="string">"giraffe"</span>, <span class="string">"lion"</span>, <span class="string">"cheetah"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// returns "sage. basil. oregano. pepper. parsley"</span></span><br><span class="line">myConcat(<span class="string">". "</span>, <span class="string">"sage"</span>, <span class="string">"basil"</span>, <span class="string">"oregano"</span>, <span class="string">"pepper"</span>, <span class="string">"parsley"</span>);</span><br></pre></td></tr></table></figure></p><h4 id="定义创建html列表的方法"><a href="#定义创建html列表的方法" class="headerlink" title="定义创建html列表的方法"></a>定义创建html列表的方法</h4><p>这个例子定义了一个函数通过一个字符串来创建HTML列表。这个函数唯一正式声明了的参数是一个字符。当该参数为 “u” 时，创建一个无序列表 (项目列表)；当该参数为 “o” 时，则创建一个有序列表 (编号列表)。该函数定义如下：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">list</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">"&lt;"</span> + type + <span class="string">"l&gt;&lt;li&gt;"</span>;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  result += args.join(<span class="string">"&lt;/li&gt;&lt;li&gt;"</span>);</span><br><span class="line">  result += <span class="string">"&lt;/li&gt;&lt;/"</span> + type + <span class="string">"l&gt;"</span>; <span class="comment">// end list</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你可以传递任意数量的参数到该函数，并将每个参数作为一个项添加到指定类型的列表中。例如：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> listHTML = list(<span class="string">"u"</span>, <span class="string">"One"</span>, <span class="string">"Two"</span>, <span class="string">"Three"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* listHTML is:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">"&lt;ul&gt;&lt;li&gt;One&lt;/li&gt;&lt;li&gt;Two&lt;/li&gt;&lt;li&gt;Three&lt;/li&gt;&lt;/ul&gt;"</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><h4 id="剩余参数、默认参数和解构赋值参数"><a href="#剩余参数、默认参数和解构赋值参数" class="headerlink" title="剩余参数、默认参数和解构赋值参数"></a>剩余参数、默认参数和解构赋值参数</h4><p><code>arguments</code>对象可以与<strong>剩余参数、默认参数、解构赋值</strong>参数结合使用。<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure></p><p>在严格模式下，剩余参数、默认参数和解构赋值参数的存在不会改变<code>arguments</code>对象的行为，但是在非严格模式下就有所不同了。</p><p>当非严格模式中的函数没有包含剩余参数、默认参数和解构赋值，那么<code>arguments</code>对象中的值<strong>会</strong>跟踪参数的值（反之亦然）。看下面的代码：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">99</span>;   <span class="comment">// 更新了arguments[0] 同样更新了a</span></span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">func(<span class="number">10</span>); <span class="comment">// 99</span></span><br></pre></td></tr></table></figure></p><p>并且<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a</span>) </span>&#123; </span><br><span class="line">  a = <span class="number">99</span>;              <span class="comment">// 更新了a 同样更新了arguments[0] </span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">func(<span class="number">10</span>); <span class="comment">// 99</span></span><br></pre></td></tr></table></figure></p><p>当非严格模式中的函数有包含剩余参数、默认参数和解构赋值，那么<code>arguments</code>对象中的值不会跟踪参数的值（反之亦然）。相反, <code>arguments</code>反映了调用时提供的参数：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a = <span class="number">55</span></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">99</span>; <span class="comment">// updating arguments[0] does not also update a</span></span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">func(<span class="number">10</span>); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></p><p>并且<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a = <span class="number">55</span></span>) </span>&#123; </span><br><span class="line">  a = <span class="number">99</span>; <span class="comment">// updating a does not also update arguments[0]</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">func(<span class="number">10</span>); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></p><p>并且<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a = <span class="number">55</span></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">func(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p><h2 id="babel处理Symbol的麻烦（未理解）"><a href="#babel处理Symbol的麻烦（未理解）" class="headerlink" title="babel处理Symbol的麻烦（未理解）"></a>babel处理Symbol的麻烦（未理解）</h2><p>在使用 babel 转换 ES next 代码的时候，并不会将 Symbol 直接转换成 ES5 中对应的内容，需要引入额外的 polyfill 才能正常工作。</p><p>有的团队为了避免引入这个额外的 polyfill ，会选择不使用 Symbol ，包括通过 babel 生成 Symbol 的特性（比如 <code>for of</code> 等）。</p><p>这时候就会有个比较隐蔽的地方需要注意，就是尽量不要让 babel 生成这样的代码：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _typeof = <span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">"function"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Symbol</span>.iterator === <span class="string">"symbol"</span> ? <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">typeof</span> obj; &#125; : <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123; <span class="keyword">return</span> obj &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">"function"</span> &amp;&amp; obj.constructor === <span class="built_in">Symbol</span> &amp;&amp; obj !== <span class="built_in">Symbol</span>.prototype ? <span class="string">"symbol"</span> : <span class="keyword">typeof</span> obj; &#125;;</span><br></pre></td></tr></table></figure></p><p>这个里面包含了一个 <code>Symbol</code> ，为了让 <code>Symbol</code> 不至于报错，又要想办法在全局先声明一下 <code>Symbol</code> 变量，比较丑陋。</p><p>目前在实践中，发现这样的 ES next 代码会生成上述代码：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">        filter(<span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(a);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>生成的代码为：<br><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _typeof = <span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">"function"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Symbol</span>.iterator === <span class="string">"symbol"</span> ? <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">typeof</span> obj; &#125; : <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123; <span class="keyword">return</span> obj &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">"function"</span> &amp;&amp; obj.constructor === <span class="built_in">Symbol</span> &amp;&amp; obj !== <span class="built_in">Symbol</span>.prototype ? <span class="string">"symbol"</span> : <span class="keyword">typeof</span> obj; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> _ret = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">            filter(<span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(a);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                v: <span class="keyword">void</span> <span class="number">0</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">typeof</span> _ret === <span class="string">"undefined"</span> ? <span class="string">"undefined"</span> : _typeof(_ret)) === <span class="string">"object"</span>) <span class="keyword">return</span> _ret.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码有什么特征呢？就是在 <code>if</code> 块中定义了函数，函数中访问了 <code>if</code> 块中的“块级变量”，并且 <code>if</code> 块使用了 <code>return</code> 语句。</p><p>可以看出，<code>babel</code> 为了保证 <code>if</code> 块内变量的作用域，会套一个匿名函数，同时由于 <code>if</code> 块中存在 <code>return</code> 返回，所以就用 <code>_ret</code> 来接收匿名函数的返回值。然后后面为啥会生成那串长长的对 <code>_ret</code> 的类型判断代码，目前还不太清楚，可能要结合 <code>babel</code> 的内部处理逻辑去看了，单从生成的代码看，这个完全是多余的。</p><p>推而广之， <code>for</code> 块等局部非函数作用域都会有类似的问题。</p><p>实际上，从代码编写规范角度来看，是不应该在这种局部作用域块里面定义函数的。函数应该是一段通用的代码，不应该缩在那一小块里面。</p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> linearSearch </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>由linear search引出的getchar()输入字符和数字问题</title>
      <link href="/2018/01/31/c-getchar/"/>
      <url>/2018/01/31/c-getchar/</url>
      <content type="html"><![CDATA[<h1 id="由linear-search引出的getchar-输入字符和数字问题"><a href="#由linear-search引出的getchar-输入字符和数字问题" class="headerlink" title="由linear search引出的getchar()输入字符和数字问题"></a>由linear search引出的getchar()输入字符和数字问题</h1><p>@C—language </p><hr><blockquote><p>起因：在考研之际，重新拾起快忘光了的C语言，大一的时候没有认真学习，现在还真的发现好多以前遗漏了的问题<br>主要内容：C语言的获取字符输入方法getchar()，以及如何读取int型变量<br>操作系统：windows<br>编译器：Cygwin的gnu环境</p></blockquote><h2 id="getchar-的用途"><a href="#getchar-的用途" class="headerlink" title="getchar()的用途"></a>getchar()的用途</h2><p>初始代码（<code>linearSearch.c</code>)<br><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 10</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">linearSearch</span><span class="params">(<span class="keyword">int</span> [], <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> nums[LEN] = &#123;<span class="number">5</span>, <span class="number">10</span>, <span class="number">22</span>, <span class="number">32</span>, <span class="number">45</span>, <span class="number">67</span>, <span class="number">73</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">101</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> desiredElem, location;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Input the desired element, please: \n"</span>);</span><br><span class="line">desiredElem = getchar();</span><br><span class="line"></span><br><span class="line">location = linearSearch(nums, LEN, desiredElem);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(location != <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The desired element was found at index location %d.\n"</span>, location);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The desired element was not found in the list. the location is %d.\n"</span>, location);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this function returns the location of key in the list</span></span><br><span class="line"><span class="comment">// a -1 is returned if the value is not found</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">linearSearch</span><span class="params">(<span class="keyword">int</span> <span class="built_in">list</span>[], <span class="keyword">int</span> size, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"key = %d.\n"</span>, key);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">list</span>[i] == key)&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>乍看感觉这段代码还像模像样的，但是在Cygwin中编译结果：<br><figure class="hljs highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./cygwinTest.exe</span><br><span class="line">Input the desired element, please:</span><br><span class="line"><span class="number">10</span></span><br><span class="line">key = <span class="number">49</span>.</span><br><span class="line">The desired element was not found in the list. the location is -<span class="number">1</span>.</span><br></pre></td></tr></table></figure></p><p>可以轻易发现是getchar()方法出了问题，下面看看getchar()：</p><ul><li>名称：getchar()</li><li>定义：用在文件读取中，读取文件时要区分文件中有效数据与输入结束符的问题，C语言解决方法是，在没有输入时，getchar函数将返回一个特殊值，这个特殊值与任何实际字符都不同，成为“EOF”（文件结束符），为int类型</li><li>返回值类型：int类型(对应字符的ASCII值)</li><li>一般用法：<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">读一个字符</span><br><span class="line"><span class="keyword">while</span>(该字符不是EOF)</span><br><span class="line">    输出刚读入的字符</span><br><span class="line">    读下一个字符</span><br></pre></td></tr></table></figure></li></ul><p>转换为C：<br><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/* copy input to output; 1st version */</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c != EOF)&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(c);</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以找到问题的原因了：因为我们是要得到int型，但是getchar返回的是输入字符的ASCII码，所以就出错了，应该使用scanf函数：<br><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;desiredElem);</span><br></pre></td></tr></table></figure></p><p>编译结果如下：<br><figure class="hljs highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./cygwinTest.exe</span><br><span class="line">Input the desired element, please:</span><br><span class="line"><span class="number">22</span></span><br><span class="line">key = <span class="number">22</span>.</span><br><span class="line">The desired element was found at index location <span class="number">2</span>.</span><br></pre></td></tr></table></figure></p><blockquote><p>下面引出今天叙述的重点：C语言如何从键盘输入数据</p></blockquote><h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf()"></a>scanf()</h3><p>scanf == scan format，意思是格式化扫描，即从键盘获得用户输入<br>一般用法为：<br><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);  <span class="comment">//输入整数并赋值给变量a</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b);  <span class="comment">//输入整数并赋值给变量b</span></span><br></pre></td></tr></table></figure></p><p>scanf与printf非常相似：<br><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);  <span class="comment">// 获取用户输入的两个整数，分别赋值给变量 a 和 b</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d"</span>, a, b);  <span class="comment">// 将变量 a 和 b 的是在显示器上输出。</span></span><br></pre></td></tr></table></figure></p><p>它们都有格式控制字符串，都有变量列表。不同的是，scanf的变量前要带一个<code>&amp;</code>符号，称为“取地址符”，即获得变量在内存中的地址。<br>数据都是以二进制的形式保存在内存中的，字节（Byte）是最小的可操作单位。为了便于管理，我们给每个字节分配了一个编号，使用该字节时，只要知道编号就可以，就像每个学生都有学号，老师会随机抽取学号来让学生回答问题。字节的编号是有顺序的，从 0 开始，接下来是 1、2、3……<br>下图是 4G 内存中每个字节的编号（以十六进制表示）：</p><p><img src="https://raw.githubusercontent.com/Yojiaku/hexoBlogPic/676fef3df90d1f2b094c7ae72fa1503eceb5adae/2018-1-31charStore.png" alt="字节编号"></p><p>这个编号，就叫做<strong>地址（Address）</strong>。<code>int a;</code>    会在内存中分配四个字节的空间，我们将第一个字节的地址称为变量 a 的地址，也就是<code>&amp;a</code>的值。对于的整数、浮点数、字符，都要使用 &amp; 获取它们的地址，scanf 会根据地址把读取到的数据写入内存。<br>不妨将变量地址数出来看看：<br><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="string">'F'</span>;</span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">12</span>;</span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">452</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;a=%#x, &amp;b=%#x, &amp;c=%#x\n"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="hljs highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./scanfAddress.exe</span><br><span class="line">&amp;a=<span class="number">0</span>xffffcbfc, &amp;b=<span class="number">0</span>xffffcbf8, &amp;c=<span class="number">0</span>xffffcbf4</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/Yojiaku/hexoBlogPic/f516a7e74f92ebc1991939583757173687f6f561/2018-1-31charStore2.png" alt="abc变量内存地址"></p><blockquote><p>注意：这里看到的地址是虚拟地址，并不等于它在物理内存中的地址。虚拟地址是现代计算机因内存管理的需要才提出的概念。</p></blockquote><p>以上。</p>]]></content>
      
      
        <tags>
            
            <tag> C—language </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>markdown语法归纳</title>
      <link href="/2018/01/30/hello-hexo/"/>
      <url>/2018/01/30/hello-hexo/</url>
      <content type="html"><![CDATA[<p><a href="https://www.zybuluo.com/mdeditor" title="作业部落旗下 Cmd 在线 Markdown 编辑阅读器" target="_blank" rel="noopener">『Cmd 技术渲染的沙箱页面，点击此处编写自己的文档』</a></p><h1 id="Cmd-Markdown-简明语法手册"><a href="#Cmd-Markdown-简明语法手册" class="headerlink" title="Cmd Markdown 简明语法手册"></a>Cmd Markdown 简明语法手册</h1><p>标签： Cmd-Markdown</p><hr><h3 id="1-斜体和粗体"><a href="#1-斜体和粗体" class="headerlink" title="1. 斜体和粗体"></a>1. 斜体和粗体</h3><p>使用 * 和 ** 表示斜体和粗体。</p><p>示例：</p><p>这是 <em>斜体</em>，这是 <strong>粗体</strong>。</p><h3 id="2-分级标题"><a href="#2-分级标题" class="headerlink" title="2. 分级标题"></a>2. 分级标题</h3><p>使用 === 表示一级标题，使用 — 表示二级标题。</p><p>示例：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这是一个一级标题</span><br><span class="line">============================</span><br><span class="line"></span><br><span class="line">这是一个二级标题</span><br><span class="line">--------------------------------------------------</span><br><span class="line"></span><br><span class="line">### 这是一个三级标题</span><br></pre></td></tr></table></figure><p>你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。</p><h3 id="3-外链接"><a href="#3-外链接" class="headerlink" title="3. 外链接"></a>3. 外链接</h3><p>使用 [描述](链接地址) 为文字增加外链接。</p><p>示例：</p><p>这是去往 <a href="http://ghosertblog.github.com" target="_blank" rel="noopener">本人博客</a> 的链接。</p><h3 id="4-无序列表"><a href="#4-无序列表" class="headerlink" title="4. 无序列表"></a>4. 无序列表</h3><p>使用 *，+，- 表示无序列表。</p><p>示例：</p><ul><li>无序列表项 一</li><li>无序列表项 二</li><li>无序列表项 三</li></ul><h3 id="5-有序列表"><a href="#5-有序列表" class="headerlink" title="5. 有序列表"></a>5. 有序列表</h3><p>使用数字和点表示有序列表。</p><p>示例：</p><ol><li>有序列表项 一</li><li>有序列表项 二</li><li>有序列表项 三</li></ol><h3 id="6-文字引用"><a href="#6-文字引用" class="headerlink" title="6. 文字引用"></a>6. 文字引用</h3><p>使用 &gt; 表示文字引用。</p><p>示例：</p><blockquote><p>野火烧不尽，春风吹又生。</p></blockquote><h3 id="7-行内代码块"><a href="#7-行内代码块" class="headerlink" title="7. 行内代码块"></a>7. 行内代码块</h3><p>使用 `代码` 表示行内代码块。</p><p>示例：</p><p>让我们聊聊 <code>html</code>。</p><h3 id="8-代码块"><a href="#8-代码块" class="headerlink" title="8.  代码块"></a>8.  代码块</h3><p>使用 四个缩进空格 表示代码块。</p><p>示例：</p><pre><code>这是一个代码块，此行左侧有四个不可见的空格。</code></pre><h3 id="9-插入图像"><a href="#9-插入图像" class="headerlink" title="9.  插入图像"></a>9.  插入图像</h3><p>使用 ![描述](图片链接地址) 插入图像。</p><p>示例：</p><p><img src="https://www.zybuluo.com/static/img/my_head.jpg" alt="我的头像"></p><h1 id="Cmd-Markdown-高阶语法手册"><a href="#Cmd-Markdown-高阶语法手册" class="headerlink" title="Cmd Markdown 高阶语法手册"></a>Cmd Markdown 高阶语法手册</h1><h3 id="1-内容目录"><a href="#1-内容目录" class="headerlink" title="1. 内容目录"></a>1. 内容目录</h3><p>在段落中填写 <code>[TOC]</code> 以显示全文内容的目录结构。</p><p>[TOC]</p><h3 id="2-标签分类"><a href="#2-标签分类" class="headerlink" title="2. 标签分类"></a>2. 标签分类</h3><p>在编辑区任意行的列首位置输入以下代码给文稿标签：</p><p>标签： 数学 英语 Markdown</p><p>或者</p><p>Tags： 数学 英语 Markdown</p><h3 id="3-删除线"><a href="#3-删除线" class="headerlink" title="3. 删除线"></a>3. 删除线</h3><p>使用 ~~ 表示删除线。</p><p><del>这是一段错误的文本。</del></p><h3 id="4-注脚"><a href="#4-注脚" class="headerlink" title="4. 注脚"></a>4. 注脚</h3><p>使用 [^keyword] 表示注脚。</p><p>这是一个注脚[^footnote]的样例。</p><p>这是第二个注脚[^footnote2]的样例。</p><h3 id="5-LaTeX-公式"><a href="#5-LaTeX-公式" class="headerlink" title="5. LaTeX 公式"></a>5. LaTeX 公式</h3><p>$ 表示行内公式： </p><p>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</p><p>$$ 表示整行公式：</p><p>$$\sum_{i=1}^n a_i=0$$</p><p>$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$</p><p>$$\sum^{j-1}<em>{k=0}{\widehat{\gamma}</em>{kj} z_k}$$</p><p>访问 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">MathJax</a> 参考更多使用方法。</p><h3 id="6-加强的代码块"><a href="#6-加强的代码块" class="headerlink" title="6. 加强的代码块"></a>6. 加强的代码块</h3><p>支持四十一种编程语言的语法高亮的显示，行号显示。</p><p>非代码示例：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install vim-gnome</span><br></pre></td></tr></table></figure><p>Python 示例：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(param1=<span class="string">''</span>, param2=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">'''A docstring'''</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Greater'</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">'''interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt'''</span></span><br></pre></td></tr></table></figure><p>JavaScript 示例：</p><figure class="hljs highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* nth element in the fibonacci series.</span></span><br><span class="line"><span class="comment">* @param n &gt;= 0</span></span><br><span class="line"><span class="comment">* @return the nth element, &gt;= 0.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> tmp;</span><br><span class="line">  <span class="keyword">while</span> (--n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    tmp = a;</span><br><span class="line">    a += b;</span><br><span class="line">    b = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(fib(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><h3 id="7-流程图"><a href="#7-流程图" class="headerlink" title="7. 流程图"></a>7. 流程图</h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start:&gt;https://www.zybuluo.com</span><br><span class="line">io=&gt;inputoutput: verification</span><br><span class="line">op=&gt;operation: Your Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">sub=&gt;subroutine: Your Subroutine</span><br><span class="line">e=&gt;end</span><br><span class="line"></span><br><span class="line">st-&gt;io-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;sub-&gt;io</span><br></pre></td></tr></table></figure><h4 id="更多语法参考：流程图语法参考"><a href="#更多语法参考：流程图语法参考" class="headerlink" title="更多语法参考：流程图语法参考"></a>更多语法参考：<a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="noopener">流程图语法参考</a></h4><h3 id="8-序列图"><a href="#8-序列图" class="headerlink" title="8. 序列图"></a>8. 序列图</h3><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Title: Here is a title</span><br><span class="line">A-&gt;B: Normal line</span><br><span class="line">B--&gt;C: Dashed line</span><br><span class="line">C-&gt;&gt;D: Open arrow</span><br><span class="line">D--&gt;&gt;A: Dashed open arrow</span><br></pre></td></tr></table></figure><h4 id="更多语法参考：序列图语法参考"><a href="#更多语法参考：序列图语法参考" class="headerlink" title="更多语法参考：序列图语法参考"></a>更多语法参考：<a href="http://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="noopener">序列图语法参考</a></h4><h3 id="9-甘特图"><a href="#9-甘特图" class="headerlink" title="9. 甘特图"></a>9. 甘特图</h3><p>甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">title 项目开发流程</span><br><span class="line">section 项目确定</span><br><span class="line">    需求分析       :a1, 2016-06-22, 3d</span><br><span class="line">    可行性报告     :after a1, 5d</span><br><span class="line">    概念验证       : 5d</span><br><span class="line">section 项目实施</span><br><span class="line">    概要设计      :2016-07-05  , 5d</span><br><span class="line">    详细设计      :2016-07-08, 10d</span><br><span class="line">    编码          :2016-07-15, 10d</span><br><span class="line">    测试          :2016-07-22, 5d</span><br><span class="line">section 发布验收</span><br><span class="line">    发布: 2d</span><br><span class="line">    验收: 3d</span><br></pre></td></tr></table></figure><h4 id="更多语法参考：甘特图语法参考"><a href="#更多语法参考：甘特图语法参考" class="headerlink" title="更多语法参考：甘特图语法参考"></a>更多语法参考：<a href="https://knsv.github.io/mermaid/#gant-diagrams" target="_blank" rel="noopener">甘特图语法参考</a></h4><h3 id="10-Mermaid-流程图"><a href="#10-Mermaid-流程图" class="headerlink" title="10. Mermaid 流程图"></a>10. Mermaid 流程图</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A[Hard edge] --&gt;|Link text| B(Round edge)</span><br><span class="line">B --&gt; C&#123;Decision&#125;</span><br><span class="line">C --&gt;|One| D[Result one]</span><br><span class="line">C --&gt;|Two| E[Result two]</span><br></pre></td></tr></table></figure><h4 id="更多语法参考：Mermaid-流程图语法参考"><a href="#更多语法参考：Mermaid-流程图语法参考" class="headerlink" title="更多语法参考：Mermaid 流程图语法参考"></a>更多语法参考：<a href="https://knsv.github.io/mermaid/#flowcharts-basic-syntax" target="_blank" rel="noopener">Mermaid 流程图语法参考</a></h4><h3 id="11-Mermaid-序列图"><a href="#11-Mermaid-序列图" class="headerlink" title="11. Mermaid 序列图"></a>11. Mermaid 序列图</h3><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;John: Hello John, how are you?</span><br><span class="line">loop every minute</span><br><span class="line">    John--&gt;Alice: Great!</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="更多语法参考：Mermaid-序列图语法参考"><a href="#更多语法参考：Mermaid-序列图语法参考" class="headerlink" title="更多语法参考：Mermaid 序列图语法参考"></a>更多语法参考：<a href="https://knsv.github.io/mermaid/#sequence-diagrams" target="_blank" rel="noopener">Mermaid 序列图语法参考</a></h4><h3 id="12-表格支持"><a href="#12-表格支持" class="headerlink" title="12. 表格支持"></a>12. 表格支持</h3><table><thead><tr><th>项目</th><th style="text-align:right">价格</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td>计算机</td><td style="text-align:right">\$1600</td><td style="text-align:center">5</td></tr><tr><td>手机</td><td style="text-align:right">\$12</td><td style="text-align:center">12</td></tr><tr><td>管线</td><td style="text-align:right">\$1</td><td style="text-align:center">234</td></tr></tbody></table><h3 id="13-定义型列表"><a href="#13-定义型列表" class="headerlink" title="13. 定义型列表"></a>13. 定义型列表</h3><p>名词 1<br>:   定义 1（左侧有一个可见的冒号和四个不可见的空格）</p><p>代码块 2<br>:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）</p><pre><code>代码块（左侧有八个不可见的空格）</code></pre><h3 id="14-Html-标签"><a href="#14-Html-标签" class="headerlink" title="14. Html 标签"></a>14. Html 标签</h3><p>本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格：</p><pre><code>&lt;table&gt;    &lt;tr&gt;        &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt;        &lt;th&gt;星期一&lt;/th&gt;        &lt;th&gt;星期二&lt;/th&gt;        &lt;th&gt;星期三&lt;/th&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;李强&lt;/td&gt;        &lt;td&gt;张明&lt;/td&gt;        &lt;td&gt;王平&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;</code></pre><table><br>    <tr><br>        <th rowspan="2">值班人员</th><br>        <th>星期一</th><br>        <th>星期二</th><br>        <th>星期三</th><br>    </tr><br>    <tr><br>        <td>李强</td><br>        <td>张明</td><br>        <td>王平</td><br>    </tr><br></table><h3 id="15-内嵌图标"><a href="#15-内嵌图标" class="headerlink" title="15. 内嵌图标"></a>15. 内嵌图标</h3><p>本站的图标系统对外开放，在文档中输入</p><pre><code>&lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt;</code></pre><p>即显示微博的图标： <i class="icon-weibo icon-2x"></i></p><p>替换 上述 <code>i 标签</code> 内的 <code>icon-weibo</code> 以显示不同的图标，例如：</p><pre><code>&lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt;</code></pre><p>即显示人人的图标： <i class="icon-renren icon-2x"></i></p><p>更多的图标和玩法可以参看 <a href="http://fortawesome.github.io/Font-Awesome/3.2.1/icons/" target="_blank" rel="noopener">font-awesome</a> 官方网站。</p><h3 id="16-待办事宜-Todo-列表"><a href="#16-待办事宜-Todo-列表" class="headerlink" title="16. 待办事宜 Todo 列表"></a>16. 待办事宜 Todo 列表</h3><p>使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：</p><pre><code>- [ ] **Cmd Markdown 开发**    - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率    - [ ] 支持以 PDF 格式导出文稿    - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments)    - [x] 改进 LaTex 功能        - [x] 修复 LaTex 公式渲染问题        - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers)- [ ] **七月旅行准备**    - [ ] 准备邮轮上需要携带的物品    - [ ] 浏览日本免税店的物品    - [x] 购买蓝宝石公主号七月一日的船票</code></pre><p>对应显示如下待办事宜 Todo 列表：</p><ul><li style="list-style: none"><input type="checkbox"> <strong>Cmd Markdown 开发</strong><ul><li style="list-style: none"><input type="checkbox"> 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li><li style="list-style: none"><input type="checkbox"> 支持以 PDF 格式导出文稿</li><li style="list-style: none"><input type="checkbox" checked> 新增Todo列表功能 <a href="https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments" target="_blank" rel="noopener">语法参考</a></li><li style="list-style: none"><input type="checkbox" checked> 改进 LaTex 功能<ul><li style="list-style: none"><input type="checkbox" checked> 修复 LaTex 公式渲染问题</li><li style="list-style: none"><input type="checkbox" checked> 新增 LaTex 公式编号功能 <a href="http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers" target="_blank" rel="noopener">语法参考</a></li></ul></li></ul></li><li style="list-style: none"><input type="checkbox"> <strong>七月旅行准备</strong><ul><li style="list-style: none"><input type="checkbox"> 准备邮轮上需要携带的物品</li><li style="list-style: none"><input type="checkbox"> 浏览日本免税店的物品</li><li style="list-style: none"><input type="checkbox" checked> 购买蓝宝石公主号七月一日的船票</li></ul></li></ul><p>[^footnote]: 这是一个 <em>注脚</em> 的 <strong>文本</strong>。</p><p>[^footnote2]: 这是另一个 <em>注脚</em> 的 <strong>文本</strong>。</p>]]></content>
      
      
        <tags>
            
            <tag> markdown语法 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
  
</search>
