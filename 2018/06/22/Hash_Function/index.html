<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#33363b">
    <meta name="msapplication-TileColor" content="#33363b">
    
    
    
    <meta name="keywords" content="Life, ARIA, Hexo">
    
    
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
    
    
    <link rel="icon" type="image/png" sizes="192x192" href="/favicons/android-chrome-192x192.png">
    
    
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
    
    
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
    
    
    <link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#33363b">
    
    
    <link rel="manifest" href="/favicons/site.webmanifest">
    
    
    <meta name="msapplication-config" content="/favicons/browserconfig.xml">
    
    
    <link rel="alternate" href="/atom.xml" title="YOJIAKU" type="application/atom+xml" />
    
    
    <link rel="shortcut icon" type="image/x-icon" href="/favicons/favicon.ico">
    
    
    <link rel="stylesheet" type="text/css" href="/css/normalize.css">
    <link rel="stylesheet" type="text/css" href="/css/index.css">
    
    <link rel="stylesheet" type="text/css" href="/css/sidebar.css">
    
    
<link rel="stylesheet" type="text/css" href="/css/page.css">
<link rel="stylesheet" type="text/css" href="/css/post.css">

    <link rel="stylesheet" type="text/css" href="/css/custom.css">
    <link rel="stylesheet" type="text/css" href="/css/atom-one-dark.css">
    <link rel="stylesheet" type="text/css" href="/css/lightgallery.min.css">
    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script defer type="text/javascript" src="/js/util.js"></script>
    <script defer type="text/javascript" src="/js/scrollspy.js"></script>
    <script defer type="text/javascript" src="/js/fontawesome-all.min.js"></script>
    <script defer type="text/javascript" src="/js/lightgallery.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-fullscreen.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-hash.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-pager.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-thumbnail.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-zoom.min.js"></script>
    
    
    <script defer type="text/javascript" src="/js/search.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var searchPath = "search.xml";
      if (searchPath.length === 0) {
        searchPath = "search.xml";
      }
      var path = "/" + searchPath;
      searchFunc(path, "search-input", "search-result");
    });
    </script>
    
    
    <script defer type="text/javascript" src="/js/index.js"></script>
    
    <script defer type="text/javascript" src="/js/custom.js"></script>
    <title>散列方法 | YOJIAKU</title>
  </head>
  <body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"  data-spy="scroll" data-target=".list-group">
    
<header id="header" class="header" style="background: #33363b;">
  <div class="container">
    <div class="header-container">
      <div class="header-title">
        <h1 class="title"><a href="/">YOJIAKU</a></h1>
        <h2 class="subtitle"></h2>
      </div>
      <div class="logo">
        <img src="/images/ARIA_logo.png" alt="logo">
      </div>
    </div>
    
<nav id="nav" class="nav">
  <a id="nav-toggle" class="nav-toggle"><i class="fas fa-bars"></i></a>
  <ul id="menu">
    
    <li><a href="/">首页</a></li>
    
    <li><a href="/archives/">归档</a></li>
    
  </ul>
</nav>


  </div>
</header>


    <main id="main" class="main">
      <div class="container">
        <div class="main-container">
          <div class="content">
            
<div id="post" class="post">
  
  <article class="post-article card animate" itemscope itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="https://yojiaku.github.io/2018/06/22/Hash_Function/">
      <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
       <meta itemprop="name" content="yojiaku">
       <meta itemprop="description" content="">
       <meta itemprop="image" content="/images/myavatar.jpg">
      </span>
      <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
       <meta itemprop="name" content="YOJIAKU">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">散列方法</h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2018-06-22T22:03:13+08:00">2018-06-22 22:03:13</time></span>
        </span>
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      <h1 id="除法散列法"><a href="#除法散列法" class="headerlink" title="除法散列法"></a>除法散列法</h1><p>设<code>hash(key)=key mod m</code>，其中key表示被散列的关键字，而m则表示散列表的大小，mod则为取余操作。</p>
<p>这是一种比较简单的散列函数，但简单并不意味着高效。当待散列的元素之间存在某种模式时，这种散列法会有相当糟糕的性能表现。对该函数一个有用的指导原则是将m选取为接近待散列集合大小的质数。</p>
<h1 id="乘法散列法"><a href="#乘法散列法" class="headerlink" title="乘法散列法"></a>乘法散列法</h1><p>设 <code>hash(key)=floor(m×(A×key mod 1))</code>，其中floor()表示对表达式进行下取整，A∈(0,1)，m如上同样表示散列表的大小，且在这种方法中对m并无任何特殊的要求。<br>[A×key mod 1]表示将key乘上某个在0~1之间的数并取乘积的小数部分，该表达式等价于A×key-floor(A×key)</p>
<p>这里最重要的是A的值应该如何设定，Don•Knuth老大认为A=(√5-1)/2 [黄金分割点] 比较好。</p>
<h1 id="全域散列法"><a href="#全域散列法" class="headerlink" title="全域散列法"></a>全域散列法</h1><p>设<code>hasha,b(key)=(a×key+b) mod m</code>，如同除余散列法中一样，m的值应为质数，而a∈{1,2,3,…,m-1}，b∈{0,1,2,…,m-1}且a,b的值应在运行时动态确定。</p>
<p>全域散列的基本思想是给出hash函数的基本“骨架”，而其中的某些参数通过运行时在指定范围内随机选取确定，从而实际上形成了一个函数簇。根据上述a,b的取值范围，我们知道这个函数簇中存在m×(m-1)个函数。因为对于同一个输入，每次执行时选取不同的参数将拥有不同的性能表现，因此设计的函数实际上独立于任意被散列的关键字。只有当一个相对糟糕的输入——即该输入不构成随机分布，遇到一个选取的相对糟糕的散列函数时，才将导致较差的性能，在多数情况下这类散列往往具有较好的运行时性能表现。</p>
<h1 id="平方散列法"><a href="#平方散列法" class="headerlink" title="平方散列法"></a>平方散列法</h1><p>求hash(key)是非常频繁的操作，而乘法的运算要比除法更省时，所以考虑把除法换成乘法和一个位移操作，公式为： </p>
<blockquote>
<p>hash(key)= (key * key) &gt;&gt; 28   （右移28位，除以2^28。）</p>
</blockquote>
<p>如果数值分配比较均匀的话这种方法能得到不错的结果。</p>
<h1 id="斐波那契（Fibonacci）散列法"><a href="#斐波那契（Fibonacci）散列法" class="headerlink" title="斐波那契（Fibonacci）散列法"></a>斐波那契（Fibonacci）散列法</h1><p>为了解决平方散列法的缺点,我们需要找出一个理想的乘数，而不是拿key本身当作乘数。<br>1，对于16位整数而言，这个乘数是40503<br>2，对于32位整数而言，这个乘数是2654435769<br>3，对于64位整数而言，这个乘数是11400714819323198485<br>这几个“理想乘数”的得出跟一个法则有关，叫黄金分割法则，而描述黄金分割法则的最经典表达式无疑就是著名的斐波那契数列，即如此形式的序列：0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233,377, 610，987, 1597, 2584, 4181, 6765, 10946，… </p>
<p>常见的32位整数，使用公式： </p>
<blockquote>
<p>Hash（key）= (key * 2654435769) &gt;&gt; 28</p>
</blockquote>
<h1 id="加法Hash"><a href="#加法Hash" class="headerlink" title="加法Hash"></a>加法Hash</h1><p>所谓的加法Hash就是把输入元素一个一个的加起来构成最后的结果。标准的加法Hash的构造如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static int additiveHash(String key, int prime)</span><br><span class="line">&#123;</span><br><span class="line"> int hash, i;</span><br><span class="line"> for (hash = key.length(), i = 0; i &lt; key.length(); i++)</span><br><span class="line">  hash += key.charAt(i);</span><br><span class="line"> return (hash % prime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 这里的prime是任意的质数，看得出，结果的值域为[0,prime-1]。</p>
<h2 id="位运算Hash"><a href="#位运算Hash" class="headerlink" title="位运算Hash"></a>位运算Hash</h2><p>这类型Hash函数通过利用各种位运算（常见的是移位和异或）来充分的混合输入元素。比如，标准的旋转Hash的构造如下：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static int rotatingHash(String key, int prime)</span><br><span class="line">&#123;</span><br><span class="line">  int hash, i;</span><br><span class="line">  for (hash=key.length(), i=0; i&lt;key.length(); ++i)</span><br><span class="line">    hash = (hash&lt;&lt;4)^(hash&gt;&gt;28)^key.charAt(i);</span><br><span class="line">  return (hash % prime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先移位，然后再进行各种位运算是这种类型Hash函数的主要特点。比如，以上的那段计算hash的代码还可以有如下几种变形：</p>
<blockquote>
<ol>
<li>hash = (hash&lt;&lt;5)^(hash&gt;&gt;27)^key.charAt(i);</li>
<li>hash += key.charAt(i);<br>hash += (hash &lt;&lt; 10);<br>hash ^= (hash &gt;&gt; 6);</li>
<li>if((i&amp;1) == 0)<br>{<br> hash ^= (hash&lt;&lt;7) ^ key.charAt(i) ^ (hash&gt;&gt;3);<br>}<br>else<br>{<br> hash ^= ~((hash&lt;&lt;11) ^ key.charAt(i) ^ (hash &gt;&gt;5));<br>}</li>
<li>hash += (hash&lt;&lt;5) + key.charAt(i);</li>
<li>hash = key.charAt(i) + (hash&lt;&lt;6) + (hash&gt;&gt;16) – hash;</li>
<li>hash ^= ((hash&lt;&lt;5) + key.charAt(i) + (hash&gt;&gt;2));</li>
</ol>
</blockquote>
<h1 id="乘法Hash"><a href="#乘法Hash" class="headerlink" title="乘法Hash"></a>乘法Hash</h1><p>这种类型的Hash函数利用了乘法的不相关性（乘法的这种性质，最有名的莫过于平方取头尾的随机数生成算法，虽然这种算法效果并不好）。比如，<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static int bernstein(String key)</span><br><span class="line">&#123;</span><br><span class="line">  int hash = 0;</span><br><span class="line">  int i;</span><br><span class="line">  for (i=0; i&lt;key.length(); ++i) hash = 33*hash + key.charAt(i);</span><br><span class="line">  return hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>jdk5.0里面的String类的hashCode()方法也使用乘法Hash。不过，它使用的乘数是31。推荐的乘数还有：131, 1313, 13131, 131313等等。<br>使用这种方式的著名Hash函数还有：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//  32位FNV算法</span><br><span class="line">int M_SHIFT = 0;</span><br><span class="line">public int FNVHash(byte[] data)</span><br><span class="line">&#123;</span><br><span class="line">    int hash = (int)2166136261L;</span><br><span class="line">    for(byte b : data)</span><br><span class="line">        hash = (hash * 16777619) ^ b;</span><br><span class="line">    if (M_SHIFT == 0)</span><br><span class="line">        return hash;</span><br><span class="line">    return (hash ^ (hash &gt;&gt; M_SHIFT)) &amp; M_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以及改进的FNV算法：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static int FNVHash1(String data)</span><br><span class="line">&#123;</span><br><span class="line">    final int p = 16777619;</span><br><span class="line">    int hash = (int)2166136261L;</span><br><span class="line">    for(int i=0;i&lt;data.length();i++)</span><br><span class="line">        hash = (hash ^ data.charAt(i)) * p;</span><br><span class="line">    hash += hash &lt;&lt; 13;</span><br><span class="line">    hash ^= hash &gt;&gt; 7;</span><br><span class="line">    hash += hash &lt;&lt; 3;</span><br><span class="line">    hash ^= hash &gt;&gt; 17;</span><br><span class="line">    hash += hash &lt;&lt; 5;</span><br><span class="line">    return hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了乘以一个固定的数，常见的还有乘以一个不断改变的数，比如：<br><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static int RSHash(String str)</span><br><span class="line">&#123;</span><br><span class="line">    int b    = 378551;</span><br><span class="line">    int a    = 63689;</span><br><span class="line">    int hash = 0;</span><br><span class="line">   for(int i = 0; i &lt; str.length(); i++)</span><br><span class="line">   &#123;</span><br><span class="line">      hash = hash * a + str.charAt(i);</span><br><span class="line">      a    = a * b;</span><br><span class="line">   &#125;</span><br><span class="line">   return (hash &amp; 0x7FFFFFFF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>虽然Adler32算法的应用没有CRC32广泛，不过，它可能是乘法Hash里面最有名的一个。关于它的介绍，大家可以去看RFC 1950规范。</p>
<h1 id="除法Hash"><a href="#除法Hash" class="headerlink" title="除法Hash"></a>除法Hash</h1><p>除法和乘法一样，同样具有表面上看起来的不相关性。不过，因为除法太慢，这种方式几乎找不到真正的应用。需要注意的是，我们在前面看到的hash的 结果除以一个prime的目的只是为了保证结果的范围。如果你不需要它限制一个范围的话，可以使用如下的代码替代”hash%prime”：</p>
<blockquote>
<p>hash = hash ^ (hash&gt;&gt;10) ^ (hash&gt;&gt;20)。</p>
</blockquote>
<h1 id="查表Hash"><a href="#查表Hash" class="headerlink" title="查表Hash"></a>查表Hash</h1><p>查表Hash最有名的例子莫过于CRC系列算法。虽然CRC系列算法本身并不是查表，但是，查表是它的一种最快的实现方式。查表Hash中有名的例子有：Universal Hashing和Zobrist Hashing。他们的表格都是随机生成的。</p>
<h1 id="混合Hash"><a href="#混合Hash" class="headerlink" title="混合Hash"></a>混合Hash</h1><p>混合Hash算法利用了以上各种方式。各种常见的Hash算法，比如MD5、Tiger都属于这个范围。它们一般很少在面向查找的Hash函数里面使用。</p>
<h1 id="数组hash"><a href="#数组hash" class="headerlink" title="数组hash"></a>数组hash</h1><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inline int hashcode(const int *v)</span><br><span class="line">&#123;</span><br><span class="line">int s = 0;</span><br><span class="line">for(int i=0; i&lt;k; i++)</span><br><span class="line">s=((s&lt;&lt;2)+(v[i]&gt;&gt;4))^(v[i]&lt;&lt;10);</span><br><span class="line">s = s % M;</span><br><span class="line">s = s &lt; 0 ? s + M : s;</span><br><span class="line">return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </main>
    <footer class="post-footer">
      
      <div class="post-tags">
        
        
        
        
        <a class="post-tag button" href="/tags/算法/" style="background: #fc6423;" rel="tag"><i class="fas fa-tags"></i>算法</a>
        
        <a class="post-tag button" href="/tags/散列/" style="background: #a3bb54;" rel="tag"><i class="fas fa-tags"></i>散列</a>
        
      </div>
      
    </footer>
  </article>
  
  
  <div class="post-nav">
    <div class="post-nav-next post-nav-item">
      
      <a href="/2018/06/21/Heap/" rel="next" title="堆"><i class="fas fa-angle-left"></i><span class="nav-title">堆</span></a>
      
    </div>
    <div class="post-nav-prev post-nav-item">
      
      <a href="/2018/06/23/Hash/" rel="prev" title="散列"><span class="nav-title">散列</span><i class="fas fa-angle-right"></i></a>
      
    </div>
  </div>
  
  
</div>

          </div>
          
          
          
<aside class="sidebar" id="sidebar" style="background: url(/images/sidebar_background.png);">
  
  <div class="search">
    <div class="form-group">
      <i class="fas fa-search"></i><input type="search" id="search-input" name="q" results="0" placeholder="搜索" class="form-control"/>
    </div>
  </div>
  <div class="search-result-box" id="search-result"></div>
  
  
<div class="info sidebar-item" id="info">
  
  <img class="author-avatar" src="/images/myavatar.jpg" alt="yojiaku">
  
  <h1 class="author-name">yojiaku</h1>
  <h2 class="author-description"> </h2>
  <div class="site-count">
    
    <div class="archives-count">
      <div class="site-count-title">归档</div>
      <div><a href="/archives/">42</a></div>
    </div>
    
    
    
  </div>
  
  <div class="rss">
    <a class="rss-link button sidebar-item" href="/atom.xml"><i class="fas fa-rss"></i>RSS</a>
  </div>
  
</div>


  <div class="sidebar-sticky">
    
    




<hr>
<div class="post-toc sidebar-item" id="toc-div">
  <div><i class="fas fa-list-ol"></i>文章目录</div>
  <div class="post-toc-content"><ol class="list-group toc"><li class="toc-item toc-level-1"><a class="list-group-item toc-link" href="#除法散列法"><span class="toc-text">除法散列法</span></a></li><li class="toc-item toc-level-1"><a class="list-group-item toc-link" href="#乘法散列法"><span class="toc-text">乘法散列法</span></a></li><li class="toc-item toc-level-1"><a class="list-group-item toc-link" href="#全域散列法"><span class="toc-text">全域散列法</span></a></li><li class="toc-item toc-level-1"><a class="list-group-item toc-link" href="#平方散列法"><span class="toc-text">平方散列法</span></a></li><li class="toc-item toc-level-1"><a class="list-group-item toc-link" href="#斐波那契（Fibonacci）散列法"><span class="toc-text">斐波那契（Fibonacci）散列法</span></a></li><li class="toc-item toc-level-1"><a class="list-group-item toc-link" href="#加法Hash"><span class="toc-text">加法Hash</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#位运算Hash"><span class="toc-text">位运算Hash</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="list-group-item toc-link" href="#乘法Hash"><span class="toc-text">乘法Hash</span></a></li><li class="toc-item toc-level-1"><a class="list-group-item toc-link" href="#除法Hash"><span class="toc-text">除法Hash</span></a></li><li class="toc-item toc-level-1"><a class="list-group-item toc-link" href="#查表Hash"><span class="toc-text">查表Hash</span></a></li><li class="toc-item toc-level-1"><a class="list-group-item toc-link" href="#混合Hash"><span class="toc-text">混合Hash</span></a></li><li class="toc-item toc-level-1"><a class="list-group-item toc-link" href="#数组hash"><span class="toc-text">数组hash</span></a></li></ol></div>
</div>



    
    
    
<hr>
<div class="social-link sidebar-item">
  <div><i class="far fa-address-card"></i>社交链接</p></div>
  <ul>
    
    <li><i class="fas fa-envelope"></i><a href="mailto:2329082643@qq.com" target="_blank">E-Mail</a></li>
    
    <li><i class="fab fa-github"></i><a href="https://github.com/Yojiaku" target="_blank">GitHub</a></li>
    
    <li><i class="fab fa-weibo"></i><a href="https://weibo.com/3286626050/profile?rightmod=1&wvr=6&mod=personinfo" target="_blank">Weibo</a></li>
    
  </ul>
</div>


    
    
    
<hr>
<div class="blogroll sidebar-item">
  <div><i class="fas fa-link"></i>友情链接</div>
  <ul>
    
    <li><a href="https://github.com/Yojiaku" target="_blank">GitHub</a></li>
    
  </ul>
</div>


    
  </div>
</aside>


          
        </div>
      </div>
    </main>
    
<footer id="footer" class="footer" style="background: #33363b;">
  <div class="container">
    <div class="back-to-top">
      <a id="back-to-top"><i class="fas fa-angle-double-up"></i></a>
    </div>
    <div class="footer-container">
      <div class="footer-left">
        <div class="copyright">
          <span class="author">yojiaku</span><span class="year"><i class="far fa-copyright"></i>2018</span>
        </div>
        
      </div>
      <div class="footer-right">
        <div class="custom-info">
          
          托管于<i class="fab fa-github-alt"></i><a href="https://pages.github.com/" target="_blank">GitHub Pages</a>
          
        </div>
        <div class="powered-by">
          由 <a href="https://hexo.io/" target="_blank">Hexo</a> 强力驱动 | 主题 <a href="https://github.com/AlynxZhou/hexo-theme-aria/" target="_blank">ARIA</a>
        </div>
      </div>
    </div>
  </div>
</footer>


  </body>
</html>
